This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    release.yml
.vite/
  deps/
    _metadata.json
    package.json
docs/
  journals/
    251229-codebase-improvements.md
  code-standards.md
  codebase-summary.md
  project-overview-pdr.md
  system-architecture.md
plans/
  251226-1356-tauri-screenshot-app/
    research/
      researcher-01-tauri-setup.md
      researcher-02-react-konva.md
    phase-01-project-setup.md
    phase-02-screenshot-capture.md
    phase-03-canvas-editor.md
    phase-04-annotation-tools.md
    phase-05-beautification.md
    phase-06-export-system.md
    phase-07-native-integration.md
    phase-08-polish-distribution.md
    plan.md
  251231-0143-region-capture-overlay/
    plan.md
  260114-2249-codebase-improvement/
    plan.md
  260114-glassmorphism-spatial-design/
    phase-01-css-foundation.md
    phase-02-layout-structure.md
    phase-03-toolbar-redesign.md
    phase-04-sidebar-redesign.md
    phase-05-controls-overlays.md
    phase-06-screens-polish.md
    plan.md
  archive/
    251227-0444-codebase-improvements/
      phase-01-dry-constants.md
      phase-02-ux-improvements.md
      phase-03-backend-reliability.md
      phase-04-accessibility.md
      plan.md
public/
  screen-capture.aif
  tauri.svg
  vite.svg
src/
  assets/
    react.svg
  components/
    canvas/
      annotations/
        arrow-shape.tsx
        ellipse-shape.tsx
        freehand-shape.tsx
        number-shape.tsx
        rect-shape.tsx
        spotlight-shape.tsx
        text-shape.tsx
      annotation-layer.tsx
      background-layer.tsx
      canvas-editor.tsx
      crop-overlay.tsx
      drawing-preview.tsx
      text-edit-overlay.tsx
      text-input-overlay.tsx
      zoom-controls.tsx
    capture/
      window-picker-modal.tsx
    common/
      toast.tsx
    layout/
      editor-layout.tsx
    settings/
      settings-modal.tsx
    sidebar/
      background-panel.tsx
      crop-panel.tsx
      export-panel.tsx
      sidebar.tsx
    toolbar/
      tool-buttons.tsx
      tool-settings.tsx
      toolbar.tsx
      undo-redo-buttons.tsx
    ui/
      color-picker.tsx
    .gitkeep
    capture-flash.tsx
    permission-required.tsx
    region-overlay.tsx
  constants/
    annotations.ts
    canvas.ts
  data/
    __tests__/
      aspect-ratios.test.ts
      gradients.test.ts
    aspect-ratios.ts
    gradients.ts
    wallpapers.ts
  hooks/
    .gitkeep
    use-capture-feedback.ts
    use-click-away.ts
    use-drawing.ts
    use-export.ts
    use-hotkeys.ts
    use-image.ts
    use-keyboard-shortcuts.ts
    use-screenshot.ts
    use-sync-shortcuts.ts
    use-transform-handler.ts
  stores/
    __tests__/
      background-store.test.ts
      crop-store.test.ts
      export-store.test.ts
      settings-store.test.ts
    .gitkeep
    annotation-store.ts
    background-store.ts
    canvas-store.ts
    crop-store.ts
    export-store.ts
    history-store.ts
    settings-store.ts
    toast-store.ts
    ui-store.ts
  types/
    .gitkeep
    annotations.ts
    screenshot.ts
  utils/
    __tests__/
      export-utils.test.ts
    .gitkeep
    color-extractor.ts
    export-utils.ts
    file-api.ts
    hotkey-formatter.ts
    image-db.ts
    logger.ts
    sanitize.ts
    screenshot-api.ts
  App.tsx
  main.tsx
  overlay-main.tsx
  styles.css
  vite-env.d.ts
src-tauri/
  capabilities/
    default.json
  icons/
    128x128.png
    128x128@2x.png
    32x32.png
    icon.icns
    icon.ico
    icon.png
    Square107x107Logo.png
    Square142x142Logo.png
    Square150x150Logo.png
    Square284x284Logo.png
    Square30x30Logo.png
    Square310x310Logo.png
    Square44x44Logo.png
    Square71x71Logo.png
    Square89x89Logo.png
    StoreLogo.png
  src/
    clipboard.rs
    file_ops.rs
    lib.rs
    main.rs
    overlay.rs
    permissions.rs
    screenshot.rs
    shortcuts.rs
    tray.rs
  .gitignore
  beautyfullshot.desktop
  build.rs
  Cargo.toml
  entitlements.plist
  Info.plist
  tauri.conf.json
.gitignore
debug-app.mjs
debug-sidebar.html
index.html
LICENSE
overlay.html
package.json
README.md
tsconfig.json
tsconfig.node.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test -- --run --coverage

      - name: TypeScript check
        run: npx tsc --noEmit

  build-check:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-action@stable

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev

      - name: Install frontend dependencies
        run: npm ci

      - name: Build frontend
        run: npm run build

      - name: Check Rust compilation
        working-directory: src-tauri
        run: cargo check
</file>

<file path=".vite/deps/_metadata.json">
{
  "hash": "f998dfdd",
  "configHash": "ae31bb15",
  "lockfileHash": "7b0a2e4a",
  "browserHash": "f9051456",
  "optimized": {},
  "chunks": {}
}
</file>

<file path=".vite/deps/package.json">
{
  "type": "module"
}
</file>

<file path="docs/journals/251229-codebase-improvements.md">
# BeautyShot Codebase Improvements: 75% Complete

**Date**: 2025-12-29 14:22
**Severity**: Medium
**Component**: Frontend & Backend Architecture
**Status**: Partial - 3/4 phases complete

## What Happened

Started systematic codebase cleanup on 2025-12-27 based on comprehensive code review. Plan covered 4 phases addressing DRY violations, UX gaps, backend reliability, and accessibility. Currently at 75% completion with phases 01, 02, 04 fully implemented. Phase 03 (backend reliability) remains pending.

## The Brutal Truth

We identified real issues that should've been caught earlier: duplicate constants across components, silent error handling in Rust that masks failures, and missing accessibility features. The frustrating part? Most of these were low-effort fixes that would've prevented tech debt accumulation.

Phase 03 remains incomplete despite being the highest priority—silent error handling in 17 unwrap_or() calls and PNG buffer reallocations are still live. This is a real gap because production errors are currently swallowed without proper feedback.

## Technical Details

### Completed (Phases 01, 02, 04)

**Phase 01 - DRY Violations:**
- Created `/src/constants/canvas.ts` with ZOOM object
- Consolidated ZOOM_FACTOR (was duplicated in canvas-editor.tsx + zoom-controls.tsx)
- Consolidated MIN_SCALE/MAX_SCALE definitions
- Removed all hardcoded magic numbers
- Result: Single source of truth, 0 duplicates

**Phase 02 - UX Improvements:**
- Created `/src/hooks/use-click-away.ts` with mousedown + ESC handlers
- Fixed window dropdown closure (was missing outside click detection)
- Integrated with toolbar.tsx for proper dropdown behavior
- Status: Loading spinners and auto-dismiss errors fully implemented

**Phase 04 - Accessibility:**
- Added aria-label to all interactive buttons (capture, zoom, clear)
- Implemented aria-live regions for zoom level announcements
- Set proper ARIA roles (listbox, option) for window dropdown
- Added role, tabIndex management for keyboard navigation
- Keyboard: Arrow keys + Enter for dropdown selection

### Not Done (Phase 03 - Backend Reliability)

**Critical Issues Still Live:**
1. **Error Handling**: 17 remaining `unwrap_or()` calls in Rust
   - Silently default to 0 instead of propagating failures
   - Located across screenshot.rs, permissions.rs
2. **PNG Encoding**: No pre-allocation, reallocates repeatedly
   - Estimated 2-4MB overhead per screenshot for large images
3. **No Structured Errors**: Generic string errors instead of typed enum
4. **Late Validation**: capture_region() validates AFTER expensive operations

## What We Tried

- Planned implementation with specific file targets
- Created detailed phase docs with code snippets
- Successfully executed phases 01, 02, 04 with full code integration
- Phase 03 required Rust structural refactoring + testing

## Root Cause Analysis

Phase 03 wasn't completed likely because:
1. **Complexity**: Requires creating error.rs + modifying multiple Rust files
2. **Testing**: Changes need validation with actual screenshots
3. **Priority Shift**: Newer features (export system, native integration) took precedence
4. **Effort**: Estimated 3h, highest complexity relative to other phases

The real issue: Backend stability work got deprioritized for feature development. This is typical but risky—silent errors in production are worse than missing features.

## Lessons Learned

1. **Frontend improvements are quick wins** - DRY fixes, UX polish, A11y took ~5h total and immediate ROI
2. **Backend refactoring needs dedicated time** - Can't tack it onto feature sprints; needs focused blocks
3. **Constant consolidation prevents compound complexity** - Small duplicates snowball fast (we found them at 390 LOC; imagine at 5000)
4. **Error handling is non-negotiable** - Silent failures are worse than crashes; typed errors prevent downstream bugs

## Next Steps

1. **Complete Phase 03** - Dedicate 3h block to backend reliability
   - Create src-tauri/src/error.rs with ScreenshotError enum
   - Replace all unwrap_or(0) with proper error propagation
   - Pre-allocate PNG buffer (Vec::with_capacity)
   - Add early validation in capture_region()

2. **Test Coverage** - Verify PNG encoding doesn't reallocate
   - Benchmark pre-alloc vs current approach

3. **Remove Unused** - Delete greet command from lib.rs

4. **Document** - Update architecture docs with error handling patterns

---

## Summary

Created comprehensive improvement plan covering 4 phases. Successfully implemented frontend improvements (DRY violations, UX, accessibility). Backend reliability work remains—17 unwrap_or() calls and PNG allocation still need attention. Phases 01/02/04 are production-ready; Phase 03 should be completed before next release.

**Unresolved Questions:**
- Should Phase 03 have been higher priority? (Yes)
- What blocked its completion? (Feature prioritization)
- Buffer pre-allocation size estimate accurate? (Needs benchmark)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/research/researcher-01-tauri-setup.md">
# Research Report: Tauri v2 Project Setup & Screenshot Capture

**Research Date**: 2025-12-26 | **Language**: Vietnamese/English | **Max Length**: ~150 lines

## Executive Summary

Tauri v2 cho phép xây dựng ứng dụng desktop cross-platform với React + TypeScript + Rust. Xcap crate cung cấp API capture screenshot đơn giản. Tauri plugins (global-shortcut, system-tray, notification) tích hợp dễ dàng. IPC communication hỗ trợ binary data qua `tauri::ipc::Response`. Platform-specific concerns: macOS yêu cầu Privacy permissions, Linux Wayland cần support riêng.

## Methodology

**Sources**: 5 research queries (Tauri docs, xcap docs, Web searches)
**Date Range**: Latest Tauri v2 (2024-2025) documentation
**Key Terms**: Tauri v2, create-tauri-app, xcap, screenshot, IPC, plugins, permissions

---

## 1. Tauri v2 Project Setup

### Create & Structure
```bash
npm create tauri-app@latest
# Select: React + TypeScript
```

**Project Layout**:
```
my-app/
├── src/              # React + TypeScript frontend
├── src-tauri/        # Rust backend + config
│   ├── src/main.rs
│   ├── Cargo.toml
│   └── tauri.conf.json
└── package.json
```

### Requirements
- **Rust**: 1.70.0+ (verify: `rustc --version`)
- **Node.js**: LTS
- `tauri-build`, `serde`, `serde_json` dependencies

### Key Config (tauri.conf.json)
```json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "devPath": "http://localhost:5173"
  },
  "capabilities": {
    "main": {
      "commands": ["capture_screenshot"],
      "permissions": ["path:default", "window:default"]
    }
  }
}
```

---

## 2. Xcap Library Integration

### API Overview
Xcap (v0.8.0+) = **cross-platform screenshot crate** supporting Windows, macOS, Linux (X11/Wayland).

**Main Types**:
- `Monitor` → fullscreen, region capture
- `Window` → window-specific capture

### Usage Examples

**Fullscreen Capture**:
```rust
use xcap::Monitor;

let monitors = Monitor::all().unwrap();
for monitor in monitors {
    let image = monitor.capture_image().unwrap();
    // image.bytes() → PNG data
}
```

**Region Capture**:
```rust
let region_image = monitors[0]
    .capture_region(x: 0, y: 0, width: 1024, height: 768)
    .unwrap();
```

**Window Capture**:
```rust
use xcap::Window;

let windows = Window::all().unwrap();
for window in windows {
    println!("{}: {}", window.app_name(), window.title());
    let image = window.capture_image().unwrap();
}
```

### Key Points
- Returns `image::Image` struct with `.bytes()` for PNG data
- Returns **binary PNG data** (not base64) → ideal for IPC
- No external dependencies (pure Rust)

---

## 3. Tauri Plugins

### Global Shortcut
```rust
// src-tauri/src/main.rs
#[cfg(desktop)]
app.handle().plugin(tauri_plugin_global_shortcut::Builder::new().build());
```

**JS Frontend**:
```ts
import { register } from '@tauri-apps/plugin-global-shortcut';
await register('CommandOrControl+Shift+C', () => {
    console.log('Screenshot triggered');
});
```

**Capabilities**:
```json
{
  "global-shortcut:allow-register": true,
  "global-shortcut:allow-unregister": true
}
```

### System Tray
```rust
use tauri::{SystemTray, SystemTrayMenu, CustomMenuItem};

let quit = CustomMenuItem::new("quit".to_string(), "Quit");
let tray_menu = SystemTrayMenu::new().add_item(quit);

tauri::Builder::default()
    .system_tray(SystemTray::new().with_menu(tray_menu))
    .on_system_tray_event(|app, event| {
        // Handle click/menu events
    })
```

### Notification
```rust
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_notification::init())
        .run(tauri::generate_context!())
}
```

**JS Frontend**:
```ts
import { sendNotification, isPermissionGranted, requestPermission }
    from '@tauri-apps/plugin-notification';

let permission = await isPermissionGranted();
if (!permission) permission = await requestPermission();

sendNotification({
    title: 'Screenshot Saved',
    body: 'File saved to clipboard'
});
```

---

## 4. IPC Communication

### Binary Data (Screenshot) Transfer

**Rust Command**:
```rust
use tauri::ipc::Response;

#[tauri::command]
fn capture_screenshot() -> Result<Vec<u8>, String> {
    let image = xcap::Monitor::all()
        .unwrap()[0]
        .capture_image()
        .unwrap();
    Ok(image.bytes().to_vec())
}
```

**TypeScript Frontend**:
```ts
import { invoke } from '@tauri-apps/api/tauri';

const imageBytes = await invoke<Uint8Array>('capture_screenshot');
const blob = new Blob([imageBytes], { type: 'image/png' });
const url = URL.createObjectURL(blob);
// Display or process image
```

### Performance Notes
- JSON serialization bottleneck for large data
- Use `tauri::ipc::Response` for optimized binary return
- Channel API available for streaming (bidirectional)

---

## 5. Platform-Specific Considerations

### macOS
- **Permission Issue**: Screen capture requires Privacy → Screen Capture permission
- **Workaround**: Use `tauri-plugin-macos-permissions` to request/check permissions
- **Notarization**: App signing needed for distribution (bundle-identifier, certificate)
- **Template Icon**: System tray icon needs `iconAsTemplate: true` for dark mode

### Linux
- **X11**: Native support via xcap
- **Wayland**: Requires portal support (still developing in xcap ecosystem)
- **Caveat**: Wayland screenshot access limited, may need additional permissions

### Windows
- **UAC**: Runs with normal user permissions by default
- **No special permissions needed** for screenshot capture
- **Visual Styles**: Supports system theme detection

### Permission System
Tauri v2 uses capability-based security:
```json
{
  "permissions": [
    "core:path:default",
    "core:window:default",
    "plugin:notification:allow-*"
  ]
}
```

---

## Resources & References

### Official Documentation
- [Tauri v2 Docs](https://v2.tauri.app/)
- [Xcap crate](https://crates.io/crates/xcap)
- [IPC Communication Guide](https://v2.tauri.app/concept/inter-process-communication/)
- [Permissions & Capabilities](https://v2.tauri.app/security/permissions/)

### GitHub Repositories
- [Xcap GitHub](https://github.com/nashaofu/xcap)
- [Tauri GitHub](https://github.com/tauri-apps/tauri)

### Community
- Tauri Discord, GitHub Discussions
- Rust community (Rust forum, Reddit r/rust)

---

## Common Gotchas

1. **macOS Permissions**: App crashes on screenshot without Privacy approval
2. **Wayland**: Xcap may not capture on Linux Wayland (use X11 fallback)
3. **Binary Serialization**: Don't use `serde_json` for images (use raw bytes)
4. **Capability Mismatch**: Forgot to add command to capabilities → 403 access denied
5. **Rust Version**: Older Rust toolchain causes build failures (update with `rustup update`)

---

## Quick Start Checklist

- [ ] Install Rust 1.70+, Node.js LTS
- [ ] Run `npm create tauri-app@latest`
- [ ] Add xcap to `src-tauri/Cargo.toml`
- [ ] Add screenshot command in `main.rs`
- [ ] Register command in `tauri.conf.json` capabilities
- [ ] Add global shortcut plugin
- [ ] Test on macOS (check Privacy permissions)
- [ ] Test on Windows & Linux (Wayland warning)

---

## Unresolved Questions

- Xcap video recording API maturity (marked as WIP)
- Exact Wayland permission model for screenshot capture
- App signing certificate requirements for macOS distribution
- Screenshot performance on high-DPI displays across platforms
</file>

<file path="plans/251226-1356-tauri-screenshot-app/research/researcher-02-react-konva.md">
# Báo Cáo Nghiên Cứu: React-Konva Canvas & Annotation Tools

**Ngày:** 26/12/2025 | **Phạm vi:** React-Konva setup, annotation tools, image manipulation, export

---

## Tóm Tắt Điều Hành

React-Konva là declarative binding cho Konva.js, cho phép xây dựng canvas graphics phức tạp bằng React. **Khuyến nghị:** Dùng `react-konva@18.x` cho React 18 (phiên bản 19.x chỉ support React 19+). Hỗ trợ đầy đủ TypeScript, React Context (fixed từ v18.2.2), và SSR friendly với dynamic imports. Performance tốt với batchdraw(), layer management, và caching.

---

## 1. React-Konva Setup & Integration

### React 18 + TypeScript
```bash
npm install react-konva@18 konva
```

**Cấu trúc cơ bản:**
```tsx
import { Stage, Layer, Rect, Text, Image as KonvaImage } from 'react-konva';

export function CanvasEditor() {
  const stageRef = useRef(null);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });

  return (
    <Stage
      ref={stageRef}
      width={canvasSize.width}
      height={canvasSize.height}
      onWheel={handleZoom}
    >
      <Layer>
        <KonvaImage image={imgElement} x={0} y={0} />
        <Rect x={50} y={50} width={100} height={100} fill="blue" draggable />
        <Text text="Annotation" x={100} y={100} fontSize={16} />
      </Layer>
    </Stage>
  );
}
```

### Next.js Integration
Dùng dynamic imports với `ssr: false` để avoid server-side rendering issues:
```tsx
const CanvasEditor = dynamic(() => import('./CanvasEditor'), { ssr: false });
```

---

## 2. Annotation Tools Implementation

### Supported Shapes
- **Core:** Rect, Circle, Ellipse, Line, Star, RegularPolygon
- **Text:** Text, TextPath (curved text)
- **Advanced:** Label, SVG Path, Custom Shapes
- **Arrows:** Konva.Arrow (cảnh báo: Transformer support kém với arrows)

### Drawing Rectangle & Ellipse
```tsx
<Rect
  x={20} y={20}
  width={100} height={60}
  fill="rgba(0,0,255,0.3)"
  stroke="blue"
  strokeWidth={2}
  draggable
  onDragEnd={(e) => console.log(e.target.x())}
/>

<Ellipse
  x={150} y={150}
  radiusX={50} radiusY={30}
  fill="rgba(255,0,0,0.3)"
  stroke="red"
/>
```

### Text Annotations + Auto-increment Counter
```tsx
function TextAnnotation({ id, x, y, text, fontSize = 16, fontFamily = 'Arial' }) {
  return (
    <Text
      text={`${id}. ${text}`}
      x={x} y={y}
      fontSize={fontSize}
      fontFamily={fontFamily}
      fill="black"
      draggable
      onTransformEnd={(e) => console.log('text moved')}
    />
  );
}

// Usage: auto-increment từ state
const [annotationCount, setAnnotationCount] = useState(0);
const addAnnotation = (x, y, text) => {
  setAnnotationCount(c => c + 1);
  // Create TextAnnotation với id = annotationCount
};
```

### Spotlight/Dimming Effect
Dùng clipping region + custom layer để tạo spotlight:
```tsx
<Layer clip={{ x: spotX, y: spotY, width: 200, height: 200 }} opacity={1}>
  <Image image={imgElement} />
</Layer>

// Hoặc dùng filter (Blur) + Layer Composition
<Layer filters={[Konva.Filters.Blur]} blurRadius={15}>
  <Image image={imgElement} opacity={0.5} />
</Layer>
```

---

## 3. Image Manipulation & Transformation

### Image Cropping (Non-destructive)
```tsx
<Image
  image={imgElement}
  x={0} y={0}
  crop={{ x: 20, y: 20, width: 300, height: 200 }}
  scaleX={1.2} scaleY={1.2}
  draggable
/>
```

### Aspect Ratio Lock + Transformer
```tsx
import { Transformer } from 'react-konva';

const ASPECT_RATIO = 16/9;

<Transformer
  ref={transformerRef}
  boundBoxFunc={(oldBox, newBox) => {
    // Lock aspect ratio
    if (newBox.width / newBox.height > ASPECT_RATIO) {
      newBox.height = newBox.width / ASPECT_RATIO;
    } else {
      newBox.width = newBox.height * ASPECT_RATIO;
    }
    return newBox;
  }}
/>
```

### Gradient Background
```tsx
const gradient = ctx => {
  const grd = ctx.createLinearGradient(0, 0, stage.width(), 0);
  grd.addColorStop(0, '#ff0000');
  grd.addColorStop(1, '#0000ff');
  return grd;
};

<Rect x={0} y={0} width={800} height={600} fill={gradient} />
```

---

## 4. Export Functionality

### Export to PNG/JPEG
```tsx
const exportImage = async (format = 'image/png', quality = 0.9) => {
  const dataURL = stageRef.current.toDataURL({
    mimeType: format,
    quality: quality,
    pixelRatio: window.devicePixelRatio || 1
  });

  // Download
  const link = document.createElement('a');
  link.href = dataURL;
  link.download = `screenshot-${Date.now()}.png`;
  link.click();
};
```

### High-DPI / Retina Support
```tsx
// Export với pixelRatio = 2 cho 2x resolution (retina)
const highQualityExport = () => {
  const dataURL = stageRef.current.toDataURL({
    pixelRatio: 2, // 500x500 stage → 1000x1000 export
    mimeType: 'image/png'
  });
};

// Canvas rendering: Konva tự handle nếu stage có pixelRatio property
<Stage pixelRatio={window.devicePixelRatio} width={800} height={600} />
```

---

## 5. Responsive Canvas & Performance

### Responsive Sizing
```tsx
useEffect(() => {
  const handleResize = () => {
    const containerWidth = containerRef.current?.offsetWidth || 800;
    const scale = containerWidth / 1000; // Virtual scene width = 1000
    setCanvasSize({
      width: containerWidth,
      height: 600 * scale
    });
  };

  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);
```

### Performance Optimizations

| Technique | Lợi ích | Cách dùng |
|-----------|---------|----------|
| **batchDraw()** | Giới hạn redraws/sec | `layer.batchDraw()` thay vì `draw()` |
| **Layer Listening** | Giảm event listeners | `layer.listening(false)` nếu layer không cần events |
| **Shape Caching** | Cache complex shapes | `shape.cache()` để convert thành bitmap |
| **Dedicated Layer** | Tối ưu drag performance | Move dragging shape sang layer riêng, drag xong move back |
| **Minimize Layers** | Mỗi layer = canvas element | Keep layers < 20 để avoid overhead |
| **Mobile Viewport** | Tránh scaling overhead | `<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">` |

**Cảnh báo:** Transformers hỗ trợ tốt cho Rect, Circle, Text nhưng kém cho Arrows & Stars.

---

## 6. Chú Ý Quan Trọng

- **React Context:** Fixed từ v18.2.2, dùng version mới
- **TypeScript:** Full type support, definition file có sẵn
- **Arrows + Transformer:** Tránh combine, dùng bounding box alternative
- **Export Quality:** pixelRatio=2 cho retina, quality=0.8-1.0 cho JPEG
- **Canvas Clipping:** Hỗ trợ crop + clip kết hợp: crop → scale/rotate → clip

---

## Tài Liệu & Tham Khảo

**Official:**
- [React-Konva Docs](https://konvajs.org/docs/react/index.html)
- [Konva Shapes Guide](https://konvajs.org/docs/react/Shapes.html)
- [Performance Tips](https://konvajs.org/docs/performance/All_Performance_Tips.html)
- [High-Quality Export](https://konvajs.org/docs/data_and_serialization/High-Quality-Export.html)
- [GitHub: react-konva](https://github.com/konvajs/react-konva)

**Community:**
- [LogRocket: Canvas Manipulation with React Konva](https://blog.logrocket.com/canvas-manipulation-react-konva/)
- [Medium: Annotation Tool with Konva](https://medium.com/htc-research-engineering-blog/konva-use-konva-to-create-annotation-tool-34409bfa822b)
- [Coding Buddy: Image Annotation App Tutorial](https://www.coding-buddy.com/post/how-to-draw-shapes-on-html-canvas-using-konvajs-creating-image-annotation-app/)

---

## Câu Hỏi Chưa Giải Quyết

1. Custom spotlight effect implementation chi tiết (blur + gradient combine)?
2. Benchmark: Performance với 100+ annotations on 4K image?
3. Undo/Redo mechanism best practices cho annotation history?
</file>

<file path="plans/251231-0143-region-capture-overlay/plan.md">
---
title: "Fullscreen Dimmed Overlay Region Capture"
description: "Add interactive fullscreen overlay for selecting screen regions with crosshair cursor and visual feedback"
status: pending
priority: P1
effort: 6h
branch: main
tags: [feature, screenshot, overlay, tauri-window]
created: 2025-12-31
---

# Fullscreen Dimmed Overlay Region Capture

## Overview

Implement interactive region selection using a fullscreen transparent overlay window. User clicks region capture button, main app hides, overlay appears with crosshair cursor for drag-selection, then captures selected region.

## Architecture Decision

**Approach: Separate Overlay Window (React + Tauri)**

Why not pure-Rust overlay:
- Tauri already has React webview infrastructure
- Consistent styling with existing app
- Easier to maintain (single codebase)
- Crosshair cursor + visual feedback simpler in CSS/Canvas

Why not native OS selection (like macOS screencapture -i):
- Not cross-platform
- Less control over UX
- Inconsistent with app design

## Technical Flow

```
1. User clicks Region Capture button
2. Main window hides
3. Capture fullscreen screenshot (base64) → store temporarily
4. Create overlay window (fullscreen, transparent, always-on-top)
5. Display screenshot as background with dim overlay
6. User draws selection rectangle
7. ESC → close overlay, show main window
8. Mouse release → get coordinates, close overlay
9. Crop captured image using coordinates
10. Show main window with cropped screenshot
```

## Implementation Phases

---

### Phase 1: Overlay Window Infrastructure (2h)

**Goal:** Create and manage overlay window from Rust backend

#### 1.1 Rust: Overlay Window Commands

File: `src-tauri/src/overlay.rs` (new)

```rust
use tauri::{AppHandle, Manager, WebviewUrl, WebviewWindowBuilder, LogicalPosition, LogicalSize};

/// Create fullscreen transparent overlay window
#[tauri::command]
pub async fn create_overlay_window(app: AppHandle) -> Result<(), String> {
    // Get primary monitor dimensions
    let monitors = app.available_monitors().map_err(|e| e.to_string())?;
    let primary = monitors.iter()
        .find(|m| m.is_primary().unwrap_or(false))
        .or(monitors.first())
        .ok_or("No monitor found")?;

    let size = primary.size();
    let position = primary.position();

    // Create overlay window
    WebviewWindowBuilder::new(
        &app,
        "region-overlay",
        WebviewUrl::App("overlay.html".into())
    )
    .title("Region Selection")
    .inner_size(size.width as f64, size.height as f64)
    .position(position.x as f64, position.y as f64)
    .fullscreen(false)  // Manual fullscreen via size
    .decorations(false)
    .transparent(true)
    .always_on_top(true)
    .skip_taskbar(true)
    .focused(true)
    .build()
    .map_err(|e| e.to_string())?;

    Ok(())
}

/// Close overlay window
#[tauri::command]
pub async fn close_overlay_window(app: AppHandle) -> Result<(), String> {
    if let Some(window) = app.get_webview_window("region-overlay") {
        window.close().map_err(|e| e.to_string())?;
    }
    Ok(())
}

/// Get primary monitor info for overlay sizing
#[tauri::command]
pub fn get_primary_monitor_info(app: AppHandle) -> Result<MonitorBounds, String> {
    let monitors = app.available_monitors().map_err(|e| e.to_string())?;
    let primary = monitors.iter()
        .find(|m| m.is_primary().unwrap_or(false))
        .or(monitors.first())
        .ok_or("No monitor found")?;

    let size = primary.size();
    let position = primary.position();
    let scale = primary.scale_factor();

    Ok(MonitorBounds {
        x: position.x,
        y: position.y,
        width: size.width,
        height: size.height,
        scale_factor: scale,
    })
}

#[derive(serde::Serialize)]
pub struct MonitorBounds {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub scale_factor: f64,
}
```

#### 1.2 Register Commands

File: `src-tauri/src/lib.rs`

```rust
mod overlay;

// Add to invoke_handler:
overlay::create_overlay_window,
overlay::close_overlay_window,
overlay::get_primary_monitor_info,
```

#### 1.3 Overlay HTML Entry Point

File: `overlay.html` (new, at project root)

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Region Selection</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
    }
    #root { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/overlay-main.tsx"></script>
</body>
</html>
```

#### 1.4 Vite Config Update

File: `vite.config.ts`

```typescript
// Add to rollupOptions.input:
build: {
  rollupOptions: {
    input: {
      main: 'index.html',
      overlay: 'overlay.html',
    },
    // ... existing output config
  },
},
```

#### 1.5 Tauri Config Update

File: `src-tauri/tauri.conf.json`

Update `app.security.csp` to allow overlay:
```json
"security": {
  "csp": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: asset: https://asset.localhost blob:; connect-src ipc: http://ipc.localhost"
}
```

---

### Phase 2: Overlay React Component (2h)

**Goal:** Build region selection UI with crosshair cursor and selection rectangle

#### 2.1 Overlay Entry Point

File: `src/overlay-main.tsx` (new)

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { RegionOverlay } from './components/region-overlay';
import './styles.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RegionOverlay />
  </React.StrictMode>
);
```

#### 2.2 Region Overlay Component

File: `src/components/region-overlay.tsx` (new)

```tsx
import { useState, useEffect, useCallback, useRef } from 'react';
import { getCurrentWindow } from '@tauri-apps/api/window';
import { invoke } from '@tauri-apps/api/core';
import { emit } from '@tauri-apps/api/event';

interface SelectionRect {
  startX: number;
  startY: number;
  endX: number;
  endY: number;
}

export function RegionOverlay() {
  const [isSelecting, setIsSelecting] = useState(false);
  const [selection, setSelection] = useState<SelectionRect | null>(null);
  const [screenshotUrl, setScreenshotUrl] = useState<string | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Load screenshot passed from main window
  useEffect(() => {
    const loadScreenshot = async () => {
      // Screenshot data is passed via window.__SCREENSHOT_DATA__
      const data = (window as any).__SCREENSHOT_DATA__;
      if (data) {
        setScreenshotUrl(data);
      }
    };
    loadScreenshot();
  }, []);

  // Handle ESC to cancel
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        cancelSelection();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const cancelSelection = useCallback(async () => {
    await emit('region-selection-cancelled');
    const win = getCurrentWindow();
    await win.close();
  }, []);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    setIsSelecting(true);
    setSelection({
      startX: e.clientX,
      startY: e.clientY,
      endX: e.clientX,
      endY: e.clientY,
    });
  }, []);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isSelecting || !selection) return;
    setSelection(prev => prev ? {
      ...prev,
      endX: e.clientX,
      endY: e.clientY,
    } : null);
  }, [isSelecting, selection]);

  const handleMouseUp = useCallback(async () => {
    if (!isSelecting || !selection) return;
    setIsSelecting(false);

    // Calculate normalized rectangle (handle drag in any direction)
    const x = Math.min(selection.startX, selection.endX);
    const y = Math.min(selection.startY, selection.endY);
    const width = Math.abs(selection.endX - selection.startX);
    const height = Math.abs(selection.endY - selection.startY);

    // Minimum selection size
    if (width < 10 || height < 10) {
      cancelSelection();
      return;
    }

    // Emit selection coordinates to main window
    await emit('region-selected', { x, y, width, height });

    const win = getCurrentWindow();
    await win.close();
  }, [isSelecting, selection, cancelSelection]);

  // Calculate selection box style
  const getSelectionStyle = (): React.CSSProperties => {
    if (!selection) return { display: 'none' };

    const x = Math.min(selection.startX, selection.endX);
    const y = Math.min(selection.startY, selection.endY);
    const width = Math.abs(selection.endX - selection.startX);
    const height = Math.abs(selection.endY - selection.startY);

    return {
      position: 'absolute',
      left: x,
      top: y,
      width,
      height,
      border: '2px dashed #fff',
      backgroundColor: 'transparent',
      boxShadow: '0 0 0 9999px rgba(0, 0, 0, 0.5)',
      pointerEvents: 'none',
    };
  };

  return (
    <div
      ref={containerRef}
      className="region-overlay-container"
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      style={{
        position: 'fixed',
        inset: 0,
        cursor: 'crosshair',
        backgroundColor: 'rgba(0, 0, 0, 0.3)',
        userSelect: 'none',
      }}
    >
      {/* Screenshot background (optional - for reference) */}
      {screenshotUrl && (
        <img
          src={screenshotUrl}
          alt=""
          style={{
            position: 'absolute',
            inset: 0,
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            opacity: 0.7,
            pointerEvents: 'none',
          }}
        />
      )}

      {/* Selection rectangle */}
      <div style={getSelectionStyle()} />

      {/* Instructions */}
      {!isSelecting && (
        <div
          style={{
            position: 'absolute',
            bottom: 40,
            left: '50%',
            transform: 'translateX(-50%)',
            color: '#fff',
            fontSize: 14,
            backgroundColor: 'rgba(0, 0, 0, 0.7)',
            padding: '8px 16px',
            borderRadius: 4,
            pointerEvents: 'none',
          }}
        >
          Drag to select region · ESC to cancel
        </div>
      )}

      {/* Selection dimensions tooltip */}
      {isSelecting && selection && (
        <div
          style={{
            position: 'absolute',
            left: Math.min(selection.startX, selection.endX),
            top: Math.min(selection.startY, selection.endY) - 28,
            color: '#fff',
            fontSize: 12,
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            padding: '4px 8px',
            borderRadius: 4,
            pointerEvents: 'none',
          }}
        >
          {Math.abs(selection.endX - selection.startX)} × {Math.abs(selection.endY - selection.startY)}
        </div>
      )}
    </div>
  );
}
```

---

### Phase 3: Integration with Main App (1.5h)

**Goal:** Wire up toolbar button to trigger overlay flow and handle results

#### 3.1 Screenshot API Extension

File: `src/utils/screenshot-api.ts`

Add new functions:

```typescript
import { WebviewWindow } from '@tauri-apps/api/webviewWindow';
import { listen, emit } from '@tauri-apps/api/event';

interface MonitorBounds {
  x: number;
  y: number;
  width: number;
  height: number;
  scale_factor: number;
}

/**
 * Get primary monitor bounds for overlay positioning
 */
export async function getPrimaryMonitorInfo(): Promise<MonitorBounds> {
  return await invoke<MonitorBounds>("get_primary_monitor_info");
}

/**
 * Start region capture flow with overlay
 * Returns selected region coordinates or null if cancelled
 */
export async function startRegionCapture(): Promise<CaptureRegion | null> {
  const appWindow = getCurrentWindow();

  // Hide main window
  await appWindow.hide();
  await delay(HIDE_DELAY_MS);

  return new Promise(async (resolve) => {
    // Listen for selection result
    const unlistenSelected = await listen<CaptureRegion>('region-selected', (event) => {
      cleanup();
      resolve(event.payload);
    });

    const unlistenCancelled = await listen('region-selection-cancelled', () => {
      cleanup();
      resolve(null);
    });

    const cleanup = async () => {
      unlistenSelected();
      unlistenCancelled();
      // Show main window
      await appWindow.show();
      await appWindow.setFocus();
    };

    // Create overlay window
    try {
      await invoke('create_overlay_window');
    } catch (e) {
      cleanup();
      throw e;
    }
  });
}

/**
 * Capture region with interactive overlay selection
 */
export async function captureRegionInteractive(): Promise<Uint8Array | null> {
  // Get region from overlay
  const region = await startRegionCapture();
  if (!region) return null;

  // Capture the selected region
  const base64 = await invoke<string>("capture_region", {
    x: Math.round(region.x),
    y: Math.round(region.y),
    width: Math.round(region.width),
    height: Math.round(region.height),
  });

  return base64ToBytes(base64);
}
```

#### 3.2 useScreenshot Hook Update

File: `src/hooks/use-screenshot.ts`

Add new method:

```typescript
import * as api from "../utils/screenshot-api";

// Add to UseScreenshotReturn interface:
captureRegionInteractive: () => Promise<Uint8Array | null>;

// Add to hook implementation:
const captureRegionInteractive = useCallback(async (): Promise<Uint8Array | null> => {
  setLoading(true);
  setError(null);
  try {
    const bytes = await api.captureRegionInteractive();
    return bytes;
  } catch (e) {
    setError(String(e));
    return null;
  } finally {
    setLoading(false);
  }
}, []);

// Add to return:
captureRegionInteractive,
```

#### 3.3 Toolbar Integration

File: `src/components/toolbar/toolbar.tsx`

Update region capture button handler:

```tsx
// Import
const { captureFullscreen, captureWindow, captureRegionInteractive, getWindows, loading, error, waylandWarning } = useScreenshot();

// Add handler
const handleCaptureRegion = useCallback(async () => {
  const bytes = await captureRegionInteractive();
  if (bytes) {
    try {
      triggerFeedback();
      const { width, height } = await getImageDimensions(bytes);
      setImageFromBytes(bytes, width, height);
      setTimeout(() => fitToView(), 50);
    } catch (e) {
      logError('Toolbar:captureRegion', e);
    }
  }
}, [captureRegionInteractive, setImageFromBytes, fitToView, triggerFeedback]);

// Update button onClick:
<button
  onClick={handleCaptureRegion}
  disabled={loading}
  // ... rest unchanged
>
```

---

### Phase 4: DPI Scaling & Polish (0.5h)

**Goal:** Handle high-DPI displays correctly and add visual polish

#### 4.1 DPI-Aware Coordinate Conversion

File: `src/components/region-overlay.tsx`

Add scale factor handling:

```typescript
const [scaleFactor, setScaleFactor] = useState(1);

useEffect(() => {
  const getScaleFactor = async () => {
    const win = getCurrentWindow();
    const factor = await win.scaleFactor();
    setScaleFactor(factor);
  };
  getScaleFactor();
}, []);

// In handleMouseUp, convert logical to physical pixels:
const physicalX = Math.round(x * scaleFactor);
const physicalY = Math.round(y * scaleFactor);
const physicalWidth = Math.round(width * scaleFactor);
const physicalHeight = Math.round(height * scaleFactor);

await emit('region-selected', {
  x: physicalX,
  y: physicalY,
  width: physicalWidth,
  height: physicalHeight
});
```

#### 4.2 Visual Enhancements

- Crosshair cursor on selection start
- Animated selection border (subtle pulse)
- Corner resize handles (visual only for v1)
- Smooth fade-in on overlay appear

---

## File Summary

| File | Action | Description |
|------|--------|-------------|
| `src-tauri/src/overlay.rs` | Create | Rust commands for overlay window |
| `src-tauri/src/lib.rs` | Modify | Register overlay module |
| `overlay.html` | Create | HTML entry for overlay window |
| `vite.config.ts` | Modify | Multi-page build config |
| `src-tauri/tauri.conf.json` | Modify | CSP for blob URLs |
| `src/overlay-main.tsx` | Create | React entry for overlay |
| `src/components/region-overlay.tsx` | Create | Overlay selection component |
| `src/utils/screenshot-api.ts` | Modify | Add interactive capture API |
| `src/hooks/use-screenshot.ts` | Modify | Add captureRegionInteractive |
| `src/components/toolbar/toolbar.tsx` | Modify | Wire up region button |

## Testing Checklist

- [ ] Overlay appears on region button click
- [ ] Main window hides before overlay shows
- [ ] Crosshair cursor active in overlay
- [ ] Selection rectangle draws correctly (all 4 directions)
- [ ] ESC cancels and returns to main app
- [ ] Mouse release captures region
- [ ] Captured image loads in canvas
- [ ] Works on 1x and 2x DPI displays
- [ ] No flickering or visual artifacts

## Known Limitations (v1)

1. **Primary monitor only** - Multi-monitor support deferred
2. **No resize handles** - Selection is one-shot, no adjustment
3. **macOS transparency** - May require `macos-private-api` feature (App Store incompatible)

## Dependencies

No new npm/cargo dependencies required. Uses existing:
- `@tauri-apps/api` (window, event, invoke)
- Tauri v2 WebviewWindowBuilder

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Transparent window broken on Windows | Test early; fallback to opaque dim |
| DPI coords off by factor | Use scaleFactor conversion |
| Overlay stuck on crash | Add timeout auto-close |
| Memory leak from screenshot blob | Use URL.revokeObjectURL |

## Unresolved Questions

1. Should overlay show actual screenshot or just dimmed screen?
   - Current plan: Dimmed overlay only (simpler, less memory)
   - Alternative: Show frozen screenshot (more accurate preview)

2. macOS App Store compatibility with `macos-private-api`?
   - If targeting App Store, may need alternative approach (native screencapture)

3. Multi-monitor support timeline?
   - Suggest Phase 2 feature after core flow validated
</file>

<file path="plans/260114-2249-codebase-improvement/plan.md">
# Codebase Improvement Plan

**Date:** 2026-01-14
**Status:** Draft
**Priority:** Medium

---

## Executive Summary

Full codebase review completed. **Overall Score: 8/10**. No critical bugs or security vulnerabilities. Main areas for improvement: component size reduction, accessibility gaps, and performance optimization via selectors.

---

## Review Reports

| Area | Score | Report |
|------|-------|--------|
| Rust Backend | 8.5/10 | [rust-backend.md](../reports/code-review-260114-2249-rust-backend.md) |
| React Components | 7.5/10 | [react-components.md](../reports/code-review-260114-2249-react-components.md) |
| Hooks & Utils | 8.5/10 | [hooks-utils.md](../reports/code-review-260114-2249-hooks-utils.md) |
| Zustand Stores | 7.5/10 | [stores.md](../reports/code-review-260114-2249-stores.md) |

---

## Key Findings

### Critical Issues: **None**

### High Priority (5)
1. **8 components exceed 200 LOC** - background-panel.tsx largest at 495 LOC
2. **Missing selectors** - 600+ store accesses causing unnecessary re-renders
3. **Accessibility gaps** - region-overlay, crop-overlay lack keyboard nav
4. **Cross-store coupling** - annotation/canvas/history tightly linked
5. **Linux grim PATH risk** - external binary without validation

### Medium Priority (8)
6. Missing memoization in expensive calculations
7. Code duplication (modal patterns, PNG encoding)
8. Error information leakage to frontend
9. Magic numbers scattered across files
10. Mutex poisoning handling needs documentation
11. No devtools middleware for debugging
12. Callback storage anti-pattern in annotation-store
13. UserAgent sniffing instead of Tauri platform API

---

## Improvement Phases

| Phase | Focus | Status | Link |
|-------|-------|--------|------|
| 01 | Security Hardening | Pending | [phase-01](./phase-01-security-hardening.md) |
| 02 | Component Splitting | Pending | [phase-02](./phase-02-component-splitting.md) |
| 03 | Performance Optimization | Pending | [phase-03](./phase-03-performance-optimization.md) |
| 04 | Accessibility | Pending | [phase-04](./phase-04-accessibility.md) |
| 05 | Code Quality | Pending | [phase-05](./phase-05-code-quality.md) |

---

## Quick Wins (Do Now)
- [ ] Add grim binary path validation (Linux)
- [ ] Extract magic numbers to constants
- [ ] Add devtools middleware to stores
- [ ] Remove unused `cropRect` from deps array

---

## Metrics

| Metric | Current | Target |
|--------|---------|--------|
| Avg Component Size | 332 LOC | <200 LOC |
| Store Selector Usage | 0% | 80% |
| Accessibility Score | 5/10 | 8/10 |
| Type Coverage | 100% | 100% |
| Build Status | Clean | Clean |

---

## Unresolved Questions

1. Should wallpaper parsing move to Web Worker?
2. Is 150ms delay in region-overlay sufficient for all platforms?
3. What's the expected max annotations count? (affects memoization strategy)
4. Should implement virtual scrolling for large window lists?
5. Timeline for production error tracking (Sentry)?
</file>

<file path="plans/260114-glassmorphism-spatial-design/phase-01-css-foundation.md">
---
title: "Phase 1: CSS Foundation"
status: pending
effort: 1h
---

# Phase 1: CSS Foundation

## Overview
Establish Tailwind CSS v4 utilities and CSS custom properties for glassmorphism and spatial design tokens.

## Context Links
- [Main Plan](./plan.md)
- Current styles: `src/styles.css`

## Key Insights
- Tailwind v4 uses `@theme` for custom properties
- backdrop-filter well-supported (97%+ browsers)
- CSS custom properties enable theme switching

## Requirements

### Functional
- Glass effect utility classes
- Spatial design tokens (gaps, shadows, radii)
- Light/dark mode glass variants

### Non-Functional
- Zero impact on existing functionality
- Minimal CSS bundle increase

## Implementation

### File: `src/styles.css`

Add after line 4 (after `@custom-variant dark`):

```css
/* ===========================================
   GLASSMORPHISM DESIGN TOKENS
   =========================================== */

/* Light mode glass */
:root {
  /* Glass backgrounds */
  --glass-bg: rgba(255, 255, 255, 0.75);
  --glass-bg-light: rgba(255, 255, 255, 0.5);
  --glass-bg-heavy: rgba(255, 255, 255, 0.9);

  /* Glass borders */
  --glass-border: rgba(255, 255, 255, 0.4);
  --glass-border-subtle: rgba(0, 0, 0, 0.06);

  /* Glass effects */
  --glass-blur: 16px;
  --glass-blur-heavy: 24px;

  /* Spatial design */
  --panel-radius: 16px;
  --panel-radius-sm: 12px;
  --panel-radius-lg: 20px;
  --panel-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  --panel-shadow-lg: 0 12px 48px rgba(0, 0, 0, 0.15);
  --gap-layout: 12px;

  /* Canvas background for spatial effect */
  --canvas-bg: #e5e5e5;
}

/* Dark mode glass */
.dark {
  --glass-bg: rgba(30, 30, 30, 0.85);
  --glass-bg-light: rgba(40, 40, 40, 0.7);
  --glass-bg-heavy: rgba(20, 20, 20, 0.95);

  --glass-border: rgba(255, 255, 255, 0.1);
  --glass-border-subtle: rgba(255, 255, 255, 0.05);

  --panel-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  --panel-shadow-lg: 0 12px 48px rgba(0, 0, 0, 0.5);

  --canvas-bg: #1a1a1a;
}

/* ===========================================
   GLASSMORPHISM UTILITY CLASSES
   =========================================== */

/* Standard glass panel */
.glass {
  background: var(--glass-bg);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--glass-border);
  box-shadow: var(--panel-shadow);
}

/* Light glass variant */
.glass-light {
  background: var(--glass-bg-light);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--glass-border);
}

/* Heavy glass (more opaque) */
.glass-heavy {
  background: var(--glass-bg-heavy);
  backdrop-filter: blur(var(--glass-blur-heavy));
  -webkit-backdrop-filter: blur(var(--glass-blur-heavy));
  border: 1px solid var(--glass-border);
  box-shadow: var(--panel-shadow-lg);
}

/* Glass with no shadow (for nested elements) */
.glass-flat {
  background: var(--glass-bg-light);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--glass-border-subtle);
}

/* ===========================================
   SPATIAL LAYOUT UTILITIES
   =========================================== */

/* Floating panel base */
.floating-panel {
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
}

/* Layout gaps */
.spatial-gap {
  gap: var(--gap-layout);
  padding: var(--gap-layout);
}

/* Canvas area background */
.canvas-area {
  background: var(--canvas-bg);
}

/* ===========================================
   ENHANCED BUTTON STATES
   =========================================== */

/* Glass button hover */
.glass-btn {
  background: var(--glass-bg-light);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid var(--glass-border-subtle);
  transition: all 0.2s ease;
}

.glass-btn:hover {
  background: var(--glass-bg);
  border-color: var(--glass-border);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.dark .glass-btn:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* Active/selected glass button */
.glass-btn-active {
  background: rgba(249, 115, 22, 0.15);
  border-color: rgba(249, 115, 22, 0.4);
}

.dark .glass-btn-active {
  background: rgba(249, 115, 22, 0.2);
  border-color: rgba(249, 115, 22, 0.3);
}
```

## Todo List
- [ ] Add CSS custom properties for glass tokens
- [ ] Add glass utility classes
- [ ] Add spatial layout utilities
- [ ] Add enhanced button states
- [ ] Test in both light and dark modes
- [ ] Verify no existing styles break

## Success Criteria
- Glass utility classes available for use
- CSS variables work in both light/dark modes
- No breaking changes to existing UI

## Risk Assessment
- **Low**: CSS additions only, no modifications to existing rules
- **Mitigation**: Utility class approach = opt-in usage

## Next Steps
Proceed to [Phase 2: Layout Structure](./phase-02-layout-structure.md)
</file>

<file path="plans/260114-glassmorphism-spatial-design/phase-02-layout-structure.md">
---
title: "Phase 2: Layout Structure"
status: pending
effort: 1h
---

# Phase 2: Layout Structure

## Overview
Transform `editor-layout.tsx` to create spatial gaps between main sections (toolbar, canvas, sidebar) for floating panel effect.

## Context Links
- [Main Plan](./plan.md)
- [Phase 1: CSS Foundation](./phase-01-css-foundation.md)
- File: `src/components/layout/editor-layout.tsx`

## Key Insights
- Current layout: flex column with toolbar on top, content area below
- Need gaps around canvas area to create floating effect
- Canvas background should be visible through gaps
- Toolbar and sidebar float above canvas visually

## Requirements

### Functional
- 12px gap between toolbar and content
- 12px gap between canvas and sidebar
- Visible canvas background through gaps
- Toolbar floats at top
- Sidebar floats on right

### Non-Functional
- Maintain existing functionality
- Responsive behavior preserved
- No layout shift on load

## Architecture

### Current Structure
```
<div h-screen flex-col>
  <Toolbar /> (h-14, border-b)
  <div flex-1 flex>
    <div flex-1> <Canvas/> <ZoomControls/> </div>
    <Sidebar /> (w-80, border-l)
  </div>
</div>
```

### New Structure
```
<div h-screen flex-col canvas-area p-3>
  <Toolbar /> (floating, glass, rounded)
  <div flex-1 flex gap-3 mt-3>
    <div flex-1 relative> <Canvas/> <ZoomControls/> </div>
    <Sidebar /> (floating, glass, rounded)
  </div>
</div>
```

## Implementation

### File: `src/components/layout/editor-layout.tsx`

**Replace lines 26-50:**

```tsx
return (
  <div className="h-screen w-screen flex flex-col overflow-hidden canvas-area p-3">
    {/* Top toolbar - floating glass panel */}
    <Toolbar />

    {/* Main content area with spatial gap */}
    <div className="flex-1 flex min-h-0 overflow-hidden mt-3 gap-3">
      {/* Canvas area - no background, shows through */}
      <div className="flex-1 relative min-w-0 overflow-hidden rounded-2xl bg-white/50 dark:bg-black/30">
        <CanvasEditor />
        <ZoomControls />
      </div>

      {/* Right sidebar - floating glass panel */}
      <Sidebar />
    </div>

    {/* Window picker modal */}
    <WindowPickerModal
      isOpen={isWindowPickerOpen}
      onClose={closeWindowPicker}
      onCapture={handleWindowCapture}
    />
  </div>
);
```

## Related Code Files

| File | Action | Purpose |
|------|--------|---------|
| `src/components/layout/editor-layout.tsx` | Modify | Add spatial layout |

## Todo List
- [ ] Update root container with canvas-area background
- [ ] Add padding to root container
- [ ] Add gap between toolbar and content
- [ ] Add gap between canvas and sidebar
- [ ] Add subtle background to canvas wrapper
- [ ] Test layout in light/dark modes
- [ ] Verify window picker modal still works

## Success Criteria
- Visible gaps between toolbar, canvas, sidebar
- Canvas background visible in gaps
- Floating panel effect achieved
- No functionality regression

## Risk Assessment
- **Medium**: Layout changes could affect canvas sizing
- **Mitigation**: Canvas uses flex-1 + relative positioning, should adapt

## Next Steps
Proceed to [Phase 3: Toolbar Redesign](./phase-03-toolbar-redesign.md)
</file>

<file path="plans/260114-glassmorphism-spatial-design/phase-03-toolbar-redesign.md">
---
title: "Phase 3: Toolbar Redesign"
status: pending
effort: 1h
---

# Phase 3: Toolbar Redesign

## Overview
Transform toolbar from flat bordered bar to floating glass panel with rounded corners and subtle shadow.

## Context Links
- [Main Plan](./plan.md)
- [Phase 2: Layout Structure](./phase-02-layout-structure.md)
- File: `src/components/toolbar/toolbar.tsx`
- File: `src/components/toolbar/tool-buttons.tsx`
- File: `src/components/toolbar/tool-settings.tsx`
- File: `src/components/toolbar/undo-redo-buttons.tsx`

## Key Insights
- Current: `h-14 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700`
- Glass needs: backdrop-blur, semi-transparent, rounded corners, shadow
- Keep orange accent for capture buttons and active states
- Dividers should be subtle glass-style

## Requirements

### Functional
- Glass effect on toolbar container
- Rounded corners (16px)
- Subtle shadow for elevation
- Glass-style dividers between sections
- Preserve all button functionality

### Non-Functional
- Smooth hover transitions
- Consistent with sidebar glass effect

## Implementation

### File: `src/components/toolbar/toolbar.tsx`

**Current line 61:**
```tsx
<div className="h-14 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 flex items-center px-3 gap-2 overflow-visible">
```

**Replace with:**
```tsx
<div className="h-14 glass floating-panel flex items-center px-4 gap-3 overflow-visible">
```

**Update dividers (lines 118, 126, 134):**

Current:
```tsx
<div className="w-px h-7 bg-gray-300 dark:bg-gray-600 flex-shrink-0" />
```

Replace with:
```tsx
<div className="w-px h-7 bg-black/10 dark:bg-white/10 flex-shrink-0" />
```

**Update capture buttons (lines 65-101):**

Replace button classes:
```tsx
className="w-10 h-10 flex items-center justify-center border-2 border-orange-500 text-orange-500 rounded-xl glass-btn hover:border-orange-400 disabled:opacity-50 transition-all"
```

**Update clear button (lines 106-114):**
```tsx
className="px-4 py-2 bg-gray-500/80 backdrop-blur-sm text-white rounded-xl hover:bg-gray-600/90 font-medium text-sm flex-shrink-0 transition-all"
```

**Update settings button (lines 155-180):**
```tsx
className="w-9 h-9 flex items-center justify-center text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 glass-btn rounded-xl flex-shrink-0"
```

### File: `src/components/toolbar/tool-buttons.tsx`

**Update tool button classes (line 40-47):**

Current:
```tsx
className={`w-9 h-9 flex items-center justify-center rounded-lg text-base font-medium border ${
  currentTool === tool.type
    ? 'border-orange-500 text-orange-500 bg-orange-50 dark:bg-orange-900/20'
    : 'border-transparent bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200'
}`}
```

Replace:
```tsx
className={`w-9 h-9 flex items-center justify-center rounded-xl text-base font-medium transition-all ${
  currentTool === tool.type
    ? 'glass-btn-active border border-orange-500/50 text-orange-500'
    : 'glass-btn text-gray-700 dark:text-gray-200'
}`}
```

### File: `src/components/toolbar/tool-settings.tsx`

**Update color buttons (lines 32-43):**
```tsx
className={`w-6 h-6 rounded-lg transition-all ${
  strokeColor === color
    ? 'ring-2 ring-orange-500 ring-offset-2 ring-offset-white/50 dark:ring-offset-black/50'
    : 'ring-1 ring-black/10 dark:ring-white/10 hover:ring-black/20 dark:hover:ring-white/20'
}`}
```

**Update width buttons (lines 51-59):**
```tsx
className={`w-7 h-7 flex items-center justify-center rounded-lg transition-all ${
  strokeWidth === width
    ? 'glass-btn-active border border-orange-500/50'
    : 'glass-btn'
}`}
```

### File: `src/components/toolbar/undo-redo-buttons.tsx`

**Update undo button (lines 15-24):**
```tsx
className={`w-9 h-9 flex items-center justify-center rounded-xl transition-all ${
  canUndo
    ? 'glass-btn text-gray-700 dark:text-gray-200'
    : 'opacity-40 cursor-not-allowed text-gray-400 dark:text-gray-600'
}`}
```

**Update redo button (lines 37-46):**
```tsx
className={`w-9 h-9 flex items-center justify-center rounded-xl transition-all ${
  canRedo
    ? 'glass-btn text-gray-700 dark:text-gray-200'
    : 'opacity-40 cursor-not-allowed text-gray-400 dark:text-gray-600'
}`}
```

## Related Code Files

| File | Action | Purpose |
|------|--------|---------|
| `src/components/toolbar/toolbar.tsx` | Modify | Glass toolbar container |
| `src/components/toolbar/tool-buttons.tsx` | Modify | Glass tool buttons |
| `src/components/toolbar/tool-settings.tsx` | Modify | Glass settings buttons |
| `src/components/toolbar/undo-redo-buttons.tsx` | Modify | Glass undo/redo |

## Todo List
- [ ] Update toolbar container with glass class
- [ ] Update dividers to glass-style
- [ ] Update capture buttons to glass-btn
- [ ] Update tool buttons to glass-btn
- [ ] Update color/width selectors
- [ ] Update undo/redo buttons
- [ ] Update settings button
- [ ] Test all button interactions
- [ ] Verify dark mode appearance

## Success Criteria
- Toolbar has glass blur effect
- Rounded corners visible
- Shadow provides elevation
- All buttons remain functional
- Orange accent preserved for active states

## Risk Assessment
- **Low**: Class changes only, no structural changes
- **Mitigation**: Glass utilities are additive

## Next Steps
Proceed to [Phase 4: Sidebar Redesign](./phase-04-sidebar-redesign.md)
</file>

<file path="plans/260114-glassmorphism-spatial-design/phase-04-sidebar-redesign.md">
---
title: "Phase 4: Sidebar Redesign"
status: pending
effort: 1h
---

# Phase 4: Sidebar Redesign

## Overview
Transform sidebar and its panels to floating glass design with spatial feel.

## Context Links
- [Main Plan](./plan.md)
- [Phase 3: Toolbar Redesign](./phase-03-toolbar-redesign.md)
- File: `src/components/sidebar/sidebar.tsx`
- File: `src/components/sidebar/background-panel.tsx`
- File: `src/components/sidebar/crop-panel.tsx`
- File: `src/components/sidebar/export-panel.tsx`

## Key Insights
- Current sidebar: `w-80 bg-white dark:bg-gray-900 border-l border-gray-200`
- Needs: glass effect, rounded corners, no hard border
- Tab navigation needs glass-style active states
- Panels inside use glass-flat for nested glass
- Preserve all button styling (orange accent)

## Requirements

### Functional
- Glass effect on sidebar container
- Rounded corners (16px)
- Glass-style tab navigation
- Panel sections with subtle dividers
- All functionality preserved

### Non-Functional
- Scrollable content works with backdrop-filter
- Consistent with toolbar design

## Implementation

### File: `src/components/sidebar/sidebar.tsx`

**Current line 21:**
```tsx
<div className="w-80 bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 flex flex-col h-full">
```

**Replace:**
```tsx
<div className="w-80 glass floating-panel flex flex-col h-full overflow-hidden">
```

**Update tab navigation (lines 23-37):**

Current:
```tsx
<div className="flex border-b border-gray-200 dark:border-gray-700 shrink-0">
  {tabs.map((tab) => (
    <button
      key={tab.id}
      onClick={() => setActiveTab(tab.id)}
      className={`flex-1 py-3 px-4 text-sm font-medium transition-colors ${
        activeTab === tab.id
          ? 'text-blue-500 border-b-2 border-blue-500 bg-gray-50 dark:bg-gray-800'
          : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800'
      }`}
    >
      {tab.label}
    </button>
  ))}
</div>
```

Replace:
```tsx
<div className="flex border-b border-black/5 dark:border-white/5 shrink-0 px-2 pt-2">
  {tabs.map((tab) => (
    <button
      key={tab.id}
      onClick={() => setActiveTab(tab.id)}
      className={`flex-1 py-2.5 px-4 text-sm font-medium transition-all rounded-t-xl ${
        activeTab === tab.id
          ? 'text-orange-500 bg-white/50 dark:bg-white/10 border-b-2 border-orange-500'
          : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-white/30 dark:hover:bg-white/5'
      }`}
    >
      {tab.label}
    </button>
  ))}
</div>
```

**Update "no image" message (lines 41-44):**
```tsx
<div className="p-4 text-center text-gray-400 dark:text-gray-500 text-sm border-b border-black/5 dark:border-white/5">
  Take a screenshot to get started
</div>
```

### File: `src/components/sidebar/background-panel.tsx`

**Update panel container (line 189-190):**
```tsx
<div className="p-4 border-b border-black/5 dark:border-white/5">
```

**Update tab buttons container (line 194):**
```tsx
<div className="flex gap-1 mb-4 glass-flat rounded-xl p-1">
```

**Update tab buttons (lines 196-206):**
```tsx
className={`flex-1 py-1.5 px-2 rounded-lg text-xs font-medium transition-all ${activeTab === tab.id
  ? 'bg-white/80 dark:bg-white/20 text-gray-800 dark:text-white shadow-sm'
  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 hover:bg-white/40 dark:hover:bg-white/10'
}`}
```

**Update category tabs (lines 213-227):**
```tsx
className={`flex items-center gap-1 px-3 py-1.5 rounded-full text-xs whitespace-nowrap transition-all ${activeCategory === category.id
  ? 'bg-white/80 dark:bg-white/20 text-gray-800 dark:text-white shadow-sm'
  : 'glass-flat text-gray-600 dark:text-gray-400 hover:bg-white/50 dark:hover:bg-white/10'
}`}
```

**Update random button (lines 230-236):**
```tsx
className="w-full flex items-center justify-center gap-2 py-2 px-4 rounded-xl glass-btn text-gray-700 dark:text-gray-300 transition-all"
```

**Update slider sections (lines 435, 450, 465, 480):**
Replace border classes:
```tsx
className="mt-4 pt-4 border-t border-black/5 dark:border-white/5"
```

### File: `src/components/sidebar/crop-panel.tsx`

**Update container (line 114):**
```tsx
<div className="p-4 border-b border-black/5 dark:border-white/5">
```

**Update start crop button (lines 119-127):**
```tsx
className={`w-full py-2.5 rounded-xl font-medium transition-all border-2 ${
  canCrop
    ? 'border-orange-500 text-orange-500 hover:bg-orange-500/10'
    : 'border-gray-300/50 dark:border-gray-600/50 text-gray-400 dark:text-gray-500 cursor-not-allowed'
}`}
```

**Update aspect ratio buttons (lines 133-145):**
```tsx
className={`px-2 py-1.5 text-sm font-medium rounded-lg transition-all ${
  aspectRatio === ar.ratio
    ? 'glass-btn-active border border-orange-500/50 text-orange-500'
    : 'glass-btn text-gray-600 dark:text-gray-300'
}`}
```

**Update apply/cancel buttons (lines 149-162):**
Apply:
```tsx
className="flex-1 py-2.5 border-2 border-orange-500 text-orange-500 rounded-xl hover:bg-orange-500/10 font-medium transition-all"
```

Cancel:
```tsx
className="flex-1 py-2.5 glass-btn text-gray-700 dark:text-gray-200 rounded-xl font-medium transition-all"
```

### File: `src/components/sidebar/export-panel.tsx`

**Update container (line 59):**
```tsx
<div className="p-4 border-b border-black/5 dark:border-white/5">
```

**Update format/resolution buttons (lines 66-88, 114-129):**
```tsx
className={`flex-1 py-1.5 rounded-lg text-sm font-medium transition-all ${
  format === 'png'
    ? 'glass-btn-active border border-orange-500/50 text-orange-500'
    : 'glass-btn text-gray-600 dark:text-gray-300'
} ${isExporting ? 'opacity-50 cursor-not-allowed' : ''}`}
```

**Update output ratio grid buttons (lines 141-155):**
Same pattern as format buttons with glass-btn styles.

**Update action buttons (lines 164-213):**

Quick Save:
```tsx
className={`w-full py-2.5 border-2 border-orange-500 text-orange-500 rounded-xl text-sm font-medium transition-all ${
  isExporting ? 'opacity-70 cursor-not-allowed' : 'hover:bg-orange-500/10'
}`}
```

Save As:
```tsx
className={`w-full py-2.5 border-2 border-amber-500 text-amber-500 rounded-xl text-sm font-medium transition-all ${
  isExporting ? 'opacity-70 cursor-not-allowed' : 'hover:bg-amber-500/10'
}`}
```

Copy to Clipboard:
```tsx
className={`w-full py-2.5 glass-btn rounded-xl text-sm font-medium transition-all ${
  isExporting ? 'opacity-70 cursor-not-allowed' : ''
}`}
```

## Related Code Files

| File | Action | Purpose |
|------|--------|---------|
| `src/components/sidebar/sidebar.tsx` | Modify | Glass container + tabs |
| `src/components/sidebar/background-panel.tsx` | Modify | Glass sections |
| `src/components/sidebar/crop-panel.tsx` | Modify | Glass buttons |
| `src/components/sidebar/export-panel.tsx` | Modify | Glass buttons |

## Todo List
- [ ] Update sidebar container with glass class
- [ ] Update tab navigation to glass style
- [ ] Update background panel tabs and buttons
- [ ] Update crop panel buttons
- [ ] Update export panel buttons
- [ ] Replace hard borders with subtle glass borders
- [ ] Test scrolling behavior
- [ ] Verify dark mode appearance

## Success Criteria
- Sidebar floats with glass effect
- Tabs have smooth glass transitions
- All panel buttons use glass styling
- Orange accent preserved
- Scrolling works correctly

## Risk Assessment
- **Low**: Class changes only
- **Consideration**: Nested backdrop-filters may compound - use glass-flat for nested elements

## Next Steps
Proceed to [Phase 5: Controls & Overlays](./phase-05-controls-overlays.md)
</file>

<file path="plans/260114-glassmorphism-spatial-design/phase-05-controls-overlays.md">
---
title: "Phase 5: Controls & Overlays"
status: pending
effort: 1h
---

# Phase 5: Controls & Overlays

## Overview
Apply glass effect to zoom controls, toast notifications, settings modal, and window picker modal.

## Context Links
- [Main Plan](./plan.md)
- [Phase 4: Sidebar Redesign](./phase-04-sidebar-redesign.md)
- Files: zoom-controls.tsx, toast.tsx, settings-modal.tsx, window-picker-modal.tsx

## Key Insights
- Zoom controls: small floating panel, needs prominent visibility
- Toasts: keep distinct colors for type (success/error/info) with glass overlay
- Modals: glass backdrop + glass panel for dialog
- Settings modal: multiple sections need glass treatment

## Requirements

### Functional
- Glass zoom controls with shadow
- Glass toast notifications
- Glass modal dialogs
- Glass modal backdrop

### Non-Functional
- Toasts remain visually distinct by type
- Modals maintain focus trap behavior
- Accessibility preserved

## Implementation

### File: `src/components/canvas/zoom-controls.tsx`

**Update container (lines 64-69):**

Current:
```tsx
<div
  role="group"
  aria-label="Zoom controls"
  className="absolute bottom-4 right-4 flex gap-2 bg-white dark:bg-gray-800 rounded-lg shadow dark:shadow-gray-900 p-2"
>
```

Replace:
```tsx
<div
  role="group"
  aria-label="Zoom controls"
  className="absolute bottom-4 right-4 flex gap-2 glass floating-panel rounded-2xl p-2"
>
```

**Update copy button (lines 71-83):**
```tsx
className={`w-8 h-8 flex items-center justify-center rounded-xl text-orange-500 dark:text-orange-400 transition-all ${
  isExporting
    ? 'opacity-50 cursor-not-allowed'
    : 'hover:bg-orange-500/10'
}`}
```

**Update separator (line 86):**
```tsx
<div className="w-px h-8 bg-black/10 dark:bg-white/10" />
```

**Update zoom buttons (lines 88-115):**
```tsx
className="w-8 h-8 flex items-center justify-center hover:bg-white/50 dark:hover:bg-white/10 rounded-lg text-gray-700 dark:text-gray-200 transition-all"
```

### File: `src/components/common/toast.tsx`

**Update toast container (lines 63-67):**

Current:
```tsx
<div
  className={`flex items-start gap-3 p-4 rounded-lg shadow-lg text-white transition-all duration-300 ${bgColor} ${
    isExiting ? 'opacity-0 translate-x-4' : 'opacity-100 translate-x-0'
  }`}
>
```

Replace with glass toast:
```tsx
<div
  className={`flex items-start gap-3 p-4 rounded-2xl shadow-lg text-white transition-all duration-300 backdrop-blur-md ${
    isExiting ? 'opacity-0 translate-x-4' : 'opacity-100 translate-x-0'
  }`}
  style={{
    background: toast.type === 'success'
      ? 'rgba(22, 163, 74, 0.9)'
      : toast.type === 'error'
      ? 'rgba(220, 38, 38, 0.9)'
      : 'rgba(37, 99, 235, 0.9)',
    border: '1px solid rgba(255, 255, 255, 0.2)',
  }}
>
```

**Update ToastContainer (lines 105-110):**
```tsx
<div className="fixed bottom-4 right-4 z-50 flex flex-col gap-3 max-w-sm">
```

### File: `src/components/settings/settings-modal.tsx`

**Update backdrop (lines 157-160):**

Current:
```tsx
<div
  className="fixed inset-0 bg-black/50 flex items-center justify-center z-50"
  onClick={(e) => e.target === e.currentTarget && onClose()}
>
```

Replace:
```tsx
<div
  className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50"
  onClick={(e) => e.target === e.currentTarget && onClose()}
>
```

**Update modal panel (lines 161-167):**

Current:
```tsx
<div
  ref={modalRef}
  className="bg-white dark:bg-gray-800 rounded-lg w-[500px] max-h-[80vh] overflow-y-auto shadow-xl"
  ...
>
```

Replace:
```tsx
<div
  ref={modalRef}
  className="glass-heavy rounded-2xl w-[500px] max-h-[80vh] overflow-y-auto"
  ...
>
```

**Update header (lines 169-181):**
```tsx
<div className="p-4 border-b border-black/5 dark:border-white/5 flex justify-between items-center sticky top-0 glass-heavy rounded-t-2xl z-10">
  <h2 id="settings-title" className="text-lg font-medium text-gray-800 dark:text-gray-100">
    Settings
  </h2>
  <button
    ref={closeButtonRef}
    onClick={onClose}
    className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 hover:bg-black/5 dark:hover:bg-white/10 rounded-lg transition-all"
    aria-label="Close settings (Escape)"
  >
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
    </svg>
  </button>
</div>
```

**Update section headings:**
```tsx
<h3 className="font-medium mb-3 text-gray-700 dark:text-gray-200">
```

**Update theme buttons (lines 188-200):**
```tsx
className={`flex-1 py-2 px-3 rounded-xl text-sm font-medium transition-all ${settings.theme === option.value
  ? 'glass-btn-active border border-orange-500/50 text-orange-500'
  : 'glass-btn text-gray-600 dark:text-gray-300'
}`}
```

**Update hotkey inputs (lines 229-254):**
```tsx
className={`w-48 px-3 py-1.5 rounded-lg text-sm focus:outline-none focus:ring-2 glass-flat ${(isEditing && !isValid) || hasRegistrationError
  ? 'border border-red-300 focus:ring-red-500'
  : hasDuplicate
    ? 'border border-yellow-400 focus:ring-yellow-500'
    : 'border border-transparent focus:ring-orange-500'
}`}
```

**Update checkboxes (lines 287-318):**
```tsx
className="w-4 h-4 rounded border-gray-300/50 dark:border-gray-600/50 text-orange-500 focus:ring-orange-500 bg-white/50 dark:bg-black/30"
```

**Update footer (lines 357-371):**
```tsx
<div className="p-4 border-t border-black/5 dark:border-white/5 flex justify-between items-center sticky bottom-0 glass-heavy rounded-b-2xl">
  <button
    onClick={() => settings.resetToDefaults()}
    className="px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100 hover:bg-black/5 dark:hover:bg-white/10 rounded-lg transition-all"
  >
    Reset to Defaults
  </button>
  <button
    onClick={onClose}
    className="px-5 py-2 border-2 border-orange-500 text-orange-500 rounded-xl hover:bg-orange-500/10 text-sm font-medium transition-all"
  >
    Done
  </button>
</div>
```

### File: `src/components/capture/window-picker-modal.tsx`

**Update backdrop (lines 149-153):**
```tsx
<div
  className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50"
  onClick={(e) => e.target === e.currentTarget && onClose()}
>
```

**Update modal panel (lines 154-160):**
```tsx
<div
  ref={modalRef}
  className="glass-heavy rounded-2xl w-[500px] max-h-[70vh] flex flex-col overflow-hidden"
  role="dialog"
  ...
>
```

**Update header (lines 162-187):**
```tsx
<div className="p-4 border-b border-black/5 dark:border-white/5 flex justify-between items-center">
  <h2 ... className="text-lg font-medium text-gray-800 dark:text-gray-100">
    Select Window to Capture
  </h2>
  <div className="flex items-center gap-2">
    <button
      onClick={fetchWindows}
      disabled={loading}
      className="px-3 py-1.5 text-sm glass-btn rounded-lg disabled:opacity-50"
    >
      Refresh
    </button>
    <button
      ref={closeButtonRef}
      onClick={onClose}
      className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 hover:bg-black/5 dark:hover:bg-white/10 rounded-lg transition-all"
    >
      ...
    </button>
  </div>
</div>
```

**Update window list items (lines 201-238):**
```tsx
className={`flex items-center gap-3 p-3 rounded-xl transition-all ${
  selectedId === win.id
    ? 'glass-btn-active ring-2 ring-orange-500'
    : 'glass-btn'
}`}
```

**Update footer (lines 244-265):**
```tsx
<div className="p-4 border-t border-black/5 dark:border-white/5 flex justify-between items-center">
  <span className="text-sm text-gray-500 dark:text-gray-400">
    Double-click to capture instantly
  </span>
  <div className="flex gap-2">
    <button
      onClick={onClose}
      className="px-4 py-2 text-sm glass-btn rounded-xl"
    >
      Cancel
    </button>
    <button
      onClick={handleCapture}
      disabled={selectedId === null || capturing}
      className="px-5 py-2 bg-orange-500 text-white rounded-xl hover:bg-orange-600 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-all"
    >
      {capturing ? 'Capturing...' : 'Capture'}
    </button>
  </div>
</div>
```

## Related Code Files

| File | Action | Purpose |
|------|--------|---------|
| `src/components/canvas/zoom-controls.tsx` | Modify | Glass floating controls |
| `src/components/common/toast.tsx` | Modify | Glass notifications |
| `src/components/settings/settings-modal.tsx` | Modify | Glass modal |
| `src/components/capture/window-picker-modal.tsx` | Modify | Glass modal |

## Todo List
- [ ] Update zoom controls with glass class
- [ ] Update toast notifications with glass effect
- [ ] Update settings modal backdrop and panel
- [ ] Update settings modal sections and buttons
- [ ] Update window picker modal
- [ ] Test modal focus trapping still works
- [ ] Verify ESC key handling
- [ ] Test dark mode appearance

## Success Criteria
- All overlays have glass effect
- Modal backdrops have subtle blur
- Toasts maintain type distinction
- All functionality preserved
- Keyboard navigation works

## Risk Assessment
- **Low**: Styling changes only
- **Consideration**: Modal backdrop blur may impact performance on low-end devices

## Next Steps
Proceed to [Phase 6: Screens & Polish](./phase-06-screens-polish.md)
</file>

<file path="plans/260114-glassmorphism-spatial-design/phase-06-screens-polish.md">
---
title: "Phase 6: Screens & Polish"
status: pending
effort: 1h
---

# Phase 6: Screens & Polish

## Overview
Update App.tsx loading/permission screens and final polish pass on all components.

## Context Links
- [Main Plan](./plan.md)
- [Phase 5: Controls & Overlays](./phase-05-controls-overlays.md)
- Files: App.tsx, permission-required.tsx

## Key Insights
- Loading screen: simple spinner on canvas-area background
- Permission screen: already has glass-like card, needs refinement
- Final pass: ensure consistent border-radius, shadows, transitions

## Requirements

### Functional
- Glass loading screen
- Refined permission screen with glass
- Consistent design language throughout

### Non-Functional
- Smooth loading experience
- Professional appearance
- Cross-browser compatibility

## Implementation

### File: `src/App.tsx`

**Update loading screen (lines 102-108):**

Current:
```tsx
if (appState === 'checking') {
  return (
    <div className="fixed inset-0 bg-gray-100 dark:bg-gray-900 flex items-center justify-center">
      <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin" />
    </div>
  );
}
```

Replace:
```tsx
if (appState === 'checking') {
  return (
    <div className="fixed inset-0 canvas-area flex items-center justify-center">
      <div className="glass floating-panel p-8 rounded-2xl flex flex-col items-center gap-4">
        <div className="w-10 h-10 border-3 border-orange-500 border-t-transparent rounded-full animate-spin" />
        <span className="text-sm text-gray-500 dark:text-gray-400">Loading...</span>
      </div>
    </div>
  );
}
```

### File: `src/components/permission-required.tsx`

**Update background (line 168):**

Current:
```tsx
<div className="fixed inset-0 bg-gradient-to-br from-gray-100 to-gray-200 dark:from-gray-900 dark:to-gray-800 flex items-center justify-center p-6">
```

Replace:
```tsx
<div className="fixed inset-0 canvas-area flex items-center justify-center p-6">
```

**Update card container (line 169):**

Current:
```tsx
<div className="max-w-lg w-full bg-white dark:bg-gray-800 rounded-2xl shadow-2xl overflow-hidden">
```

Replace:
```tsx
<div className="max-w-lg w-full glass-heavy rounded-3xl overflow-hidden">
```

**Update header gradient (lines 171-176):**
```tsx
<div className="bg-gradient-to-r from-orange-500 to-amber-500 px-8 py-6 text-white">
  <h1 className="text-2xl font-bold mb-1">Permissions Required</h1>
  <p className="text-orange-100 text-sm">
    beautiFULLshot needs these permissions to work properly
  </p>
</div>
```

**Update PermissionItem component (lines 49-83):**

Update the container:
```tsx
<div className={`flex items-center gap-4 p-4 rounded-2xl transition-all ${granted
  ? 'bg-green-500/10 border border-green-500/30'
  : 'glass-flat'
}`}>
```

Update status icon container:
```tsx
<div className={`w-10 h-10 rounded-xl flex items-center justify-center shrink-0 ${granted
  ? 'bg-green-500'
  : 'bg-gray-300/50 dark:bg-gray-600/50'
}`}>
```

Update Enable button:
```tsx
<button
  onClick={onOpenSettings}
  className="px-4 py-2 border-2 border-orange-500 text-orange-500 hover:bg-orange-500/10 text-sm font-medium rounded-xl transition-all shrink-0"
>
  Enable
</button>
```

**Update warning box (lines 196-205):**
```tsx
<div className="glass-flat rounded-2xl p-4 mt-4 border border-amber-500/20">
  <p className="text-sm text-amber-700 dark:text-amber-300 font-medium mb-2">
    After enabling permissions:
  </p>
  <p className="text-sm text-amber-600 dark:text-amber-400">
    macOS requires an app restart for permission changes to take effect. Click <strong>"Restart App"</strong> below after enabling.
  </p>
</div>
```

**Update action buttons (lines 208-234):**

Restart button:
```tsx
className="flex-1 px-4 py-3 border-2 border-orange-500 text-orange-500 hover:bg-orange-500/10 disabled:opacity-50 font-medium rounded-2xl transition-all"
```

Recheck button:
```tsx
className="px-4 py-3 glass-btn text-gray-700 dark:text-gray-200 font-medium rounded-2xl transition-all"
```

Check Again button:
```tsx
className="w-full px-4 py-3 glass-btn text-gray-700 dark:text-gray-200 font-medium rounded-2xl transition-all"
```

**Update footer (lines 239-245):**
```tsx
<div className="px-6 pb-6">
  <p className="text-xs text-center text-gray-500 dark:text-gray-400 opacity-75">
    These permissions are only used for screenshot capture and keyboard shortcuts.
    <br />
    Your privacy is respected - no data is collected.
  </p>
</div>
```

## Final Polish Checklist

### Consistent Border Radius
- Buttons: `rounded-xl` (12px)
- Panels: `rounded-2xl` (16px)
- Cards: `rounded-2xl` or `rounded-3xl` (20px)
- Small elements: `rounded-lg` (8px)

### Consistent Transitions
- All interactive elements: `transition-all`
- Duration: default (150ms) or `duration-200`

### Consistent Shadows
- Small floating elements: `var(--panel-shadow)`
- Large panels: `var(--panel-shadow-lg)`

### Color Accents
- Primary action: `border-orange-500 text-orange-500`
- Secondary action: `border-amber-500 text-amber-500`
- Neutral action: `glass-btn`
- Active state: `glass-btn-active`

### Dark Mode Verification
- [ ] Toolbar glass effect visible
- [ ] Sidebar glass effect visible
- [ ] Modal backdrops have blur
- [ ] Text contrast sufficient
- [ ] Orange accent visible

## Related Code Files

| File | Action | Purpose |
|------|--------|---------|
| `src/App.tsx` | Modify | Glass loading screen |
| `src/components/permission-required.tsx` | Modify | Glass permission screen |

## Todo List
- [ ] Update App.tsx loading screen
- [ ] Update permission-required container
- [ ] Update permission items styling
- [ ] Update warning boxes
- [ ] Update action buttons
- [ ] Final review of all components
- [ ] Test complete user flow
- [ ] Verify dark mode throughout
- [ ] Check performance (backdrop-blur)
- [ ] Cross-browser test (Safari, Chrome, Firefox)

## Success Criteria
- Loading screen matches design language
- Permission screen has glass aesthetic
- All components follow consistent patterns
- No visual regressions
- Performance acceptable

## Risk Assessment
- **Low**: Final polish phase, no structural changes
- **Consideration**: Total backdrop-filter usage - monitor performance

## Post-Implementation
- Run `npm run build` to verify no errors
- Test in development mode
- Visual QA in both themes
- Document any browser-specific issues
</file>

<file path="plans/260114-glassmorphism-spatial-design/plan.md">
---
title: "Glassmorphism & Spatial Design Overhaul"
description: "Complete UI redesign with glass effects, floating panels, and spatial depth"
status: pending
priority: P1
effort: 6h
branch: main
tags: [ui, design, glassmorphism, tailwind]
created: 2026-01-14
---

# Glassmorphism & Spatial Design Implementation

## Overview
Transform BeautyFullShot from flat design to modern glassmorphism with spatial depth. Floating panels, glass effects, layered UI while preserving orange brand color.

## Design Principles
- **Glass Effect**: backdrop-blur, semi-transparent backgrounds, subtle borders
- **Spatial Depth**: Floating panels with margins, shadows for elevation, layered z-index
- **Brand Identity**: Orange (#f97316) accent color preserved throughout
- **Dark Mode**: Darker glass with adjusted opacity for contrast

## Phases

| Phase | Description | Status | Effort |
|-------|-------------|--------|--------|
| 1 | [CSS Foundation](./phase-01-css-foundation.md) - Glass utilities & base styles | pending | 1h |
| 2 | [Layout Structure](./phase-02-layout-structure.md) - Spatial gaps & floating panels | pending | 1h |
| 3 | [Toolbar Redesign](./phase-03-toolbar-redesign.md) - Glass toolbar with spatial layout | pending | 1h |
| 4 | [Sidebar Redesign](./phase-04-sidebar-redesign.md) - Floating glass sidebar | pending | 1h |
| 5 | [Controls & Overlays](./phase-05-controls-overlays.md) - Zoom, toast, modals | pending | 1h |
| 6 | [Screens & Polish](./phase-06-screens-polish.md) - Permission, loading, final touches | pending | 1h |

## Files to Modify
- `src/styles.css` - Glass utilities
- `src/App.tsx` - Loading/permission screens
- `src/components/layout/editor-layout.tsx` - Spatial layout
- `src/components/toolbar/toolbar.tsx` - Glass toolbar
- `src/components/sidebar/sidebar.tsx` - Floating sidebar
- `src/components/canvas/zoom-controls.tsx` - Glass controls
- `src/components/settings/settings-modal.tsx` - Glass modal
- `src/components/capture/window-picker-modal.tsx` - Glass modal
- `src/components/common/toast.tsx` - Glass notifications
- `src/components/permission-required.tsx` - Glass permission screen

## Key Design Tokens
```css
/* Light Mode Glass */
--glass-bg: rgba(255, 255, 255, 0.7);
--glass-border: rgba(255, 255, 255, 0.3);
--glass-blur: 16px;

/* Dark Mode Glass */
--glass-bg-dark: rgba(15, 15, 15, 0.8);
--glass-border-dark: rgba(255, 255, 255, 0.1);

/* Spatial */
--panel-radius: 16px;
--panel-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
--gap-layout: 12px;
```

## Success Criteria
- [ ] All panels have glass effect with backdrop blur
- [ ] Spatial gaps between toolbar, canvas, sidebar
- [ ] Floating elevated panels with shadows
- [ ] Dark mode maintains glass aesthetic
- [ ] Orange accent preserved for active states
- [ ] No visual regressions on functionality
</file>

<file path="plans/archive/251227-0444-codebase-improvements/phase-01-dry-constants.md">
# Phase 01: DRY Violations & Constants

**Status**: pending | **Effort**: 1h | **Priority**: Medium

## Objective

Eliminate code duplication and consolidate magic numbers into shared constants.

## Issues Addressed

| ID | Description | Location |
|----|-------------|----------|
| M2 | Duplicate ZOOM_FACTOR | canvas-editor.tsx:11, zoom-controls.tsx:5 |
| M3 | Duplicate scale clamping | canvas-store.ts + canvas-editor.tsx |

## Implementation

### 1. Create Constants File

**src/constants/canvas.ts:**
```typescript
// Canvas constants - shared across canvas components
export const ZOOM = {
  FACTOR: 1.1,
  MIN_SCALE: 0.1,
  MAX_SCALE: 5,
} as const;
```

### 2. Update canvas-store.ts

```typescript
import { ZOOM } from '../constants/canvas';

setScale: (scale) => set({
  scale: Math.max(ZOOM.MIN_SCALE, Math.min(ZOOM.MAX_SCALE, scale))
}),
```

### 3. Update canvas-editor.tsx

```typescript
import { ZOOM } from '../../constants/canvas';

// Remove local constants
// const MIN_SCALE = 0.1;
// const MAX_SCALE = 5;
// const ZOOM_FACTOR = 1.1;

// Use ZOOM.FACTOR, ZOOM.MIN_SCALE, ZOOM.MAX_SCALE
```

### 4. Update zoom-controls.tsx

```typescript
import { ZOOM } from '../../constants/canvas';

// Remove: const ZOOM_FACTOR = 1.1;
const zoomIn = () => setScale(scale * ZOOM.FACTOR);
const zoomOut = () => setScale(scale / ZOOM.FACTOR);
```

## Files to Create/Modify

| File | Action |
|------|--------|
| src/constants/canvas.ts | Create |
| src/stores/canvas-store.ts | Modify |
| src/components/canvas/canvas-editor.tsx | Modify |
| src/components/canvas/zoom-controls.tsx | Modify |

## Success Criteria

- [ ] Single source of truth for zoom constants
- [ ] No duplicate ZOOM_FACTOR definitions
- [ ] Scale clamping only in store
- [ ] TypeScript: 0 errors
</file>

<file path="plans/archive/251227-0444-codebase-improvements/phase-02-ux-improvements.md">
# Phase 02: UX Improvements

**Status**: pending | **Effort**: 2h | **Priority**: High

## Objective

Fix critical UX issues: dropdown behavior, loading states, error handling.

## Issues Addressed

| ID | Severity | Description |
|----|----------|-------------|
| H1 | High | No click-away/ESC for window dropdown |
| M5 | Medium | handleWheel causes unnecessary re-renders |
| M6 | Medium | No visual loading spinner |
| L4 | Low | Errors don't auto-dismiss |

## Implementation

### 1. Dropdown Click-Away Hook

**src/hooks/use-click-away.ts:**
```typescript
import { useEffect, RefObject } from 'react';

export function useClickAway(
  ref: RefObject<HTMLElement>,
  onClickAway: () => void
) {
  useEffect(() => {
    const handler = (e: MouseEvent | TouchEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        onClickAway();
      }
    };

    const escHandler = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClickAway();
    };

    document.addEventListener('mousedown', handler);
    document.addEventListener('touchstart', handler);
    document.addEventListener('keydown', escHandler);

    return () => {
      document.removeEventListener('mousedown', handler);
      document.removeEventListener('touchstart', handler);
      document.removeEventListener('keydown', escHandler);
    };
  }, [ref, onClickAway]);
}
```

### 2. Update Toolbar

```typescript
import { useRef, useCallback } from 'react';
import { useClickAway } from '../../hooks/use-click-away';

// In Toolbar component:
const dropdownRef = useRef<HTMLDivElement>(null);
const closeDropdown = useCallback(() => setShowWindows(false), []);
useClickAway(dropdownRef, closeDropdown);

// Wrap dropdown in ref'd div
<div ref={dropdownRef} className="relative">
  {/* dropdown content */}
</div>
```

### 3. Loading Spinner

Add visual loading indicator:
```typescript
{loading && (
  <div className="flex items-center gap-2">
    <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/>
    </svg>
    <span>Capturing...</span>
  </div>
)}
```

### 4. Auto-Dismiss Errors

```typescript
// In useScreenshot:
const [error, setError] = useState<string | null>(null);

// Auto-dismiss after 5s
useEffect(() => {
  if (error) {
    const timer = setTimeout(() => setError(null), 5000);
    return () => clearTimeout(timer);
  }
}, [error]);
```

## Files to Create/Modify

| File | Action |
|------|--------|
| src/hooks/use-click-away.ts | Create |
| src/components/toolbar/toolbar.tsx | Modify |
| src/hooks/use-screenshot.ts | Modify |

## Success Criteria

- [ ] Dropdown closes on outside click
- [ ] Dropdown closes on ESC key
- [ ] Loading spinner visible during capture
- [ ] Errors auto-dismiss after 5s
</file>

<file path="plans/archive/251227-0444-codebase-improvements/phase-03-backend-reliability.md">
# Phase 03: Backend Reliability

**Status**: pending | **Effort**: 3h | **Priority**: High

## Objective

Fix silent error handling, optimize performance, add structured errors.

## Issues Addressed

| ID | Severity | Description |
|----|----------|-------------|
| H1 | High | Silent error handling masks failures |
| H2 | High | Repeated expensive syscalls |
| H3 | High | PNG encoding reallocations |
| H4 | High | Late validation in capture_region |
| M1 | Medium | No structured error types |
| M3 | Medium | Unused greet command |

## Implementation

### 1. Structured Error Types

**src-tauri/src/error.rs:**
```rust
use serde::Serialize;

#[derive(Debug, Serialize)]
pub enum ScreenshotError {
    NoMonitorFound,
    WindowNotFound(u32),
    CaptureError(String),
    EncodingError(String),
    InvalidRegion { width: u32, height: u32 },
    PermissionDenied,
}

impl std::fmt::Display for ScreenshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NoMonitorFound => write!(f, "No primary monitor found"),
            Self::WindowNotFound(id) => write!(f, "Window {} not found", id),
            Self::CaptureError(e) => write!(f, "Capture failed: {}", e),
            Self::EncodingError(e) => write!(f, "PNG encoding failed: {}", e),
            Self::InvalidRegion { width, height } =>
                write!(f, "Invalid region: {}x{}", width, height),
            Self::PermissionDenied => write!(f, "Screen capture permission denied"),
        }
    }
}

impl std::error::Error for ScreenshotError {}
```

### 2. Fix Silent Error Handling

Replace `unwrap_or(0)` with proper error propagation:

```rust
// Before:
id: w.id().unwrap_or(0),

// After:
let id = match w.id() {
    Some(id) if id > 0 => id,
    _ => continue, // Skip invalid windows
};
```

### 3. Pre-allocate PNG Buffer

```rust
fn image_to_png_bytes(img: &image::RgbaImage) -> Result<Vec<u8>, ScreenshotError> {
    // Estimate: RGBA = 4 bytes/pixel, PNG ~50% compression
    let estimated_size = (img.width() * img.height() * 2) as usize;
    let mut bytes: Vec<u8> = Vec::with_capacity(estimated_size);

    let encoder = image::codecs::png::PngEncoder::new(&mut bytes);
    encoder
        .write_image(
            img.as_raw(),
            img.width(),
            img.height(),
            image::ExtendedColorType::Rgba8,
        )
        .map_err(|e| ScreenshotError::EncodingError(e.to_string()))?;
    Ok(bytes)
}
```

### 4. Early Validation

```rust
#[tauri::command]
pub fn capture_region(x: i32, y: i32, width: u32, height: u32) -> Result<Vec<u8>, ScreenshotError> {
    // Validate BEFORE expensive operations
    if width == 0 || height == 0 {
        return Err(ScreenshotError::InvalidRegion { width, height });
    }

    // Now proceed with capture...
}
```

### 5. Remove Unused greet Command

Delete from lib.rs:
```rust
// Remove:
// #[tauri::command]
// fn greet(name: &str) -> String { ... }

// Remove from generate_handler:
// greet,
```

## Files to Create/Modify

| File | Action |
|------|--------|
| src-tauri/src/error.rs | Create |
| src-tauri/src/screenshot.rs | Modify |
| src-tauri/src/lib.rs | Modify |

## Success Criteria

- [ ] No unwrap_or(0) for IDs
- [ ] Structured error types
- [ ] PNG buffer pre-allocated
- [ ] Early validation before capture
- [ ] greet command removed
</file>

<file path="plans/archive/251227-0444-codebase-improvements/phase-04-accessibility.md">
# Phase 04: Accessibility

**Status**: pending | **Effort**: 2h | **Priority**: Medium

## Objective

Add ARIA labels, keyboard navigation, and screen reader support.

## Issues Addressed

| ID | Severity | Description |
|----|----------|-------------|
| L1 | Low | Missing ARIA labels on buttons |
| L2 | Low | No keyboard navigation for dropdown |

## Implementation

### 1. ARIA Labels for Buttons

**toolbar.tsx:**
```tsx
<button
  onClick={handleCaptureFullscreen}
  disabled={loading}
  aria-label="Capture full screen screenshot"
  className="..."
>
  {loading ? 'Capturing...' : 'Capture Screen'}
</button>

<button
  onClick={() => setShowWindows(!showWindows)}
  aria-expanded={showWindows}
  aria-haspopup="listbox"
  aria-label="Select window to capture"
  className="..."
>
  Capture Window
</button>

<button
  onClick={clearCanvas}
  aria-label="Clear current screenshot"
  className="..."
>
  Clear
</button>
```

**zoom-controls.tsx:**
```tsx
<button
  onClick={zoomOut}
  aria-label="Zoom out"
  className="..."
>
  -
</button>

<span aria-live="polite" aria-label={`Zoom level ${Math.round(scale * 100)} percent`}>
  {Math.round(scale * 100)}%
</span>

<button
  onClick={zoomIn}
  aria-label="Zoom in"
  className="..."
>
  +
</button>

<button
  onClick={zoomFit}
  aria-label="Fit image to screen"
  className="..."
>
  Fit
</button>
```

### 2. Keyboard Navigation for Dropdown

```tsx
// Window dropdown with keyboard nav
<div
  role="listbox"
  aria-label="Available windows"
  tabIndex={-1}
  onKeyDown={(e) => {
    if (e.key === 'ArrowDown') {
      // Focus next item
    } else if (e.key === 'ArrowUp') {
      // Focus previous item
    } else if (e.key === 'Enter') {
      // Select current item
    }
  }}
>
  {windows.map((w, index) => (
    <button
      key={w.id}
      role="option"
      tabIndex={showWindows ? 0 : -1}
      aria-selected={false}
      onClick={() => handleCaptureWindow(w.id)}
      className="..."
    >
      <span className="font-medium">{w.app_name}</span>
      <span className="text-gray-500 ml-2">{w.title}</span>
    </button>
  ))}
</div>
```

### 3. Focus Management

```tsx
// Focus first dropdown item when opened
useEffect(() => {
  if (showWindows && dropdownRef.current) {
    const firstButton = dropdownRef.current.querySelector('button');
    firstButton?.focus();
  }
}, [showWindows]);
```

## Files to Modify

| File | Action |
|------|--------|
| src/components/toolbar/toolbar.tsx | Modify |
| src/components/canvas/zoom-controls.tsx | Modify |

## Success Criteria

- [ ] All buttons have aria-label
- [ ] Dropdown has proper ARIA roles
- [ ] Keyboard navigation works (Arrow keys + Enter)
- [ ] Zoom level announced to screen readers
- [ ] Focus management on dropdown open
</file>

<file path="plans/archive/251227-0444-codebase-improvements/plan.md">
---
title: "BeautyShot Codebase Improvements"
description: "Quality improvements based on comprehensive code review"
status: partial
priority: P2
effort: 8h
branch: master
created: 2025-12-27
---

# Codebase Improvement Plan

Quality improvements for BeautyShot identified during comprehensive code review.

## Current State

| Metric | Value |
|--------|-------|
| Frontend LOC | ~390 |
| Backend LOC | ~230 |
| TypeScript Errors | 0 |
| Critical Issues | 0 |
| High Priority | 3 |
| Medium Priority | 9 |

## Phases Overview

| Phase | Title | Status | Effort | File |
|-------|-------|--------|--------|------|
| 01 | DRY Violations & Constants | ✅ DONE | 1h | [phase-01](./phase-01-dry-constants.md) |
| 02 | UX Improvements | ✅ DONE | 2h | [phase-02](./phase-02-ux-improvements.md) |
| 03 | Backend Reliability | pending | 3h | [phase-03](./phase-03-backend-reliability.md) |
| 04 | Accessibility | ✅ DONE | 2h | [phase-04](./phase-04-accessibility.md) |

## Key Findings

### Frontend (React/TypeScript)
- **DRY**: ZOOM_FACTOR defined twice
- **UX**: Window dropdown lacks click-away/ESC
- **Performance**: handleWheel deps cause re-renders
- **A11y**: Missing ARIA labels, keyboard nav

### Backend (Rust)
- **Reliability**: Silent error handling masks failures
- **Performance**: Repeated expensive syscalls
- **Memory**: PNG encoding reallocations
- **Cleanup**: Unused greet command

## Priority Matrix

| Priority | Frontend | Backend |
|----------|----------|---------|
| High | Dropdown UX | Silent errors |
| High | - | Repeated syscalls |
| High | - | PNG allocation |
| Medium | DRY violations | Structured errors |
| Medium | handleWheel deps | Input validation |
| Low | ARIA labels | Logging |

## Success Criteria

- [ ] Zero DRY violations
- [ ] Dropdown has proper UX
- [ ] All errors properly handled
- [ ] ARIA labels on all interactive elements
- [ ] PNG encoding pre-allocated

## Reports

- [Frontend Review](../reports/code-reviewer-251227-0445-frontend-review.md)
- [Backend Review](../reports/code-reviewer-251227-0445-rust-backend.md)
</file>

<file path="public/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/canvas/drawing-preview.tsx">
// DrawingPreview - Shows preview shape while drawing

import { Rect, Ellipse, Line, Arrow } from 'react-konva';
import { ANNOTATION_DEFAULTS } from '../../constants/annotations';

interface PreviewRect {
  x: number;
  y: number;
  width: number;
  height: number;
  startPos: { x: number; y: number };
  currentPos: { x: number; y: number };
}

interface DrawingPreviewProps {
  tool: string | null;
  previewRect: PreviewRect | null;
  strokeColor: string;
  fillColor: string;
  strokeWidth: number;
}

export function DrawingPreview({
  tool,
  previewRect,
  strokeColor,
  fillColor,
  strokeWidth,
}: DrawingPreviewProps) {
  if (!previewRect || !tool) return null;

  const { x, y, width, height, startPos, currentPos } = previewRect;

  // Common style for preview (slightly transparent)
  const previewOpacity = 0.6;

  switch (tool) {
    case 'rectangle':
      return (
        <Rect
          x={x}
          y={y}
          width={width}
          height={height}
          fill={fillColor}
          stroke={strokeColor}
          strokeWidth={strokeWidth}
          opacity={previewOpacity}
          listening={false}
          dash={[5, 5]}
        />
      );

    case 'ellipse':
      return (
        <Ellipse
          x={x + width / 2}
          y={y + height / 2}
          radiusX={width / 2}
          radiusY={height / 2}
          fill={fillColor}
          stroke={strokeColor}
          strokeWidth={strokeWidth}
          opacity={previewOpacity}
          listening={false}
          dash={[5, 5]}
        />
      );

    case 'line':
      return (
        <Line
          points={[startPos.x, startPos.y, currentPos.x, currentPos.y]}
          stroke={strokeColor}
          strokeWidth={strokeWidth}
          opacity={previewOpacity}
          listening={false}
          dash={[5, 5]}
        />
      );

    case 'arrow':
      return (
        <Arrow
          points={[startPos.x, startPos.y, currentPos.x, currentPos.y]}
          stroke={strokeColor}
          strokeWidth={strokeWidth}
          pointerLength={ANNOTATION_DEFAULTS.ARROW.POINTER_LENGTH}
          pointerWidth={ANNOTATION_DEFAULTS.ARROW.POINTER_WIDTH}
          fill={strokeColor}
          opacity={previewOpacity}
          listening={false}
          dash={[5, 5]}
        />
      );

    case 'spotlight':
      return (
        <Rect
          x={x}
          y={y}
          width={width}
          height={height}
          stroke="#ffffff"
          strokeWidth={2}
          opacity={previewOpacity}
          listening={false}
          dash={[5, 5]}
        />
      );

    default:
      return null;
  }
}
</file>

<file path="src/components/canvas/text-edit-overlay.tsx">
// TextEditOverlay - Edit existing text annotations via double-click

import { useRef, useEffect, useState } from 'react';
import { useAnnotationStore } from '../../stores/annotation-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { useBackgroundStore } from '../../stores/background-store';
import { useExportStore } from '../../stores/export-store';
import { calculateAspectRatioExtend } from '../../utils/export-utils';
import type { TextAnnotation } from '../../types/annotations';

export function TextEditOverlay() {
  const inputRef = useRef<HTMLInputElement>(null);
  const measureRef = useRef<HTMLSpanElement>(null);
  const [inputWidth, setInputWidth] = useState(50);
  const [isReady, setIsReady] = useState(false);

  const { editingTextId, annotations, updateTextContent, setEditingTextId } = useAnnotationStore();
  const { scale, position, originalWidth, originalHeight } = useCanvasStore();
  const { getPaddingPx } = useBackgroundStore();
  const { outputAspectRatio } = useExportStore();

  const annotation = annotations.find(
    (a) => a.id === editingTextId && a.type === 'text'
  ) as TextAnnotation | undefined;

  const [text, setText] = useState('');

  // Initialize text when annotation changes
  useEffect(() => {
    if (annotation) {
      setText(annotation.text);
      setIsReady(false);
    }
  }, [annotation?.id]);

  // Focus input on mount
  useEffect(() => {
    if (annotation) {
      const timer = setTimeout(() => {
        inputRef.current?.focus();
        inputRef.current?.select();
        setIsReady(true);
      }, 50);
      return () => clearTimeout(timer);
    }
  }, [annotation?.id]);

  // Update input width based on text content
  useEffect(() => {
    if (measureRef.current && annotation) {
      const width = measureRef.current.offsetWidth;
      setInputWidth(Math.max(50, width + 10));
    }
  }, [text, annotation?.fontSize, scale]);

  if (!annotation || !editingTextId) {
    return null;
  }

  const padding = getPaddingPx(originalWidth, originalHeight);

  // Calculate aspect ratio offset
  const baseWidth = originalWidth + padding * 2;
  const baseHeight = originalHeight + padding * 2;
  const aspectExtension = calculateAspectRatioExtend(baseWidth, baseHeight, outputAspectRatio);
  const contentOffsetX = aspectExtension?.offsetX || 0;
  const contentOffsetY = aspectExtension?.offsetY || 0;

  // Calculate screen position from canvas coordinates
  const canvasX = annotation.x + padding + contentOffsetX;
  const canvasY = annotation.y + padding + contentOffsetY;
  const screenX = canvasX * scale + position.x;
  const screenY = canvasY * scale + position.y;

  const scaledFontSize = annotation.fontSize * scale;

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      updateTextContent(editingTextId, text);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      setEditingTextId(null);
    }
  };

  const handleBlur = () => {
    if (!isReady) return;
    updateTextContent(editingTextId, text);
  };

  return (
    <div
      className="absolute z-50 pointer-events-auto"
      style={{
        left: screenX - 4,
        top: screenY - 2,
      }}
    >
      {/* Hidden span to measure text width */}
      <span
        ref={measureRef}
        className="absolute invisible whitespace-pre"
        style={{
          fontSize: `${scaledFontSize}px`,
          fontFamily: annotation.fontFamily,
        }}
      >
        {text || ' '}
      </span>
      <input
        ref={inputRef}
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        onKeyDown={handleKeyDown}
        onBlur={handleBlur}
        className="px-1 py-0.5 border-2 border-blue-500 rounded outline-none bg-white dark:bg-gray-800"
        style={{
          fontSize: `${scaledFontSize}px`,
          fontFamily: annotation.fontFamily,
          color: annotation.fill,
          width: `${inputWidth}px`,
        }}
      />
    </div>
  );
}
</file>

<file path="src/components/ui/color-picker.tsx">
// ColorPicker - Custom color picker with saturation/brightness canvas and hue slider

import { useRef, useEffect, useCallback, useState } from 'react';

interface ColorPickerProps {
  color: string;
  onChange: (color: string) => void;
}

// Convert hex to RGB
function hexToRgb(hex: string): { r: number; g: number; b: number } {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return { r, g, b };
}

// Convert RGB to hex
function rgbToHex(r: number, g: number, b: number): string {
  const toHex = (x: number) => {
    const hex = Math.max(0, Math.min(255, Math.round(x))).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

// Convert hex to HSV
function hexToHsv(hex: string): { h: number; s: number; v: number } {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;

  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;

  if (d !== 0) {
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }

  return { h: h * 360, s: s * 100, v: v * 100 };
}

// Convert HSV to hex
function hsvToHex(h: number, s: number, v: number): string {
  const hNorm = h / 360;
  const sNorm = s / 100;
  const vNorm = v / 100;

  const i = Math.floor(hNorm * 6);
  const f = hNorm * 6 - i;
  const p = vNorm * (1 - sNorm);
  const q = vNorm * (1 - f * sNorm);
  const t = vNorm * (1 - (1 - f) * sNorm);

  let r = 0, g = 0, b = 0;
  switch (i % 6) {
    case 0: r = vNorm; g = t; b = p; break;
    case 1: r = q; g = vNorm; b = p; break;
    case 2: r = p; g = vNorm; b = t; break;
    case 3: r = p; g = q; b = vNorm; break;
    case 4: r = t; g = p; b = vNorm; break;
    case 5: r = vNorm; g = p; b = q; break;
  }

  const toHex = (x: number) => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };

  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

type ColorMode = 'hex' | 'rgb' | 'hsl';

// Convert RGB to HSL
function rgbToHsl(r: number, g: number, b: number): { h: number; s: number; l: number } {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
    }
  }
  return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
}

// Convert HSL to RGB
function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
  h /= 360;
  s /= 100;
  l /= 100;
  let r, g, b;

  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}

export function ColorPicker({ color, onChange }: ColorPickerProps) {
  const svCanvasRef = useRef<HTMLCanvasElement>(null);
  const hueCanvasRef = useRef<HTMLCanvasElement>(null);
  const [hsv, setHsv] = useState(() => hexToHsv(color || '#ff0000'));
  const [isDraggingSV, setIsDraggingSV] = useState(false);
  const [isDraggingHue, setIsDraggingHue] = useState(false);
  const [colorMode, setColorMode] = useState<ColorMode>('hex');

  // Update HSV when external color changes
  useEffect(() => {
    if (color && /^#[0-9A-Fa-f]{6}$/.test(color)) {
      const newHsv = hexToHsv(color);
      // Only update if significantly different to avoid loops
      if (Math.abs(newHsv.h - hsv.h) > 1 || Math.abs(newHsv.s - hsv.s) > 1 || Math.abs(newHsv.v - hsv.v) > 1) {
        setHsv(newHsv);
      }
    }
  }, [color]);

  // Draw saturation/value canvas
  const drawSVCanvas = useCallback(() => {
    const canvas = svCanvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;

    // Create saturation gradient (left to right: white to pure hue)
    const satGradient = ctx.createLinearGradient(0, 0, width, 0);
    satGradient.addColorStop(0, '#ffffff');
    satGradient.addColorStop(1, hsvToHex(hsv.h, 100, 100));

    ctx.fillStyle = satGradient;
    ctx.fillRect(0, 0, width, height);

    // Create value gradient (top to bottom: transparent to black)
    const valGradient = ctx.createLinearGradient(0, 0, 0, height);
    valGradient.addColorStop(0, 'rgba(0,0,0,0)');
    valGradient.addColorStop(1, '#000000');

    ctx.fillStyle = valGradient;
    ctx.fillRect(0, 0, width, height);
  }, [hsv.h]);

  // Draw hue slider
  const drawHueCanvas = useCallback(() => {
    const canvas = hueCanvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;

    const gradient = ctx.createLinearGradient(0, 0, width, 0);
    gradient.addColorStop(0, '#ff0000');
    gradient.addColorStop(0.17, '#ffff00');
    gradient.addColorStop(0.33, '#00ff00');
    gradient.addColorStop(0.5, '#00ffff');
    gradient.addColorStop(0.67, '#0000ff');
    gradient.addColorStop(0.83, '#ff00ff');
    gradient.addColorStop(1, '#ff0000');

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
  }, []);

  // Redraw canvases
  useEffect(() => {
    drawSVCanvas();
    drawHueCanvas();
  }, [drawSVCanvas, drawHueCanvas]);

  // Handle SV canvas interaction
  const handleSVInteraction = useCallback((clientX: number, clientY: number) => {
    const canvas = svCanvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    const y = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));

    const newS = x * 100;
    const newV = (1 - y) * 100;

    setHsv(prev => ({ ...prev, s: newS, v: newV }));
    onChange(hsvToHex(hsv.h, newS, newV));
  }, [hsv.h, onChange]);

  // Handle hue slider interaction
  const handleHueInteraction = useCallback((clientX: number) => {
    const canvas = hueCanvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    const newH = x * 360;

    setHsv(prev => ({ ...prev, h: newH }));
    onChange(hsvToHex(newH, hsv.s, hsv.v));
  }, [hsv.s, hsv.v, onChange]);

  // Mouse handlers for SV canvas
  const handleSVMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    setIsDraggingSV(true);
    handleSVInteraction(e.clientX, e.clientY);
  };

  // Mouse handlers for hue slider
  const handleHueMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    setIsDraggingHue(true);
    handleHueInteraction(e.clientX);
  };

  // Global mouse move/up handlers
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (isDraggingSV) {
        handleSVInteraction(e.clientX, e.clientY);
      }
      if (isDraggingHue) {
        handleHueInteraction(e.clientX);
      }
    };

    const handleMouseUp = () => {
      setIsDraggingSV(false);
      setIsDraggingHue(false);
    };

    if (isDraggingSV || isDraggingHue) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDraggingSV, isDraggingHue, handleSVInteraction, handleHueInteraction]);

  // Calculate picker positions
  const svPickerX = (hsv.s / 100) * 100;
  const svPickerY = (1 - hsv.v / 100) * 100;
  const huePickerX = (hsv.h / 360) * 100;

  // Get RGB and HSL values from current color
  const rgb = hexToRgb(color || '#000000');
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

  // Cycle through color modes
  const cycleColorMode = () => {
    const modes: ColorMode[] = ['hex', 'rgb', 'hsl'];
    const currentIndex = modes.indexOf(colorMode);
    const nextIndex = (currentIndex + 1) % modes.length;
    setColorMode(modes[nextIndex]);
  };

  // Handle input changes based on mode
  const handleInputChange = (index: number, value: string) => {
    const num = parseInt(value) || 0;

    if (colorMode === 'rgb') {
      const clamped = Math.max(0, Math.min(255, num));
      const newRgb = { ...rgb };
      if (index === 0) newRgb.r = clamped;
      if (index === 1) newRgb.g = clamped;
      if (index === 2) newRgb.b = clamped;
      onChange(rgbToHex(newRgb.r, newRgb.g, newRgb.b));
    } else if (colorMode === 'hsl') {
      const newHsl = { ...hsl };
      if (index === 0) newHsl.h = Math.max(0, Math.min(360, num));
      if (index === 1) newHsl.s = Math.max(0, Math.min(100, num));
      if (index === 2) newHsl.l = Math.max(0, Math.min(100, num));
      const newRgb = hslToRgb(newHsl.h, newHsl.s, newHsl.l);
      onChange(rgbToHex(newRgb.r, newRgb.g, newRgb.b));
    }
  };

  // Handle hex input change
  const handleHexChange = (value: string) => {
    let hex = value.startsWith('#') ? value : `#${value}`;
    if (/^#[0-9A-Fa-f]{0,6}$/.test(hex)) {
      if (hex.length === 7) {
        onChange(hex);
      }
    }
  };

  // Get labels and values for current mode
  const getModeData = () => {
    switch (colorMode) {
      case 'hex':
        return { labels: ['HEX'], values: [color], single: true };
      case 'rgb':
        return { labels: ['R', 'G', 'B'], values: [rgb.r, rgb.g, rgb.b], single: false };
      case 'hsl':
        return { labels: ['H', 'S', 'L'], values: [hsl.h, hsl.s, hsl.l], single: false };
    }
  };

  const modeData = getModeData();

  return (
    <div className="space-y-2">
      {/* Saturation/Value canvas */}
      <div className="relative">
        <canvas
          ref={svCanvasRef}
          width={200}
          height={120}
          className="w-full h-[120px] rounded-lg"
          onMouseDown={handleSVMouseDown}
        />
        {/* SV picker indicator */}
        <div
          className="absolute w-4 h-4 border-2 border-white rounded-full shadow-md pointer-events-none"
          style={{
            left: `calc(${svPickerX}% - 8px)`,
            top: `calc(${svPickerY}% - 8px)`,
            backgroundColor: color,
            boxShadow: '0 0 0 1px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.3)',
          }}
        />
      </div>

      {/* Hue slider with eyedropper button */}
      <div className="flex gap-2 items-center">
        <div className="relative flex-1">
          <canvas
            ref={hueCanvasRef}
            width={200}
            height={16}
            className="w-full h-4 rounded-lg cursor-default"
            onMouseDown={handleHueMouseDown}
          />
          {/* Hue picker indicator */}
          <div
            className="absolute top-0 w-2 h-full border-2 border-white rounded pointer-events-none"
            style={{
              left: `calc(${huePickerX}% - 4px)`,
              boxShadow: '0 0 0 1px rgba(0,0,0,0.3)',
            }}
          />
        </div>
        {/* Eyedropper button - pick color from screen */}
        {'EyeDropper' in window && (
          <button
            onClick={async () => {
              try {
                // @ts-expect-error EyeDropper API
                const eyeDropper = new window.EyeDropper();
                const result = await eyeDropper.open();
                if (result?.sRGBHex) {
                  onChange(result.sRGBHex);
                }
              } catch {
                // User cancelled or API not supported
              }
            }}
            className="w-6 h-6 flex items-center justify-center rounded glass-btn text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors flex-shrink-0"
            title="Pick color from screen"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 3l6 6m-6-6l-9.5 9.5a2.121 2.121 0 00-.5.8L4 18l4.7-1a2.121 2.121 0 00.8-.5L19 7m-4-4l2.5 2.5M7 21h10" />
            </svg>
          </button>
        )}
      </div>

      {/* Color preview and mode-switchable inputs */}
      <div className="flex gap-2 items-center">
        {/* Color preview */}
        <div
          className="w-8 h-8 rounded-lg border border-gray-300 dark:border-gray-600 flex-shrink-0"
          style={{ backgroundColor: color }}
        />

        {/* Mode-switchable inputs - all modes use same column layout */}
        <div className="flex-1 flex gap-1">
          {modeData.single ? (
            /* HEX mode - single column with label on top */
            <div className="flex-1 flex flex-col items-center">
              <span className="text-[10px] text-gray-400 uppercase mb-0.5">HEX</span>
              <input
                type="text"
                value={color}
                onChange={(e) => handleHexChange(e.target.value)}
                className="w-full px-1 py-1 text-xs rounded glass-flat text-gray-800 dark:text-gray-100 font-mono text-center"
                placeholder="#000000"
              />
            </div>
          ) : (
            /* RGB/HSL mode - three columns with label on top, value below */
            modeData.labels.map((label, index) => (
              <div key={label} className="flex-1 flex flex-col items-center">
                <span className="text-[10px] text-gray-400 uppercase mb-0.5">{label}</span>
                <input
                  type="number"
                  min="0"
                  max={colorMode === 'rgb' ? 255 : (index === 0 ? 360 : 100)}
                  value={modeData.values[index]}
                  onChange={(e) => handleInputChange(index, e.target.value)}
                  className="w-full px-1 py-1 text-xs rounded glass-flat text-gray-800 dark:text-gray-100 text-center"
                />
              </div>
            ))
          )}
        </div>

        {/* Mode switch button */}
        <button
          onClick={cycleColorMode}
          className="w-6 h-6 flex items-center justify-center rounded glass-btn text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors flex-shrink-0"
          title={`Switch to ${colorMode === 'hex' ? 'RGB' : colorMode === 'rgb' ? 'HSL' : 'HEX'}`}
        >
          <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
          </svg>
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/capture-flash.tsx">
// CaptureFlash - Full screen white flash effect for screenshot feedback

interface CaptureFlashProps {
  visible: boolean;
}

/**
 * Full-screen flash overlay that briefly appears when taking a screenshot
 * Provides visual feedback similar to camera flash
 */
export function CaptureFlash({ visible }: CaptureFlashProps) {
  if (!visible) return null;

  return (
    <div
      className="fixed inset-0 bg-white pointer-events-none z-[9999] animate-flash"
      aria-hidden="true"
    />
  );
}
</file>

<file path="src/constants/annotations.ts">
// Annotation default values and constants

export const ANNOTATION_DEFAULTS = {
  NUMBER: {
    RADIUS: 15,
    FONT_SIZE: 14,
    TEXT_COLOR: '#ffffff',
  },
  ARROW: {
    POINTER_LENGTH: 10,
    POINTER_WIDTH: 10,
  },
  SPOTLIGHT: {
    OPACITY: 0.5,
    DIMMED_COLOR: 'rgba(0,0,0,0.5)',
  },
  TRANSFORMER: {
    MIN_SIZE: 10,
    MIN_SHAPE_SIZE: 5,
    MIN_SPOTLIGHT_SIZE: 20,
    MIN_FONT_SIZE: 8,
  },
  TEXT: {
    MAX_LENGTH: 500,
  },
  SHAPE: {
    MIN_DRAW_SIZE: 5,
  },
} as const;

// Default canvas fallback dimensions
export const CANVAS_FALLBACK = {
  WIDTH: 1920,
  HEIGHT: 1080,
} as const;
</file>

<file path="src/constants/canvas.ts">
// Canvas constants - shared across canvas components

export const ZOOM = {
  FACTOR: 1.1,
  MIN_SCALE: 0.1,
  MAX_SCALE: 5,
} as const;
</file>

<file path="src/data/__tests__/gradients.test.ts">
import { describe, it, expect } from 'vitest';
import { GRADIENT_PRESETS, SOLID_COLORS, type GradientPreset, type SolidColor } from '../gradients';

describe('Gradients Data', () => {
  describe('GRADIENT_PRESETS', () => {
    it('should have at least 24 gradient presets', () => {
      expect(GRADIENT_PRESETS.length).toBeGreaterThanOrEqual(24);
    });

    it('should have exactly 24 gradient presets', () => {
      expect(GRADIENT_PRESETS.length).toBe(24);
    });

    it('should have unique IDs for all gradients', () => {
      const ids = GRADIENT_PRESETS.map(g => g.id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(GRADIENT_PRESETS.length);
    });

    it('should have unique names for all gradients', () => {
      const names = GRADIENT_PRESETS.map(g => g.name);
      const uniqueNames = new Set(names);
      expect(uniqueNames.size).toBe(GRADIENT_PRESETS.length);
    });

    it('should contain expected gradient categories', () => {
      const ids = GRADIENT_PRESETS.map(g => g.id);

      // Blues
      expect(ids).toContain('ocean');
      expect(ids).toContain('royal');
      expect(ids).toContain('azure');

      // Purples
      expect(ids).toContain('velvet');
      expect(ids).toContain('midnight');
      expect(ids).toContain('cosmic');

      // Warm
      expect(ids).toContain('sunset');
      expect(ids).toContain('sunrise');
      expect(ids).toContain('peach');

      // Greens
      expect(ids).toContain('forest');
      expect(ids).toContain('mint');
      expect(ids).toContain('emerald');

      // Neutrals
      expect(ids).toContain('slate');
      expect(ids).toContain('charcoal');
      expect(ids).toContain('silver');

      // Vibrant
      expect(ids).toContain('rainbow');
      expect(ids).toContain('neon');
      expect(ids).toContain('electric');

      // Soft
      expect(ids).toContain('blush');
      expect(ids).toContain('lavender');
      expect(ids).toContain('cream');

      // Dark
      expect(ids).toContain('obsidian');
      expect(ids).toContain('void');
      expect(ids).toContain('carbon');
    });
  });

  describe('GradientPreset Structure', () => {
    it('should have all required properties', () => {
      GRADIENT_PRESETS.forEach(gradient => {
        expect(gradient).toHaveProperty('id');
        expect(gradient).toHaveProperty('name');
        expect(gradient).toHaveProperty('colors');
        expect(gradient).toHaveProperty('direction');
      });
    });

    it('should have valid ID format (lowercase, no spaces)', () => {
      GRADIENT_PRESETS.forEach(gradient => {
        expect(gradient.id).toMatch(/^[a-z0-9]+$/);
      });
    });

    it('should have non-empty names', () => {
      GRADIENT_PRESETS.forEach(gradient => {
        expect(gradient.name.length).toBeGreaterThan(0);
      });
    });

    it('should have at least 2 colors per gradient', () => {
      GRADIENT_PRESETS.forEach(gradient => {
        expect(gradient.colors.length).toBeGreaterThanOrEqual(2);
      });
    });

    it('should have valid color hex values', () => {
      const hexColorRegex = /^#[0-9A-Fa-f]{6}$/;
      GRADIENT_PRESETS.forEach(gradient => {
        gradient.colors.forEach(color => {
          expect(color).toMatch(hexColorRegex);
        });
      });
    });

    it('should have valid direction values', () => {
      const validDirections = ['linear', 'radial'];
      GRADIENT_PRESETS.forEach(gradient => {
        expect(validDirections).toContain(gradient.direction);
      });
    });

    it('should have angle for linear gradients', () => {
      GRADIENT_PRESETS.forEach(gradient => {
        if (gradient.direction === 'linear') {
          expect(gradient.angle).toBeDefined();
          expect(typeof gradient.angle).toBe('number');
          expect(gradient.angle).toBeGreaterThanOrEqual(0);
          expect(gradient.angle).toBeLessThanOrEqual(360);
        }
      });
    });
  });

  describe('Gradient Presets by Category', () => {
    it('should have Blues category', () => {
      const blues = ['ocean', 'royal', 'azure'];
      blues.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Purples category', () => {
      const purples = ['velvet', 'midnight', 'cosmic'];
      purples.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Warm category', () => {
      const warms = ['sunset', 'sunrise', 'peach'];
      warms.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Greens category', () => {
      const greens = ['forest', 'mint', 'emerald'];
      greens.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Neutrals category', () => {
      const neutrals = ['slate', 'charcoal', 'silver'];
      neutrals.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Vibrant category', () => {
      const vibrants = ['rainbow', 'neon', 'electric'];
      vibrants.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Soft category', () => {
      const softs = ['blush', 'lavender', 'cream'];
      softs.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });

    it('should have Dark category', () => {
      const darks = ['obsidian', 'void', 'carbon'];
      darks.forEach(id => {
        const gradient = GRADIENT_PRESETS.find(g => g.id === id);
        expect(gradient).toBeDefined();
      });
    });
  });

  describe('Specific Gradient Validation', () => {
    it('Ocean gradient should be correct', () => {
      const ocean = GRADIENT_PRESETS.find(g => g.id === 'ocean');
      expect(ocean).toEqual({
        id: 'ocean',
        name: 'Ocean',
        colors: ['#667eea', '#764ba2'],
        direction: 'linear',
        angle: 135,
      });
    });

    it('Rainbow gradient should have 3 colors', () => {
      const rainbow = GRADIENT_PRESETS.find(g => g.id === 'rainbow');
      expect(rainbow?.colors.length).toBe(3);
    });

    it('Void gradient should have 3 colors', () => {
      const void_grad = GRADIENT_PRESETS.find(g => g.id === 'void');
      expect(void_grad?.colors.length).toBe(3);
    });
  });

  describe('SOLID_COLORS', () => {
    it('should exist and be an array', () => {
      expect(Array.isArray(SOLID_COLORS)).toBe(true);
    });

    it('should have multiple color options', () => {
      expect(SOLID_COLORS.length).toBeGreaterThan(0);
    });

    it('should have unique IDs', () => {
      const ids = SOLID_COLORS.map(c => c.id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(SOLID_COLORS.length);
    });

    it('should have valid color structure', () => {
      SOLID_COLORS.forEach(color => {
        expect(color).toHaveProperty('id');
        expect(color).toHaveProperty('name');
        expect(color).toHaveProperty('color');
      });
    });

    it('should have valid hex color values', () => {
      const hexColorRegex = /^#[0-9A-Fa-f]{6}$/;
      SOLID_COLORS.forEach(color => {
        expect(color.color).toMatch(hexColorRegex);
      });
    });

    it('should include basic colors', () => {
      const ids = SOLID_COLORS.map(c => c.id);
      expect(ids).toContain('white');
      expect(ids).toContain('black');
      expect(ids).toContain('gray');
    });
  });

  describe('Interface Compliance', () => {
    it('GRADIENT_PRESETS should match GradientPreset interface', () => {
      GRADIENT_PRESETS.forEach(gradient => {
        const preset: GradientPreset = gradient;
        expect(preset.id).toBeDefined();
        expect(preset.name).toBeDefined();
        expect(preset.colors).toBeDefined();
        expect(preset.direction).toBeDefined();
      });
    });

    it('SOLID_COLORS should match SolidColor interface', () => {
      SOLID_COLORS.forEach(color => {
        const solid: SolidColor = color;
        expect(solid.id).toBeDefined();
        expect(solid.name).toBeDefined();
        expect(solid.color).toBeDefined();
      });
    });
  });
});
</file>

<file path="src/data/gradients.ts">
// Gradient presets library for background beautification
// 24+ gradient presets inspired by Winshot

export interface GradientPreset {
  id: string;
  name: string;
  colors: string[];
  direction: 'linear' | 'radial';
  angle?: number; // for linear gradients
}

export interface SolidColor {
  id: string;
  name: string;
  color: string;
}

export const GRADIENT_PRESETS: GradientPreset[] = [
  // Blues
  { id: 'ocean', name: 'Ocean', colors: ['#667eea', '#764ba2'], direction: 'linear', angle: 135 },
  { id: 'royal', name: 'Royal', colors: ['#141E30', '#243B55'], direction: 'linear', angle: 180 },
  { id: 'azure', name: 'Azure', colors: ['#0099F7', '#F11712'], direction: 'linear', angle: 135 },

  // Purples
  { id: 'velvet', name: 'Velvet', colors: ['#DA22FF', '#9733EE'], direction: 'linear', angle: 135 },
  { id: 'midnight', name: 'Midnight', colors: ['#232526', '#414345'], direction: 'linear', angle: 180 },
  { id: 'cosmic', name: 'Cosmic', colors: ['#ff00cc', '#333399'], direction: 'linear', angle: 135 },

  // Warm
  { id: 'sunset', name: 'Sunset', colors: ['#f12711', '#f5af19'], direction: 'linear', angle: 135 },
  { id: 'sunrise', name: 'Sunrise', colors: ['#FF512F', '#F09819'], direction: 'linear', angle: 90 },
  { id: 'peach', name: 'Peach', colors: ['#ed4264', '#ffedbc'], direction: 'linear', angle: 135 },

  // Greens
  { id: 'forest', name: 'Forest', colors: ['#134E5E', '#71B280'], direction: 'linear', angle: 135 },
  { id: 'mint', name: 'Mint', colors: ['#00b09b', '#96c93d'], direction: 'linear', angle: 135 },
  { id: 'emerald', name: 'Emerald', colors: ['#348F50', '#56B4D3'], direction: 'linear', angle: 135 },

  // Neutrals
  { id: 'slate', name: 'Slate', colors: ['#2C3E50', '#4CA1AF'], direction: 'linear', angle: 135 },
  { id: 'charcoal', name: 'Charcoal', colors: ['#373B44', '#4286f4'], direction: 'linear', angle: 135 },
  { id: 'silver', name: 'Silver', colors: ['#bdc3c7', '#2c3e50'], direction: 'linear', angle: 180 },

  // Vibrant
  { id: 'rainbow', name: 'Rainbow', colors: ['#f12711', '#f5af19', '#56B4D3'], direction: 'linear', angle: 90 },
  { id: 'neon', name: 'Neon', colors: ['#12c2e9', '#c471ed', '#f64f59'], direction: 'linear', angle: 90 },
  { id: 'electric', name: 'Electric', colors: ['#4776E6', '#8E54E9'], direction: 'linear', angle: 135 },

  // Soft
  { id: 'blush', name: 'Blush', colors: ['#ffecd2', '#fcb69f'], direction: 'linear', angle: 135 },
  { id: 'lavender', name: 'Lavender', colors: ['#e0c3fc', '#8ec5fc'], direction: 'linear', angle: 135 },
  { id: 'cream', name: 'Cream', colors: ['#fdfbfb', '#ebedee'], direction: 'linear', angle: 180 },

  // Dark
  { id: 'obsidian', name: 'Obsidian', colors: ['#000000', '#434343'], direction: 'linear', angle: 180 },
  { id: 'void', name: 'Void', colors: ['#0f0c29', '#302b63', '#24243e'], direction: 'linear', angle: 135 },
  { id: 'carbon', name: 'Carbon', colors: ['#1c1c1c', '#383838'], direction: 'linear', angle: 180 },
];

export const SOLID_COLORS: SolidColor[] = [
  { id: 'white', name: 'White', color: '#ffffff' },
  { id: 'black', name: 'Black', color: '#000000' },
  { id: 'gray', name: 'Gray', color: '#6b7280' },
  { id: 'red', name: 'Red', color: '#ef4444' },
  { id: 'blue', name: 'Blue', color: '#3b82f6' },
  { id: 'green', name: 'Green', color: '#22c55e' },
];
</file>

<file path="src/hooks/use-capture-feedback.ts">
// useCaptureFeeback - Provides visual and audio feedback for screenshot capture
// Includes camera shutter sound and screen flash effect

import { useState, useCallback, useRef, useEffect } from 'react';

interface UseCaptureFebackReturn {
  showFlash: boolean;
  triggerFeedback: () => void;
}

/**
 * Creates a function to play the macOS screen capture sound
 * Uses the system's native screenshot sound for familiar UX
 */
function createShutterSound(): () => void {
  let audio: HTMLAudioElement | null = null;

  return () => {
    try {
      if (!audio) {
        audio = new Audio('/screen-capture.aif');
        audio.volume = 0.7;
      }
      audio.currentTime = 0;
      audio.play().catch(() => {/* ignore autoplay restrictions */});
    } catch {
      // Silently fail
    }
  };
}

/**
 * Hook that provides screenshot capture feedback
 * - Visual flash effect (white screen flash)
 * - Audio shutter sound
 */
export function useCaptureFeedback(): UseCaptureFebackReturn {
  const [showFlash, setShowFlash] = useState(false);
  const playSound = useRef(createShutterSound());

  // Cleanup flash state after animation
  useEffect(() => {
    if (showFlash) {
      const timer = setTimeout(() => setShowFlash(false), 150);
      return () => clearTimeout(timer);
    }
  }, [showFlash]);

  const triggerFeedback = useCallback(() => {
    // Play shutter sound
    playSound.current();
    // Show flash
    setShowFlash(true);
  }, []);

  return { showFlash, triggerFeedback };
}
</file>

<file path="src/hooks/use-click-away.ts">
// useClickAway hook - Close dropdown on outside click or ESC

import { useEffect, RefObject } from 'react';

export function useClickAway(
  ref: RefObject<HTMLElement | null>,
  onClickAway: () => void,
  enabled: boolean = true
) {
  useEffect(() => {
    if (!enabled) return;

    const handleClick = (e: MouseEvent | TouchEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        onClickAway();
      }
    };

    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClickAway();
    };

    document.addEventListener('mousedown', handleClick);
    document.addEventListener('touchstart', handleClick);
    document.addEventListener('keydown', handleEsc);

    return () => {
      document.removeEventListener('mousedown', handleClick);
      document.removeEventListener('touchstart', handleClick);
      document.removeEventListener('keydown', handleEsc);
    };
  }, [ref, onClickAway, enabled]);
}
</file>

<file path="src/hooks/use-transform-handler.ts">
// useTransformHandler - Shared transform logic for annotation shapes

import { useCallback } from 'react';
import Konva from 'konva';
import { useAnnotationStore } from '../stores/annotation-store';
import { ANNOTATION_DEFAULTS } from '../constants/annotations';
import type { Annotation } from '../types/annotations';

type ShapeType = 'rect' | 'ellipse' | 'text' | 'spotlight';

interface ShapeContext {
  radiusX?: number;
  radiusY?: number;
  fontSize?: number;
}

/**
 * Shared hook for handling shape transformation (resize/rotate)
 * Reduces code duplication across shape components
 */
export function useTransformHandler(
  annotationId: string,
  shapeType: ShapeType,
  context?: ShapeContext
) {
  const { updateAnnotation } = useAnnotationStore();

  const handleTransformEnd = useCallback(
    (e: Konva.KonvaEventObject<Event>) => {
      const node = e.target;
      const updates: Partial<Annotation> = {
        x: node.x(),
        y: node.y(),
        rotation: node.rotation(),
      };

      // Shape-specific updates
      switch (shapeType) {
        case 'rect':
          Object.assign(updates, {
            width: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SHAPE_SIZE,
              node.width() * node.scaleX()
            ),
            height: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SHAPE_SIZE,
              node.height() * node.scaleY()
            ),
          });
          break;

        case 'ellipse':
          Object.assign(updates, {
            radiusX: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SHAPE_SIZE,
              (context?.radiusX ?? 50) * node.scaleX()
            ),
            radiusY: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SHAPE_SIZE,
              (context?.radiusY ?? 50) * node.scaleY()
            ),
          });
          break;

        case 'text':
          Object.assign(updates, {
            fontSize: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_FONT_SIZE,
              (context?.fontSize ?? 16) * node.scaleY()
            ),
          });
          break;

        case 'spotlight':
          Object.assign(updates, {
            width: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SPOTLIGHT_SIZE,
              node.width() * node.scaleX()
            ),
            height: Math.max(
              ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SPOTLIGHT_SIZE,
              node.height() * node.scaleY()
            ),
          });
          break;
      }

      updateAnnotation(annotationId, updates);

      // Reset scale after applying to dimensions
      node.scaleX(1);
      node.scaleY(1);
    },
    [annotationId, shapeType, context?.radiusX, context?.radiusY, context?.fontSize, updateAnnotation]
  );

  return handleTransformEnd;
}
</file>

<file path="src/stores/toast-store.ts">
// Toast store - Zustand state for in-app toast notifications

import { create } from 'zustand';
import { nanoid } from 'nanoid';
import type { ToastData } from '../components/common/toast';

interface ToastState {
  toasts: ToastData[];
  addToast: (toast: Omit<ToastData, 'id'>) => void;
  removeToast: (id: string) => void;
  clearToasts: () => void;
}

export const useToastStore = create<ToastState>((set) => ({
  toasts: [],

  addToast: (toast) =>
    set((state) => ({
      toasts: [...state.toasts, { ...toast, id: nanoid() }],
    })),

  removeToast: (id) =>
    set((state) => ({
      toasts: state.toasts.filter((t) => t.id !== id),
    })),

  clearToasts: () => set({ toasts: [] }),
}));

// Helper functions for common toast types
export const toast = {
  success: (title: string, message: string, filePath?: string) => {
    useToastStore.getState().addToast({
      type: 'success',
      title,
      message,
      filePath,
    });
  },
  error: (title: string, message: string) => {
    useToastStore.getState().addToast({
      type: 'error',
      title,
      message,
    });
  },
  info: (title: string, message: string) => {
    useToastStore.getState().addToast({
      type: 'info',
      title,
      message,
    });
  },
};
</file>

<file path="src/stores/ui-store.ts">
// UI store - Zustand state management for UI modals and dialogs

import { create } from 'zustand';

interface UIState {
  // Modal states
  isWindowPickerOpen: boolean;
  isSettingsOpen: boolean;

  // Actions
  openWindowPicker: () => void;
  closeWindowPicker: () => void;
  openSettings: () => void;
  closeSettings: () => void;
}

export const useUIStore = create<UIState>((set) => ({
  isWindowPickerOpen: false,
  isSettingsOpen: false,

  openWindowPicker: () => set({ isWindowPickerOpen: true }),
  closeWindowPicker: () => set({ isWindowPickerOpen: false }),
  openSettings: () => set({ isSettingsOpen: true }),
  closeSettings: () => set({ isSettingsOpen: false }),
}));
</file>

<file path="src/types/screenshot.ts">
// Screenshot capture types for Tauri IPC

export interface MonitorInfo {
  id: number;
  name: string;
  width: number;
  height: number;
  x: number;
  y: number;
  is_primary: boolean;
}

export interface WindowInfo {
  id: number;
  app_name: string;
  title: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface CaptureRegion {
  x: number;
  y: number;
  width: number;
  height: number;
}
</file>

<file path="src/utils/color-extractor.ts">
// Color extractor - Extract dominant color from image for auto background

/**
 * Extract the dominant/average color from an image URL
 * Samples pixels from the edges of the image for better background matching
 */
export async function extractDominantColor(imageUrl: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';

    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          resolve('#808080'); // Fallback gray
          return;
        }

        // Use a small sample size for performance
        const sampleSize = Math.min(img.width, img.height, 100);
        canvas.width = sampleSize;
        canvas.height = sampleSize;

        // Draw scaled image
        ctx.drawImage(img, 0, 0, sampleSize, sampleSize);

        // Sample pixels from edges (top, bottom, left, right borders)
        const edgeWidth = Math.max(1, Math.floor(sampleSize * 0.1)); // 10% border
        const pixels: { r: number; g: number; b: number }[] = [];

        const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);
        const data = imageData.data;

        // Sample from top edge
        for (let y = 0; y < edgeWidth; y++) {
          for (let x = 0; x < sampleSize; x++) {
            const i = (y * sampleSize + x) * 4;
            pixels.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
          }
        }

        // Sample from bottom edge
        for (let y = sampleSize - edgeWidth; y < sampleSize; y++) {
          for (let x = 0; x < sampleSize; x++) {
            const i = (y * sampleSize + x) * 4;
            pixels.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
          }
        }

        // Sample from left edge
        for (let y = edgeWidth; y < sampleSize - edgeWidth; y++) {
          for (let x = 0; x < edgeWidth; x++) {
            const i = (y * sampleSize + x) * 4;
            pixels.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
          }
        }

        // Sample from right edge
        for (let y = edgeWidth; y < sampleSize - edgeWidth; y++) {
          for (let x = sampleSize - edgeWidth; x < sampleSize; x++) {
            const i = (y * sampleSize + x) * 4;
            pixels.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
          }
        }

        if (pixels.length === 0) {
          resolve('#808080');
          return;
        }

        // Calculate average color
        const avgR = Math.round(pixels.reduce((sum, p) => sum + p.r, 0) / pixels.length);
        const avgG = Math.round(pixels.reduce((sum, p) => sum + p.g, 0) / pixels.length);
        const avgB = Math.round(pixels.reduce((sum, p) => sum + p.b, 0) / pixels.length);

        // Convert to hex
        const toHex = (n: number) => n.toString(16).padStart(2, '0');
        const hexColor = `#${toHex(avgR)}${toHex(avgG)}${toHex(avgB)}`;

        resolve(hexColor);
      } catch {
        resolve('#808080'); // Fallback gray
      }
    };

    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };

    img.src = imageUrl;
  });
}

/**
 * Lighten or darken a hex color
 */
export function adjustColorBrightness(hex: string, percent: number): string {
  const num = parseInt(hex.replace('#', ''), 16);
  const amt = Math.round(2.55 * percent);
  const R = Math.min(255, Math.max(0, (num >> 16) + amt));
  const G = Math.min(255, Math.max(0, ((num >> 8) & 0x00ff) + amt));
  const B = Math.min(255, Math.max(0, (num & 0x0000ff) + amt));
  return `#${((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
}
</file>

<file path="src/utils/hotkey-formatter.ts">
/**
 * Detects the current OS
 */
export function getOS(): 'macos' | 'windows' | 'linux' | 'unknown' {
    const userAgent = window.navigator.userAgent.toLowerCase();
    if (userAgent.includes('mac')) return 'macos';
    if (userAgent.includes('win')) return 'windows';
    if (userAgent.includes('linux')) return 'linux';
    return 'unknown';
}

/**
 * Formats a hotkey string for display
 * replaces long modifier names with short ones or symbols based on OS
 */
export function formatHotkey(hotkey: string): string {
    if (!hotkey) return '';

    const os = getOS();

    let formatted = hotkey
        // Normalize logic operators
        .replace('CommandOrControl', os === 'macos' ? 'Cmd' : 'Ctrl')
        .replace('CmdOrCtrl', os === 'macos' ? 'Cmd' : 'Ctrl')
        .replace('Command', 'Cmd')
        .replace('Control', 'Ctrl')
        .replace('Option', os === 'macos' ? 'Opt' : 'Alt')
        .replace('Alt', os === 'macos' ? 'Opt' : 'Alt')
        .replace('Shift', 'Shift')
        .replace('Super', 'Cmd')
        .replace('Meta', 'Cmd');

    // Ensure uppercase keys
    const parts = formatted.split('+');
    if (parts.length > 0) {
        const lastPart = parts.pop();
        if (lastPart) {
            parts.push(lastPart.toUpperCase());
        }
        formatted = parts.join('+');
    }

    return formatted;
}
</file>

<file path="src/utils/image-db.ts">
// IndexedDB storage for background images
// Much larger storage capacity than localStorage (hundreds of MB to GB)

const DB_NAME = 'beautyscreenshot-images';
const DB_VERSION = 1;
const STORE_NAME = 'background-images';

export interface StoredImage {
  id: string;
  dataUrl: string; // Full quality image
  thumbnail: string; // Small preview for UI
  timestamp: number;
}

let dbInstance: IDBDatabase | null = null;

// Initialize the database
function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    if (dbInstance) {
      resolve(dbInstance);
      return;
    }

    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      reject(new Error('Failed to open IndexedDB'));
    };

    request.onsuccess = () => {
      dbInstance = request.result;
      resolve(dbInstance);
    };

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        store.createIndex('timestamp', 'timestamp', { unique: false });
      }
    };
  });
}

// Add image to database
export async function addImageToDB(image: StoredImage): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.put(image);

    request.onsuccess = () => resolve();
    request.onerror = () => reject(new Error('Failed to add image'));
  });
}

// Get all images from database (sorted by timestamp, newest first)
export async function getAllImagesFromDB(): Promise<StoredImage[]> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();

    request.onsuccess = () => {
      const images = request.result as StoredImage[];
      // Sort by timestamp descending (newest first)
      images.sort((a, b) => b.timestamp - a.timestamp);
      resolve(images);
    };
    request.onerror = () => reject(new Error('Failed to get images'));
  });
}

// Get single image by ID
export async function getImageFromDB(id: string): Promise<StoredImage | null> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.get(id);

    request.onsuccess = () => resolve(request.result || null);
    request.onerror = () => reject(new Error('Failed to get image'));
  });
}

// Remove image from database
export async function removeImageFromDB(id: string): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.delete(id);

    request.onsuccess = () => resolve();
    request.onerror = () => reject(new Error('Failed to remove image'));
  });
}

// Clear all images from database
export async function clearAllImagesFromDB(): Promise<void> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.clear();

    request.onsuccess = () => resolve();
    request.onerror = () => reject(new Error('Failed to clear images'));
  });
}

// Get count of images
export async function getImageCountFromDB(): Promise<number> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.count();

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(new Error('Failed to count images'));
  });
}

// Remove oldest images to maintain max count
export async function trimOldestImages(maxCount: number): Promise<void> {
  const images = await getAllImagesFromDB();
  if (images.length <= maxCount) return;

  // Remove oldest images (they're already sorted newest first)
  const toRemove = images.slice(maxCount);
  for (const img of toRemove) {
    await removeImageFromDB(img.id);
  }
}
</file>

<file path="src/utils/logger.ts">
// Logger utility for error handling and debugging

interface LogOptions {
  context: string;
  data?: unknown;
}

/**
 * Production-safe logging utility
 * Only logs in development mode
 */
export const logger = {
  error: (message: string, options?: LogOptions) => {
    if (import.meta.env.DEV) {
      const prefix = options?.context ? `[${options.context}]` : '';
      console.error(`${prefix} ${message}`, options?.data ?? '');
    }
    // TODO: Send to error tracking service in production (Sentry, etc.)
  },

  warn: (message: string, options?: LogOptions) => {
    if (import.meta.env.DEV) {
      const prefix = options?.context ? `[${options.context}]` : '';
      console.warn(`${prefix} ${message}`, options?.data ?? '');
    }
  },

  info: (message: string, options?: LogOptions) => {
    if (import.meta.env.DEV) {
      const prefix = options?.context ? `[${options.context}]` : '';
      console.info(`${prefix} ${message}`, options?.data ?? '');
    }
  },

  debug: (message: string, options?: LogOptions) => {
    if (import.meta.env.DEV) {
      const prefix = options?.context ? `[${options.context}]` : '';
      console.debug(`${prefix} ${message}`, options?.data ?? '');
    }
  },
};

/**
 * Log error with context - convenience wrapper
 */
export function logError(context: string, error: unknown): void {
  logger.error('An error occurred', { context, data: error });
}
</file>

<file path="src/utils/sanitize.ts">
// Text sanitization utilities for security

/**
 * Sanitize user text input to prevent XSS and enforce limits
 * @param input - Raw user input
 * @param maxLength - Maximum allowed length (default 500)
 * @returns Sanitized string
 */
export function sanitizeTextInput(input: string, maxLength = 500): string {
  return input
    .trim()
    .slice(0, maxLength)
    .replace(/[<>]/g, ''); // Basic XSS prevention
}

/**
 * Validate text input is not empty after sanitization
 * @param input - Raw user input
 * @returns Sanitized text or null if empty
 */
export function validateTextInput(input: string | null): string | null {
  if (!input) return null;
  const sanitized = sanitizeTextInput(input);
  return sanitized.length > 0 ? sanitized : null;
}
</file>

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./styles.css";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="src/overlay-main.tsx">
// Overlay entry point - React entry for region selection overlay window

import React from 'react';
import ReactDOM from 'react-dom/client';
import { RegionOverlay } from './components/region-overlay';
import './styles.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RegionOverlay />
  </React.StrictMode>
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src-tauri/src/file_ops.rs">
// File operations for BeautyShot export system

use std::path::PathBuf;

/// Maximum file size limit (50MB) - prevents DoS from excessively large exports
const MAX_FILE_SIZE: usize = 50 * 1024 * 1024;

/// Save binary data to file at specified path
/// Security: Validates path and enforces size limits
#[tauri::command]
pub async fn save_file(path: String, data: Vec<u8>) -> Result<String, String> {
    // Enforce file size limit
    if data.len() > MAX_FILE_SIZE {
        return Err(format!(
            "File size ({} MB) exceeds maximum allowed ({} MB)",
            data.len() / (1024 * 1024),
            MAX_FILE_SIZE / (1024 * 1024)
        ));
    }

    let path = PathBuf::from(&path);

    // Canonicalize path to prevent directory traversal attacks
    // For new files, canonicalize the parent directory
    let canonical_path = if let Some(parent) = path.parent() {
        // Create parent if needed, then canonicalize
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create directory: {}", e))?;

        let canonical_parent = parent
            .canonicalize()
            .map_err(|e| format!("Invalid path: {}", e))?;

        // Ensure we're not escaping to unexpected locations
        if let Some(filename) = path.file_name() {
            canonical_parent.join(filename)
        } else {
            return Err("Invalid filename".to_string());
        }
    } else {
        return Err("Invalid path: no parent directory".to_string());
    };

    // Validate the path doesn't contain suspicious patterns
    let path_str = canonical_path.to_string_lossy();
    if path_str.contains("..") {
        return Err("Invalid path: directory traversal not allowed".to_string());
    }

    std::fs::write(&canonical_path, data)
        .map_err(|e| format!("Failed to save file: {}", e))?;

    Ok(canonical_path.to_string_lossy().to_string())
}

/// Get Pictures directory with BeautyShot subfolder
#[tauri::command]
pub fn get_pictures_dir() -> Result<String, String> {
    dirs::picture_dir()
        .map(|p| p.join("BeautyShot").to_string_lossy().to_string())
        .ok_or_else(|| "Could not find Pictures directory".to_string())
}

/// Get Desktop directory
#[tauri::command]
pub fn get_desktop_dir() -> Result<String, String> {
    dirs::desktop_dir()
        .map(|p| p.to_string_lossy().to_string())
        .ok_or_else(|| "Could not find Desktop directory".to_string())
}
</file>

<file path="src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    beautyfullshot_lib::run()
}
</file>

<file path="src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="src-tauri/beautyfullshot.desktop">
[Desktop Entry]
Name=BeautyFullShot
Comment=Screenshot beautification app
Exec=beautyfullshot
Icon=beautyfullshot
Type=Application
Categories=Graphics;Utility;
Keywords=screenshot;capture;annotation;beautify;
StartupWMClass=beautyfullshot
</file>

<file path="src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="src-tauri/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSScreenCaptureDescription</key>
    <string>BeautyFullShot needs screen recording permission to capture screenshots.</string>
    <key>LSUIElement</key>
    <true/>
</dict>
</plist>
</file>

<file path="debug-app.mjs">
import { chromium } from 'playwright';

async function debugApp() {
  const browser = await chromium.launch({ headless: false });
  const page = await browser.newPage();

  // Collect console messages
  const logs = [];
  page.on('console', msg => {
    logs.push('[' + msg.type() + '] ' + msg.text());
  });

  // Collect page errors
  const errors = [];
  page.on('pageerror', err => {
    errors.push(err.message);
  });

  try {
    console.log('Navigating to http://localhost:1420...');
    await page.goto('http://localhost:1420', { waitUntil: 'networkidle', timeout: 30000 });

    // Wait a bit for any async errors
    await page.waitForTimeout(2000);

    // Get page content
    const bodyText = await page.locator('body').innerText().catch(() => '(empty)');

    console.log('\n=== PAGE INFO ===');
    console.log('Title:', await page.title());
    console.log('URL:', page.url());
    console.log('Body text length:', bodyText.length);
    console.log('Body text preview:', bodyText.slice(0, 200) || '(empty)');

    console.log('\n=== CONSOLE LOGS ===');
    logs.forEach(log => console.log(log));

    console.log('\n=== PAGE ERRORS ===');
    if (errors.length === 0) {
      console.log('(no errors)');
    } else {
      errors.forEach(err => console.log('ERROR:', err));
    }

    // Check for specific elements
    console.log('\n=== DOM CHECK ===');
    console.log('#root exists:', await page.locator('#root').count() > 0);
    const rootHtml = await page.locator('#root').innerHTML().catch(() => '');
    console.log('#root innerHTML length:', rootHtml.length);
    console.log('#root innerHTML preview:', rootHtml.slice(0, 500));

    // Take screenshot
    await page.screenshot({ path: '/tmp/debug-screenshot.png', fullPage: true });
    console.log('\nScreenshot saved to /tmp/debug-screenshot.png');

  } catch (err) {
    console.error('Navigation error:', err.message);
  }

  await browser.close();
}

debugApp();
</file>

<file path="debug-sidebar.html">
<!DOCTYPE html>
<html>
<head>
  <title>Debug Sidebar Visibility</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    .container { display: flex; height: 100vh; }
    .main { flex: 1; background: #f0f0f0; padding: 20px; }
    .sidebar { width: 256px; background: white; border-left: 1px solid #e0e0e0; }
    .info { padding: 20px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="main">
      <h1>Main Content Area</h1>
      <p>Current window state:</p>
      <ul>
        <li>Window Width: <span id="width"></span>px</li>
        <li>Window Height: <span id="height"></span>px</li>
        <li>Fullscreen: <span id="fullscreen"></span></li>
      </ul>
    </div>
    <div class="sidebar">
      <div class="info">
        <h2>Sidebar (w-64 = 256px)</h2>
        <p>This sidebar should always be visible</p>
      </div>
    </div>
  </div>

  <script>
    function updateInfo() {
      document.getElementById('width').textContent = window.innerWidth;
      document.getElementById('height').textContent = window.innerHeight;
      document.getElementById('fullscreen').textContent = document.fullscreenElement ? 'Yes' : 'No';
    }

    updateInfo();
    window.addEventListener('resize', updateInfo);
    document.addEventListener('fullscreenchange', updateInfo);
  </script>
</body>
</html>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 BeautyFullShot Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'text-summary'],
      include: [
        'src/stores/**/*.ts',
        'src/data/**/*.ts'
      ],
      exclude: [
        'node_modules/',
        'src/**/*.d.ts'
      ]
    }
  }
});
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-01-project-setup.md">
# Phase 01: Project Setup & Scaffolding

**Status**: ✅ DONE | **Effort**: 2h | **Priority**: P1
**Completed**: 2025-12-27 | **Review Report**: `../reports/code-reviewer-251227-0323-phase01-setup.md`

## Objective

Bootstrap Tauri v2 + React + TypeScript project with proper Rust toolchain, dependencies, and folder structure.

---

## Prerequisites

- Rust 1.70+ installed (`rustup update stable`)
- Node.js 18+ LTS
- Platform build tools:
  - Windows: Visual Studio Build Tools 2022
  - macOS: Xcode Command Line Tools
  - Linux: `build-essential`, `libwebkit2gtk-4.1-dev`, `libgtk-3-dev`

---

## Tasks

### 1.1 Create Tauri Project

```bash
cd /Users/dcppsw/Projects/beautyshot
npm create tauri-app@latest . -- --template react-ts --package-manager npm
```

**Expected structure:**
```
beautyshot/
├── src/                    # React frontend
│   ├── App.tsx
│   ├── main.tsx
│   └── styles.css
├── src-tauri/              # Rust backend
│   ├── src/
│   │   └── main.rs
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   └── capabilities/
│       └── default.json
├── package.json
├── tsconfig.json
├── vite.config.ts
└── index.html
```

### 1.2 Install Frontend Dependencies

```bash
npm install react-konva@18 konva
npm install @tauri-apps/api@2
npm install @tauri-apps/plugin-global-shortcut @tauri-apps/plugin-notification
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

### 1.3 Configure Tailwind CSS

**tailwind.config.js:**
```js
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: { extend: {} },
  plugins: [],
}
```

**src/styles.css:**
```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

### 1.4 Add Rust Dependencies

**src-tauri/Cargo.toml:**
```toml
[dependencies]
tauri = { version = "2.0", features = [] }
tauri-plugin-global-shortcut = "2.0"
tauri-plugin-notification = "2.0"
xcap = "0.8"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[build-dependencies]
tauri-build = { version = "2.0", features = [] }
```

### 1.5 Configure Tauri

**src-tauri/tauri.conf.json:**
```json
{
  "$schema": "https://schema.tauri.app/config/2.0.0",
  "productName": "BeautyShot",
  "version": "0.1.0",
  "identifier": "com.beautyshot.app",
  "build": {
    "beforeBuildCommand": "npm run build",
    "devPath": "http://localhost:5173",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [{
      "title": "BeautyShot",
      "width": 1200,
      "height": 800,
      "resizable": true,
      "fullscreen": false
    }],
    "security": {
      "csp": null
    }
  }
}
```

### 1.6 Setup Capabilities

**src-tauri/capabilities/default.json:**
```json
{
  "identifier": "default",
  "description": "Default capabilities for BeautyShot",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "core:window:default",
    "global-shortcut:default",
    "notification:default"
  ]
}
```

### 1.7 Create Folder Structure

```
src/
├── components/
│   ├── canvas/           # Konva canvas components
│   ├── toolbar/          # Tool selection UI
│   ├── sidebar/          # Settings panels
│   └── common/           # Shared components
├── hooks/                # Custom React hooks
├── stores/               # State management
├── utils/                # Helper functions
├── types/                # TypeScript types
└── assets/               # Icons, images
```

---

## Verification

```bash
# Run dev mode
npm run tauri dev

# Expected: Window opens with React app
# Console shows: Tauri is ready
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `package.json` | Create (via scaffolding) |
| `src-tauri/Cargo.toml` | Modify (add deps) |
| `src-tauri/tauri.conf.json` | Modify (configure) |
| `src-tauri/capabilities/default.json` | Create |
| `tailwind.config.js` | Create |
| `src/styles.css` | Modify (tailwind) |

---

## Success Criteria

- [✅] `npm run tauri dev` opens window without errors
- [✅] React app renders in Tauri webview
- [✅] Rust compiles without warnings (423 crates compiled)
- [✅] Tailwind CSS classes work (v4 stable)
- [✅] Folder structure created

## Issues Fixed (2025-12-27)

All critical issues from code review have been resolved:
- ✅ **C1**: CSP enabled with proper security policy
- ✅ **C3**: Product name standardized to `BeautyFullShot` (per Round 2 validation)
- ✅ **M2**: Added `rel="noopener noreferrer"` to external links
- ✅ **H2**: .gitkeep files added to empty folders
- ✅ Title updated in `index.html`

---

## Platform Notes

- **macOS**: First build takes 5-10min (compiling Rust deps)
- **Windows**: Ensure WebView2 runtime installed
- **Linux**: Install webkit2gtk dev package first

---

## Next Phase

[Phase 02: Screenshot Capture](./phase-02-screenshot-capture.md)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-02-screenshot-capture.md">
# Phase 02: Core Screenshot Functionality

**Status**: completed | **Effort**: 4h | **Priority**: P1 | **Reviewed**: 2025-12-27

## Objective

Implement screenshot capture using xcap crate with IPC commands for fullscreen, region, and window capture modes.

---

## Tasks

### 2.1 Rust Screenshot Commands

**src-tauri/src/screenshot.rs:**
```rust
use xcap::{Monitor, Window as XcapWindow};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct MonitorInfo {
    pub id: u32,
    pub name: String,
    pub width: u32,
    pub height: u32,
    pub x: i32,
    pub y: i32,
    pub is_primary: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WindowInfo {
    pub id: u32,
    pub app_name: String,
    pub title: String,
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}

/// Capture primary monitor
#[tauri::command]
pub fn capture_fullscreen() -> Result<Vec<u8>, String> {
    let monitors = Monitor::all().map_err(|e| e.to_string())?;
    let primary = monitors.into_iter()
        .find(|m| m.is_primary())
        .ok_or("No primary monitor found")?;

    let image = primary.capture_image().map_err(|e| e.to_string())?;
    Ok(image.to_png().map_err(|e| e.to_string())?)
}

/// Capture specific region
#[tauri::command]
pub fn capture_region(x: i32, y: i32, width: u32, height: u32) -> Result<Vec<u8>, String> {
    let monitors = Monitor::all().map_err(|e| e.to_string())?;
    let monitor = monitors.into_iter()
        .find(|m| m.is_primary())
        .ok_or("No primary monitor")?;

    let image = monitor.capture_image().map_err(|e| e.to_string())?;

    // Crop to region
    let cropped = image::imageops::crop_imm(
        &image,
        x as u32,
        y as u32,
        width,
        height
    ).to_image();

    let mut bytes = Vec::new();
    cropped.write_to(&mut std::io::Cursor::new(&mut bytes), image::ImageFormat::Png)
        .map_err(|e| e.to_string())?;

    Ok(bytes)
}

/// Get list of capturable windows
#[tauri::command]
pub fn get_windows() -> Result<Vec<WindowInfo>, String> {
    let windows = XcapWindow::all().map_err(|e| e.to_string())?;

    Ok(windows.into_iter()
        .filter(|w| !w.title().is_empty())
        .map(|w| WindowInfo {
            id: w.id(),
            app_name: w.app_name().to_string(),
            title: w.title().to_string(),
            x: w.x(),
            y: w.y(),
            width: w.width(),
            height: w.height(),
        })
        .collect())
}

/// Capture specific window by ID
#[tauri::command]
pub fn capture_window(window_id: u32) -> Result<Vec<u8>, String> {
    let windows = XcapWindow::all().map_err(|e| e.to_string())?;
    let window = windows.into_iter()
        .find(|w| w.id() == window_id)
        .ok_or("Window not found")?;

    let image = window.capture_image().map_err(|e| e.to_string())?;
    Ok(image.to_png().map_err(|e| e.to_string())?)
}

/// Get monitor list
#[tauri::command]
pub fn get_monitors() -> Result<Vec<MonitorInfo>, String> {
    let monitors = Monitor::all().map_err(|e| e.to_string())?;

    Ok(monitors.into_iter().map(|m| MonitorInfo {
        id: m.id(),
        name: m.name().to_string(),
        width: m.width(),
        height: m.height(),
        x: m.x(),
        y: m.y(),
        is_primary: m.is_primary(),
    }).collect())
}
```

### 2.2 Register Commands in main.rs

**src-tauri/src/main.rs:**
```rust
mod screenshot;

fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_global_shortcut::Builder::new().build())
        .plugin(tauri_plugin_notification::init())
        .invoke_handler(tauri::generate_handler![
            screenshot::capture_fullscreen,
            screenshot::capture_region,
            screenshot::capture_window,
            screenshot::get_windows,
            screenshot::get_monitors,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 2.3 TypeScript Types & API

**src/types/screenshot.ts:**
```typescript
export interface MonitorInfo {
  id: number;
  name: string;
  width: number;
  height: number;
  x: number;
  y: number;
  is_primary: boolean;
}

export interface WindowInfo {
  id: number;
  app_name: string;
  title: string;
  x: number;
  y: number;
  width: number;
  height: number;
}
```

**src/utils/screenshot-api.ts:**
```typescript
import { invoke } from '@tauri-apps/api/core';
import type { MonitorInfo, WindowInfo } from '../types/screenshot';

export async function captureFullscreen(): Promise<Uint8Array> {
  return await invoke<number[]>('capture_fullscreen')
    .then(arr => new Uint8Array(arr));
}

export async function captureRegion(
  x: number, y: number, width: number, height: number
): Promise<Uint8Array> {
  return await invoke<number[]>('capture_region', { x, y, width, height })
    .then(arr => new Uint8Array(arr));
}

export async function captureWindow(windowId: number): Promise<Uint8Array> {
  return await invoke<number[]>('capture_window', { windowId })
    .then(arr => new Uint8Array(arr));
}

export async function getWindows(): Promise<WindowInfo[]> {
  return await invoke('get_windows');
}

export async function getMonitors(): Promise<MonitorInfo[]> {
  return await invoke('get_monitors');
}

export function bytesToImageUrl(bytes: Uint8Array): string {
  const blob = new Blob([bytes], { type: 'image/png' });
  return URL.createObjectURL(blob);
}
```

### 2.4 Screenshot Hook

**src/hooks/use-screenshot.ts:**
```typescript
import { useState, useCallback } from 'react';
import * as api from '../utils/screenshot-api';
import type { WindowInfo } from '../types/screenshot';

export function useScreenshot() {
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [imageBytes, setImageBytes] = useState<Uint8Array | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const captureFullscreen = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const bytes = await api.captureFullscreen();
      setImageBytes(bytes);
      setImageUrl(api.bytesToImageUrl(bytes));
    } catch (e) {
      setError(String(e));
    } finally {
      setLoading(false);
    }
  }, []);

  const captureWindow = useCallback(async (windowId: number) => {
    setLoading(true);
    setError(null);
    try {
      const bytes = await api.captureWindow(windowId);
      setImageBytes(bytes);
      setImageUrl(api.bytesToImageUrl(bytes));
    } catch (e) {
      setError(String(e));
    } finally {
      setLoading(false);
    }
  }, []);

  const clearImage = useCallback(() => {
    if (imageUrl) URL.revokeObjectURL(imageUrl);
    setImageUrl(null);
    setImageBytes(null);
  }, [imageUrl]);

  return {
    imageUrl,
    imageBytes,
    loading,
    error,
    captureFullscreen,
    captureWindow,
    clearImage,
  };
}
```

---

## macOS Permissions Handling

**Important**: macOS requires Screen Recording permission.

**src-tauri/src/permissions.rs:**
```rust
#[cfg(target_os = "macos")]
#[tauri::command]
pub fn check_screen_permission() -> bool {
    // xcap internally handles permission check
    // Returns true if permission granted
    xcap::Monitor::all().is_ok()
}

#[cfg(not(target_os = "macos"))]
#[tauri::command]
pub fn check_screen_permission() -> bool {
    true // Other platforms don't need explicit permission
}
```

**User flow**: On first capture attempt, macOS shows permission dialog. If denied, show error message guiding user to System Preferences → Privacy → Screen Recording.

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src-tauri/src/screenshot.rs` | Create |
| `src-tauri/src/permissions.rs` | Create |
| `src-tauri/src/main.rs` | Modify |
| `src/types/screenshot.ts` | Create |
| `src/utils/screenshot-api.ts` | Create |
| `src/hooks/use-screenshot.ts` | Create |

---

## Verification

```typescript
// In App.tsx for testing
import { useScreenshot } from './hooks/use-screenshot';

function App() {
  const { imageUrl, loading, error, captureFullscreen } = useScreenshot();

  return (
    <div>
      <button onClick={captureFullscreen} disabled={loading}>
        {loading ? 'Capturing...' : 'Capture Screen'}
      </button>
      {error && <p className="text-red-500">{error}</p>}
      {imageUrl && <img src={imageUrl} alt="Screenshot" />}
    </div>
  );
}
```

---

## Success Criteria

- [x] `capture_fullscreen` returns PNG bytes
- [x] `get_windows` returns window list with titles
- [x] `capture_window` captures specific window
- [x] Binary data transfers to frontend correctly
- [x] Image displays in React app
- [x] macOS permission prompt appears on first use

**Review Report**: [code-reviewer-251227-0345-phase02-screenshot-capture.md](../reports/code-reviewer-251227-0345-phase02-screenshot-capture.md)

---

## Platform Notes

| Platform | Notes |
|----------|-------|
| macOS | Screen Recording permission required |
| Windows | Works without special permissions |
| Linux X11 | Works out of box |
| Linux Wayland | May require portal, test carefully |

---

## Next Phase

[Phase 03: Canvas Editor Foundation](./phase-03-canvas-editor.md)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-04-annotation-tools.md">
# Phase 04: Annotation Tools

**Status**: completed | **Effort**: 6h | **Priority**: P1 | **Review**: code-reviewer-251227-0516

## Objective

Implement full annotation toolkit: shapes (rect, ellipse, line, arrow), text with fonts, numbered annotations, spotlight/dimming effect, and Transformer for move/resize/rotate.

---

## Tasks

### 4.1 Annotation Types & Store

**src/types/annotations.ts:**
```typescript
export type AnnotationType =
  | 'rectangle'
  | 'ellipse'
  | 'line'
  | 'arrow'
  | 'text'
  | 'number'
  | 'spotlight';

export interface BaseAnnotation {
  id: string;
  type: AnnotationType;
  x: number;
  y: number;
  rotation: number;
  draggable: boolean;
}

export interface RectAnnotation extends BaseAnnotation {
  type: 'rectangle';
  width: number;
  height: number;
  fill: string;
  stroke: string;
  strokeWidth: number;
}

export interface EllipseAnnotation extends BaseAnnotation {
  type: 'ellipse';
  radiusX: number;
  radiusY: number;
  fill: string;
  stroke: string;
  strokeWidth: number;
}

export interface LineAnnotation extends BaseAnnotation {
  type: 'line' | 'arrow';
  points: number[]; // [x1, y1, x2, y2]
  stroke: string;
  strokeWidth: number;
  pointerLength?: number; // for arrow
  pointerWidth?: number;
}

export interface TextAnnotation extends BaseAnnotation {
  type: 'text';
  text: string;
  fontSize: number;
  fontFamily: string;
  fill: string;
}

export interface NumberAnnotation extends BaseAnnotation {
  type: 'number';
  number: number;
  radius: number;
  fill: string;
  textColor: string;
  fontSize: number;
}

export interface SpotlightAnnotation extends BaseAnnotation {
  type: 'spotlight';
  width: number;
  height: number;
  shape: 'rectangle' | 'ellipse';
}

export type Annotation =
  | RectAnnotation
  | EllipseAnnotation
  | LineAnnotation
  | TextAnnotation
  | NumberAnnotation
  | SpotlightAnnotation;
```

**src/stores/annotation-store.ts:**
```typescript
import { create } from 'zustand';
import type { Annotation, AnnotationType } from '../types/annotations';
import { nanoid } from 'nanoid';

interface AnnotationState {
  annotations: Annotation[];
  selectedId: string | null;
  currentTool: AnnotationType | 'select' | null;
  numberCounter: number;

  // Tool settings
  strokeColor: string;
  fillColor: string;
  strokeWidth: number;
  fontSize: number;
  fontFamily: string;

  // Actions
  addAnnotation: (annotation: Omit<Annotation, 'id'>) => string;
  updateAnnotation: (id: string, updates: Partial<Annotation>) => void;
  deleteAnnotation: (id: string) => void;
  setSelected: (id: string | null) => void;
  setTool: (tool: AnnotationType | 'select' | null) => void;
  incrementNumber: () => number;

  // Settings
  setStrokeColor: (color: string) => void;
  setFillColor: (color: string) => void;
  setStrokeWidth: (width: number) => void;
  setFontSize: (size: number) => void;
  setFontFamily: (family: string) => void;

  clearAnnotations: () => void;
}

export const useAnnotationStore = create<AnnotationState>((set, get) => ({
  annotations: [],
  selectedId: null,
  currentTool: 'select',
  numberCounter: 0,

  strokeColor: '#ff0000',
  fillColor: 'rgba(255,0,0,0.3)',
  strokeWidth: 2,
  fontSize: 16,
  fontFamily: 'Arial',

  addAnnotation: (annotation) => {
    const id = nanoid();
    set(state => ({
      annotations: [...state.annotations, { ...annotation, id } as Annotation]
    }));
    return id;
  },

  updateAnnotation: (id, updates) => {
    set(state => ({
      annotations: state.annotations.map(a =>
        a.id === id ? { ...a, ...updates } : a
      )
    }));
  },

  deleteAnnotation: (id) => {
    set(state => ({
      annotations: state.annotations.filter(a => a.id !== id),
      selectedId: state.selectedId === id ? null : state.selectedId
    }));
  },

  setSelected: (id) => set({ selectedId: id }),
  setTool: (tool) => set({ currentTool: tool, selectedId: null }),

  incrementNumber: () => {
    const next = get().numberCounter + 1;
    set({ numberCounter: next });
    return next;
  },

  setStrokeColor: (color) => set({ strokeColor: color }),
  setFillColor: (color) => set({ fillColor: color }),
  setStrokeWidth: (width) => set({ strokeWidth: width }),
  setFontSize: (size) => set({ fontSize: size }),
  setFontFamily: (family) => set({ fontFamily: family }),

  clearAnnotations: () => set({ annotations: [], numberCounter: 0, selectedId: null }),
}));
```

### 4.2 Shape Components

**src/components/canvas/annotations/rect-shape.tsx:**
```typescript
import { Rect } from 'react-konva';
import type { RectAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: RectAnnotation;
}

export function RectShape({ annotation }: Props) {
  const { updateAnnotation, setSelected, selectedId } = useAnnotationStore();

  return (
    <Rect
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      width={annotation.width}
      height={annotation.height}
      fill={annotation.fill}
      stroke={annotation.stroke}
      strokeWidth={annotation.strokeWidth}
      rotation={annotation.rotation}
      draggable={annotation.draggable}
      onClick={() => setSelected(annotation.id)}
      onTap={() => setSelected(annotation.id)}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
      onTransformEnd={(e) => {
        const node = e.target;
        updateAnnotation(annotation.id, {
          x: node.x(),
          y: node.y(),
          width: Math.max(5, node.width() * node.scaleX()),
          height: Math.max(5, node.height() * node.scaleY()),
          rotation: node.rotation(),
        });
        node.scaleX(1);
        node.scaleY(1);
      }}
    />
  );
}
```

**src/components/canvas/annotations/arrow-shape.tsx:**
```typescript
import { Arrow, Line } from 'react-konva';
import type { LineAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: LineAnnotation;
}

export function ArrowShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();
  const isArrow = annotation.type === 'arrow';

  const Component = isArrow ? Arrow : Line;

  return (
    <Component
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      points={annotation.points}
      stroke={annotation.stroke}
      strokeWidth={annotation.strokeWidth}
      pointerLength={isArrow ? annotation.pointerLength || 10 : undefined}
      pointerWidth={isArrow ? annotation.pointerWidth || 10 : undefined}
      draggable={annotation.draggable}
      onClick={() => setSelected(annotation.id)}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
    />
  );
}
```

**src/components/canvas/annotations/text-shape.tsx:**
```typescript
import { Text } from 'react-konva';
import type { TextAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: TextAnnotation;
}

export function TextShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();

  return (
    <Text
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      text={annotation.text}
      fontSize={annotation.fontSize}
      fontFamily={annotation.fontFamily}
      fill={annotation.fill}
      rotation={annotation.rotation}
      draggable={annotation.draggable}
      onClick={() => setSelected(annotation.id)}
      onDblClick={() => {
        // TODO: Inline text editing
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
      onTransformEnd={(e) => {
        const node = e.target;
        updateAnnotation(annotation.id, {
          x: node.x(),
          y: node.y(),
          fontSize: Math.max(8, annotation.fontSize * node.scaleY()),
          rotation: node.rotation(),
        });
        node.scaleX(1);
        node.scaleY(1);
      }}
    />
  );
}
```

**src/components/canvas/annotations/number-shape.tsx:**
```typescript
import { Circle, Text, Group } from 'react-konva';
import type { NumberAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: NumberAnnotation;
}

export function NumberShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();

  return (
    <Group
      x={annotation.x}
      y={annotation.y}
      draggable={annotation.draggable}
      onClick={() => setSelected(annotation.id)}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
    >
      <Circle
        radius={annotation.radius}
        fill={annotation.fill}
      />
      <Text
        text={String(annotation.number)}
        fontSize={annotation.fontSize}
        fill={annotation.textColor}
        x={-annotation.radius}
        y={-annotation.fontSize / 2}
        width={annotation.radius * 2}
        align="center"
      />
    </Group>
  );
}
```

### 4.3 Spotlight Effect

**src/components/canvas/annotations/spotlight-shape.tsx:**
```typescript
import { Group, Rect, Shape } from 'react-konva';
import type { SpotlightAnnotation } from '../../../types/annotations';
import { useCanvasStore } from '../../../stores/canvas-store';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: SpotlightAnnotation;
}

export function SpotlightShape({ annotation }: Props) {
  const { originalWidth, originalHeight } = useCanvasStore();
  const { updateAnnotation, setSelected } = useAnnotationStore();

  return (
    <Group>
      {/* Dimmed overlay with cutout */}
      <Shape
        sceneFunc={(ctx, shape) => {
          ctx.beginPath();
          // Full canvas
          ctx.rect(0, 0, originalWidth, originalHeight);
          // Cutout (spotlight area)
          if (annotation.shape === 'ellipse') {
            ctx.ellipse(
              annotation.x + annotation.width / 2,
              annotation.y + annotation.height / 2,
              annotation.width / 2,
              annotation.height / 2,
              0, 0, Math.PI * 2, true
            );
          } else {
            ctx.rect(annotation.x, annotation.y, annotation.width, annotation.height);
          }
          ctx.fillStrokeShape(shape);
        }}
        fill="rgba(0,0,0,0.5)"
        listening={false}
      />

      {/* Invisible draggable handle */}
      <Rect
        x={annotation.x}
        y={annotation.y}
        width={annotation.width}
        height={annotation.height}
        fill="transparent"
        stroke="white"
        strokeWidth={2}
        dash={[5, 5]}
        draggable
        onClick={() => setSelected(annotation.id)}
        onDragEnd={(e) => {
          updateAnnotation(annotation.id, {
            x: e.target.x(),
            y: e.target.y(),
          });
        }}
        onTransformEnd={(e) => {
          const node = e.target;
          updateAnnotation(annotation.id, {
            x: node.x(),
            y: node.y(),
            width: node.width() * node.scaleX(),
            height: node.height() * node.scaleY(),
          });
          node.scaleX(1);
          node.scaleY(1);
        }}
      />
    </Group>
  );
}
```

### 4.4 Annotation Layer with Transformer

**src/components/canvas/annotation-layer.tsx:**
```typescript
import { useRef, useEffect } from 'react';
import { Layer, Transformer } from 'react-konva';
import Konva from 'konva';
import { useAnnotationStore } from '../../stores/annotation-store';
import { RectShape } from './annotations/rect-shape';
import { ArrowShape } from './annotations/arrow-shape';
import { TextShape } from './annotations/text-shape';
import { NumberShape } from './annotations/number-shape';
import { SpotlightShape } from './annotations/spotlight-shape';
import { EllipseShape } from './annotations/ellipse-shape';

export function AnnotationLayer() {
  const transformerRef = useRef<Konva.Transformer>(null);
  const layerRef = useRef<Konva.Layer>(null);

  const { annotations, selectedId } = useAnnotationStore();

  // Attach transformer to selected shape
  useEffect(() => {
    if (!transformerRef.current || !layerRef.current) return;

    if (selectedId) {
      const node = layerRef.current.findOne(`#${selectedId}`);
      if (node) {
        transformerRef.current.nodes([node]);
        transformerRef.current.getLayer()?.batchDraw();
      }
    } else {
      transformerRef.current.nodes([]);
    }
  }, [selectedId]);

  const renderAnnotation = (annotation: Annotation) => {
    switch (annotation.type) {
      case 'rectangle':
        return <RectShape key={annotation.id} annotation={annotation} />;
      case 'ellipse':
        return <EllipseShape key={annotation.id} annotation={annotation} />;
      case 'line':
      case 'arrow':
        return <ArrowShape key={annotation.id} annotation={annotation} />;
      case 'text':
        return <TextShape key={annotation.id} annotation={annotation} />;
      case 'number':
        return <NumberShape key={annotation.id} annotation={annotation} />;
      case 'spotlight':
        return <SpotlightShape key={annotation.id} annotation={annotation} />;
      default:
        return null;
    }
  };

  return (
    <Layer ref={layerRef}>
      {annotations.map(renderAnnotation)}
      <Transformer
        ref={transformerRef}
        boundBoxFunc={(oldBox, newBox) => {
          // Minimum size constraint
          if (newBox.width < 10 || newBox.height < 10) {
            return oldBox;
          }
          return newBox;
        }}
      />
    </Layer>
  );
}
```

### 4.5 Drawing Handler (Create shapes on canvas)

**src/hooks/use-drawing.ts:**
```typescript
import { useState, useCallback } from 'react';
import Konva from 'konva';
import { useAnnotationStore } from '../stores/annotation-store';

export function useDrawing() {
  const [isDrawing, setIsDrawing] = useState(false);
  const [startPos, setStartPos] = useState({ x: 0, y: 0 });

  const {
    currentTool,
    strokeColor,
    fillColor,
    strokeWidth,
    fontSize,
    fontFamily,
    addAnnotation,
    incrementNumber,
  } = useAnnotationStore();

  const handleMouseDown = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    if (currentTool === 'select' || !currentTool) return;

    const stage = e.target.getStage();
    const pos = stage?.getPointerPosition();
    if (!pos) return;

    // Adjust for stage transform
    const transform = stage.getAbsoluteTransform().copy().invert();
    const realPos = transform.point(pos);

    setIsDrawing(true);
    setStartPos(realPos);

    // For click-to-place tools
    if (currentTool === 'text') {
      const text = prompt('Enter text:') || 'Text';
      addAnnotation({
        type: 'text',
        x: realPos.x,
        y: realPos.y,
        text,
        fontSize,
        fontFamily,
        fill: strokeColor,
        rotation: 0,
        draggable: true,
      });
      setIsDrawing(false);
    } else if (currentTool === 'number') {
      const num = incrementNumber();
      addAnnotation({
        type: 'number',
        x: realPos.x,
        y: realPos.y,
        number: num,
        radius: 15,
        fill: strokeColor,
        textColor: '#ffffff',
        fontSize: 14,
        rotation: 0,
        draggable: true,
      });
      setIsDrawing(false);
    }
  }, [currentTool, addAnnotation, strokeColor, fontSize, fontFamily, incrementNumber]);

  const handleMouseUp = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    if (!isDrawing || currentTool === 'select' || !currentTool) return;

    const stage = e.target.getStage();
    const pos = stage?.getPointerPosition();
    if (!pos) return;

    const transform = stage.getAbsoluteTransform().copy().invert();
    const endPos = transform.point(pos);

    const width = Math.abs(endPos.x - startPos.x);
    const height = Math.abs(endPos.y - startPos.y);
    const x = Math.min(startPos.x, endPos.x);
    const y = Math.min(startPos.y, endPos.y);

    if (width < 5 && height < 5) {
      setIsDrawing(false);
      return; // Too small, ignore
    }

    switch (currentTool) {
      case 'rectangle':
        addAnnotation({
          type: 'rectangle',
          x, y, width, height,
          fill: fillColor,
          stroke: strokeColor,
          strokeWidth,
          rotation: 0,
          draggable: true,
        });
        break;
      case 'ellipse':
        addAnnotation({
          type: 'ellipse',
          x: x + width / 2,
          y: y + height / 2,
          radiusX: width / 2,
          radiusY: height / 2,
          fill: fillColor,
          stroke: strokeColor,
          strokeWidth,
          rotation: 0,
          draggable: true,
        });
        break;
      case 'line':
      case 'arrow':
        addAnnotation({
          type: currentTool,
          x: 0,
          y: 0,
          points: [startPos.x, startPos.y, endPos.x, endPos.y],
          stroke: strokeColor,
          strokeWidth,
          pointerLength: 10,
          pointerWidth: 10,
          rotation: 0,
          draggable: true,
        });
        break;
      case 'spotlight':
        addAnnotation({
          type: 'spotlight',
          x, y, width, height,
          shape: 'rectangle',
          rotation: 0,
          draggable: true,
        });
        break;
    }

    setIsDrawing(false);
  }, [isDrawing, currentTool, startPos, addAnnotation, fillColor, strokeColor, strokeWidth]);

  return {
    isDrawing,
    handleMouseDown,
    handleMouseUp,
  };
}
```

### 4.6 Toolbar Tools

**src/components/toolbar/tool-buttons.tsx:**
```typescript
import { useAnnotationStore } from '../../stores/annotation-store';
import type { AnnotationType } from '../../types/annotations';

const TOOLS: { type: AnnotationType | 'select'; icon: string; label: string }[] = [
  { type: 'select', icon: '↖', label: 'Select' },
  { type: 'rectangle', icon: '▢', label: 'Rectangle' },
  { type: 'ellipse', icon: '○', label: 'Ellipse' },
  { type: 'line', icon: '/', label: 'Line' },
  { type: 'arrow', icon: '→', label: 'Arrow' },
  { type: 'text', icon: 'T', label: 'Text' },
  { type: 'number', icon: '#', label: 'Number' },
  { type: 'spotlight', icon: '◐', label: 'Spotlight' },
];

export function ToolButtons() {
  const { currentTool, setTool } = useAnnotationStore();

  return (
    <div className="flex gap-1">
      {TOOLS.map(tool => (
        <button
          key={tool.type}
          onClick={() => setTool(tool.type)}
          className={`w-8 h-8 flex items-center justify-center rounded ${
            currentTool === tool.type
              ? 'bg-blue-500 text-white'
              : 'hover:bg-gray-100'
          }`}
          title={tool.label}
        >
          {tool.icon}
        </button>
      ))}
    </div>
  );
}
```

---

## Install nanoid

```bash
npm install nanoid
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/types/annotations.ts` | Create |
| `src/stores/annotation-store.ts` | Create |
| `src/components/canvas/annotations/*.tsx` | Create (6 files) |
| `src/components/canvas/annotation-layer.tsx` | Create |
| `src/components/toolbar/tool-buttons.tsx` | Create |
| `src/hooks/use-drawing.ts` | Create |
| `src/components/canvas/canvas-editor.tsx` | Modify |

---

## Success Criteria

- [x] Rectangle tool: draw, move, resize, rotate
- [x] Ellipse tool: draw, move, resize
- [x] Arrow tool: draw, move endpoints
- [x] Text tool: click to add, edit text (using prompt - UX improvement needed Phase 05)
- [x] Number tool: auto-increment counter
- [x] Spotlight: dims outside, movable highlight
- [x] Transformer handles on selected shapes
- [x] Delete key removes selected shape

---

## Known Limitations

- Arrow + Transformer has issues (Konva bug) → use bounding box drag instead
- Stars not included (not in requirements)
- Inline text editing requires custom implementation

---

## Code Review Summary

**Date:** 2025-12-27 05:16
**Report:** plans/reports/code-reviewer-251227-0516-phase04-annotation-tools.md
**Grade:** B+ (85/100) → **A- (92/100)** after fixes

### Key Findings
- ✅ No critical security issues
- ✅ Type safety excellent (strict mode passes)
- ✅ Clean architecture, KISS/DRY principles followed
- ✅ Console logging → `src/utils/logger.ts` created
- ✅ Text input sanitization → `src/utils/sanitize.ts` created
- ✅ DRY violations → `src/hooks/use-transform-handler.ts` created
- ✅ Magic numbers → `src/constants/annotations.ts` created
- ✅ Transformer cleanup → useEffect cleanup added
- ✅ Exhaustiveness check → added to renderAnnotation
- ⚠️ UX: Browser prompt() for text input (defer to Phase 05)

### Tech Debt for Phase 05
1. Replace prompt() with proper text input dialog/modal

### Status
**Phase 04: COMPLETE** - All success criteria met. All code review issues resolved except text dialog UX.

---

## Next Phase

[Phase 05: Beautification Features](./phase-05-beautification.md)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-05-beautification.md">
# Phase 05: Beautification Features

**Status**: ✓ complete | **Effort**: 4h | **Priority**: P2 | **Review**: A- (92/100)

## Objective

Implement gradient background library (24+ presets like Winshot), non-destructive cropping with aspect ratio presets, and real-time preview.

---

## Tasks

### 5.1 Gradient Presets Library

**src/data/gradients.ts:**
```typescript
export interface GradientPreset {
  id: string;
  name: string;
  colors: string[];
  direction: 'linear' | 'radial';
  angle?: number; // for linear gradients
}

export const GRADIENT_PRESETS: GradientPreset[] = [
  // Blues
  { id: 'ocean', name: 'Ocean', colors: ['#667eea', '#764ba2'], direction: 'linear', angle: 135 },
  { id: 'royal', name: 'Royal', colors: ['#141E30', '#243B55'], direction: 'linear', angle: 180 },
  { id: 'azure', name: 'Azure', colors: ['#0099F7', '#F11712'], direction: 'linear', angle: 135 },

  // Purples
  { id: 'velvet', name: 'Velvet', colors: ['#DA22FF', '#9733EE'], direction: 'linear', angle: 135 },
  { id: 'midnight', name: 'Midnight', colors: ['#232526', '#414345'], direction: 'linear', angle: 180 },
  { id: 'cosmic', name: 'Cosmic', colors: ['#ff00cc', '#333399'], direction: 'linear', angle: 135 },

  // Warm
  { id: 'sunset', name: 'Sunset', colors: ['#f12711', '#f5af19'], direction: 'linear', angle: 135 },
  { id: 'sunrise', name: 'Sunrise', colors: ['#FF512F', '#F09819'], direction: 'linear', angle: 90 },
  { id: 'peach', name: 'Peach', colors: ['#ed4264', '#ffedbc'], direction: 'linear', angle: 135 },

  // Greens
  { id: 'forest', name: 'Forest', colors: ['#134E5E', '#71B280'], direction: 'linear', angle: 135 },
  { id: 'mint', name: 'Mint', colors: ['#00b09b', '#96c93d'], direction: 'linear', angle: 135 },
  { id: 'emerald', name: 'Emerald', colors: ['#348F50', '#56B4D3'], direction: 'linear', angle: 135 },

  // Neutrals
  { id: 'slate', name: 'Slate', colors: ['#2C3E50', '#4CA1AF'], direction: 'linear', angle: 135 },
  { id: 'charcoal', name: 'Charcoal', colors: ['#373B44', '#4286f4'], direction: 'linear', angle: 135 },
  { id: 'silver', name: 'Silver', colors: ['#bdc3c7', '#2c3e50'], direction: 'linear', angle: 180 },

  // Vibrant
  { id: 'rainbow', name: 'Rainbow', colors: ['#f12711', '#f5af19', '#56B4D3'], direction: 'linear', angle: 90 },
  { id: 'neon', name: 'Neon', colors: ['#12c2e9', '#c471ed', '#f64f59'], direction: 'linear', angle: 90 },
  { id: 'electric', name: 'Electric', colors: ['#4776E6', '#8E54E9'], direction: 'linear', angle: 135 },

  // Soft
  { id: 'blush', name: 'Blush', colors: ['#ffecd2', '#fcb69f'], direction: 'linear', angle: 135 },
  { id: 'lavender', name: 'Lavender', colors: ['#e0c3fc', '#8ec5fc'], direction: 'linear', angle: 135 },
  { id: 'cream', name: 'Cream', colors: ['#fdfbfb', '#ebedee'], direction: 'linear', angle: 180 },

  // Dark
  { id: 'obsidian', name: 'Obsidian', colors: ['#000000', '#434343'], direction: 'linear', angle: 180 },
  { id: 'void', name: 'Void', colors: ['#0f0c29', '#302b63', '#24243e'], direction: 'linear', angle: 135 },
  { id: 'carbon', name: 'Carbon', colors: ['#1c1c1c', '#383838'], direction: 'linear', angle: 180 },
];

export const SOLID_COLORS = [
  { id: 'white', name: 'White', color: '#ffffff' },
  { id: 'black', name: 'Black', color: '#000000' },
  { id: 'gray', name: 'Gray', color: '#6b7280' },
  { id: 'red', name: 'Red', color: '#ef4444' },
  { id: 'blue', name: 'Blue', color: '#3b82f6' },
  { id: 'green', name: 'Green', color: '#22c55e' },
  { id: 'transparent', name: 'Transparent', color: 'transparent' },
];
```

### 5.2 Background Store

**src/stores/background-store.ts:**
```typescript
import { create } from 'zustand';
import type { GradientPreset } from '../data/gradients';

interface BackgroundState {
  type: 'gradient' | 'solid' | 'transparent';
  gradient: GradientPreset | null;
  solidColor: string;
  padding: number; // px around image

  setGradient: (gradient: GradientPreset) => void;
  setSolidColor: (color: string) => void;
  setTransparent: () => void;
  setPadding: (padding: number) => void;
}

export const useBackgroundStore = create<BackgroundState>((set) => ({
  type: 'gradient',
  gradient: null,
  solidColor: '#ffffff',
  padding: 40,

  setGradient: (gradient) => set({ type: 'gradient', gradient }),
  setSolidColor: (color) => set({ type: 'solid', solidColor: color }),
  setTransparent: () => set({ type: 'transparent' }),
  setPadding: (padding) => set({ padding: Math.max(0, Math.min(200, padding)) }),
}));
```

### 5.3 Gradient Background Component

**src/components/canvas/background-layer.tsx:**
```typescript
import { Rect, Shape } from 'react-konva';
import { useBackgroundStore } from '../../stores/background-store';
import { useCanvasStore } from '../../stores/canvas-store';

export function BackgroundLayer() {
  const { type, gradient, solidColor, padding } = useBackgroundStore();
  const { originalWidth, originalHeight } = useCanvasStore();

  const totalWidth = originalWidth + padding * 2;
  const totalHeight = originalHeight + padding * 2;

  if (type === 'transparent') {
    // Checkerboard pattern for transparency
    return (
      <Shape
        sceneFunc={(ctx, shape) => {
          const size = 10;
          for (let x = 0; x < totalWidth; x += size) {
            for (let y = 0; y < totalHeight; y += size) {
              ctx.fillStyle = (Math.floor(x / size) + Math.floor(y / size)) % 2 === 0
                ? '#ccc'
                : '#fff';
              ctx.fillRect(x, y, size, size);
            }
          }
        }}
        listening={false}
      />
    );
  }

  if (type === 'solid') {
    return (
      <Rect
        x={0}
        y={0}
        width={totalWidth}
        height={totalHeight}
        fill={solidColor}
        listening={false}
      />
    );
  }

  // Gradient background
  if (!gradient) {
    return (
      <Rect
        x={0}
        y={0}
        width={totalWidth}
        height={totalHeight}
        fill="#ffffff"
        listening={false}
      />
    );
  }

  return (
    <Shape
      sceneFunc={(ctx, shape) => {
        let grd: CanvasGradient;

        if (gradient.direction === 'radial') {
          grd = ctx.createRadialGradient(
            totalWidth / 2, totalHeight / 2, 0,
            totalWidth / 2, totalHeight / 2, Math.max(totalWidth, totalHeight) / 2
          );
        } else {
          // Linear gradient based on angle
          const angle = (gradient.angle || 0) * Math.PI / 180;
          const x1 = totalWidth / 2 - Math.cos(angle) * totalWidth / 2;
          const y1 = totalHeight / 2 - Math.sin(angle) * totalHeight / 2;
          const x2 = totalWidth / 2 + Math.cos(angle) * totalWidth / 2;
          const y2 = totalHeight / 2 + Math.sin(angle) * totalHeight / 2;
          grd = ctx.createLinearGradient(x1, y1, x2, y2);
        }

        gradient.colors.forEach((color, i) => {
          grd.addColorStop(i / (gradient.colors.length - 1), color);
        });

        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, totalWidth, totalHeight);
      }}
      listening={false}
    />
  );
}
```

### 5.4 Aspect Ratio Cropping

**src/data/aspect-ratios.ts:**
```typescript
export interface AspectRatio {
  id: string;
  name: string;
  ratio: number | null; // null = freeform
}

export const ASPECT_RATIOS: AspectRatio[] = [
  { id: 'free', name: 'Free', ratio: null },
  { id: '1:1', name: '1:1 Square', ratio: 1 },
  { id: '4:3', name: '4:3', ratio: 4 / 3 },
  { id: '3:2', name: '3:2', ratio: 3 / 2 },
  { id: '16:9', name: '16:9 Widescreen', ratio: 16 / 9 },
  { id: '21:9', name: '21:9 Ultrawide', ratio: 21 / 9 },
  { id: '9:16', name: '9:16 Portrait', ratio: 9 / 16 },
  { id: '3:4', name: '3:4 Portrait', ratio: 3 / 4 },
];
```

**src/stores/crop-store.ts:**
```typescript
import { create } from 'zustand';

interface CropState {
  isCropping: boolean;
  cropRect: { x: number; y: number; width: number; height: number } | null;
  aspectRatio: number | null;

  startCrop: (ratio?: number | null) => void;
  setCropRect: (rect: { x: number; y: number; width: number; height: number }) => void;
  applyCrop: () => void;
  cancelCrop: () => void;
  setAspectRatio: (ratio: number | null) => void;
}

export const useCropStore = create<CropState>((set, get) => ({
  isCropping: false,
  cropRect: null,
  aspectRatio: null,

  startCrop: (ratio = null) => set({
    isCropping: true,
    aspectRatio: ratio,
    cropRect: null
  }),

  setCropRect: (rect) => set({ cropRect: rect }),

  applyCrop: () => {
    // Crop will be applied during export (non-destructive)
    set({ isCropping: false });
  },

  cancelCrop: () => set({
    isCropping: false,
    cropRect: null
  }),

  setAspectRatio: (ratio) => set({ aspectRatio: ratio }),
}));
```

### 5.5 Crop Overlay Component

**src/components/canvas/crop-overlay.tsx:**
```typescript
import { Rect, Transformer, Group } from 'react-konva';
import { useRef, useEffect } from 'react';
import Konva from 'konva';
import { useCropStore } from '../../stores/crop-store';
import { useCanvasStore } from '../../stores/canvas-store';

export function CropOverlay() {
  const rectRef = useRef<Konva.Rect>(null);
  const trRef = useRef<Konva.Transformer>(null);

  const { isCropping, cropRect, aspectRatio, setCropRect } = useCropStore();
  const { originalWidth, originalHeight } = useCanvasStore();

  useEffect(() => {
    if (isCropping && trRef.current && rectRef.current) {
      trRef.current.nodes([rectRef.current]);
      trRef.current.getLayer()?.batchDraw();
    }
  }, [isCropping]);

  if (!isCropping) return null;

  const defaultRect = cropRect || {
    x: originalWidth * 0.1,
    y: originalHeight * 0.1,
    width: originalWidth * 0.8,
    height: originalHeight * 0.8,
  };

  return (
    <Group>
      {/* Dimmed areas outside crop */}
      <Rect
        x={0}
        y={0}
        width={originalWidth}
        height={originalHeight}
        fill="rgba(0,0,0,0.5)"
        listening={false}
      />

      {/* Clear crop area */}
      <Rect
        ref={rectRef}
        x={defaultRect.x}
        y={defaultRect.y}
        width={defaultRect.width}
        height={defaultRect.height}
        fill="transparent"
        stroke="white"
        strokeWidth={2}
        dash={[10, 5]}
        draggable
        onDragEnd={(e) => {
          setCropRect({
            x: e.target.x(),
            y: e.target.y(),
            width: e.target.width(),
            height: e.target.height(),
          });
        }}
        onTransformEnd={(e) => {
          const node = e.target;
          setCropRect({
            x: node.x(),
            y: node.y(),
            width: node.width() * node.scaleX(),
            height: node.height() * node.scaleY(),
          });
          node.scaleX(1);
          node.scaleY(1);
        }}
      />

      <Transformer
        ref={trRef}
        keepRatio={aspectRatio !== null}
        boundBoxFunc={(oldBox, newBox) => {
          // Enforce aspect ratio if set
          if (aspectRatio !== null) {
            const targetRatio = aspectRatio;
            if (newBox.width / newBox.height > targetRatio) {
              newBox.height = newBox.width / targetRatio;
            } else {
              newBox.width = newBox.height * targetRatio;
            }
          }
          // Minimum size
          if (newBox.width < 50 || newBox.height < 50) {
            return oldBox;
          }
          return newBox;
        }}
      />
    </Group>
  );
}
```

### 5.6 Background & Crop Panel UI

**src/components/sidebar/background-panel.tsx:**
```typescript
import { GRADIENT_PRESETS, SOLID_COLORS } from '../../data/gradients';
import { useBackgroundStore } from '../../stores/background-store';

export function BackgroundPanel() {
  const { type, gradient, padding, setGradient, setSolidColor, setTransparent, setPadding } = useBackgroundStore();

  return (
    <div className="p-4 border-b">
      <h3 className="font-medium mb-3">Background</h3>

      {/* Gradient presets */}
      <div className="grid grid-cols-6 gap-2 mb-4">
        {GRADIENT_PRESETS.slice(0, 12).map(preset => (
          <button
            key={preset.id}
            onClick={() => setGradient(preset)}
            className={`w-8 h-8 rounded ${
              gradient?.id === preset.id ? 'ring-2 ring-blue-500' : ''
            }`}
            style={{
              background: `linear-gradient(${preset.angle || 135}deg, ${preset.colors.join(', ')})`,
            }}
            title={preset.name}
          />
        ))}
      </div>

      {/* Solid colors */}
      <div className="flex gap-2 mb-4">
        {SOLID_COLORS.map(c => (
          <button
            key={c.id}
            onClick={() => setSolidColor(c.color)}
            className={`w-6 h-6 rounded border ${
              type === 'solid' && c.color === useBackgroundStore.getState().solidColor
                ? 'ring-2 ring-blue-500' : ''
            }`}
            style={{ background: c.color === 'transparent' ? 'repeating-linear-gradient(45deg, #ccc, #ccc 5px, #fff 5px, #fff 10px)' : c.color }}
            title={c.name}
          />
        ))}
        <button
          onClick={setTransparent}
          className={`w-6 h-6 rounded border ${type === 'transparent' ? 'ring-2 ring-blue-500' : ''}`}
          style={{ background: 'repeating-linear-gradient(45deg, #ccc, #ccc 5px, #fff 5px, #fff 10px)' }}
          title="Transparent"
        />
      </div>

      {/* Padding slider */}
      <div>
        <label className="text-sm text-gray-600">Padding: {padding}px</label>
        <input
          type="range"
          min="0"
          max="200"
          value={padding}
          onChange={(e) => setPadding(Number(e.target.value))}
          className="w-full"
        />
      </div>
    </div>
  );
}
```

**src/components/sidebar/crop-panel.tsx:**
```typescript
import { ASPECT_RATIOS } from '../../data/aspect-ratios';
import { useCropStore } from '../../stores/crop-store';

export function CropPanel() {
  const { isCropping, aspectRatio, startCrop, applyCrop, cancelCrop, setAspectRatio } = useCropStore();

  return (
    <div className="p-4 border-b">
      <h3 className="font-medium mb-3">Crop</h3>

      {!isCropping ? (
        <button
          onClick={() => startCrop()}
          className="w-full py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          Start Crop
        </button>
      ) : (
        <>
          {/* Aspect ratio buttons */}
          <div className="grid grid-cols-2 gap-2 mb-4">
            {ASPECT_RATIOS.map(ar => (
              <button
                key={ar.id}
                onClick={() => setAspectRatio(ar.ratio)}
                className={`px-2 py-1 text-sm rounded ${
                  aspectRatio === ar.ratio
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-100 hover:bg-gray-200'
                }`}
              >
                {ar.name}
              </button>
            ))}
          </div>

          <div className="flex gap-2">
            <button
              onClick={applyCrop}
              className="flex-1 py-2 bg-green-500 text-white rounded hover:bg-green-600"
            >
              Apply
            </button>
            <button
              onClick={cancelCrop}
              className="flex-1 py-2 bg-gray-300 rounded hover:bg-gray-400"
            >
              Cancel
            </button>
          </div>
        </>
      )}
    </div>
  );
}
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/data/gradients.ts` | Create |
| `src/data/aspect-ratios.ts` | Create |
| `src/stores/background-store.ts` | Create |
| `src/stores/crop-store.ts` | Create |
| `src/components/canvas/background-layer.tsx` | Create |
| `src/components/canvas/crop-overlay.tsx` | Create |
| `src/components/sidebar/background-panel.tsx` | Create |
| `src/components/sidebar/crop-panel.tsx` | Create |

---

## Success Criteria

- [x] 24+ gradient presets available
- [x] Solid color backgrounds work
- [x] Transparent background (checkerboard) works
- [x] Padding slider adjusts space around image
- [x] Crop mode with aspect ratio lock
- [x] Freeform crop available
- [x] Non-destructive (original preserved until export)
- [x] Real-time preview of all changes

## Code Review Summary

**Grade:** A- (92/100)
**Review Report:** [plans/reports/code-reviewer-251229-1140-phase05-beautification.md](../reports/code-reviewer-251229-1140-phase05-beautification.md)

**Highlights:**
- Zero security vulnerabilities
- Zero critical issues
- TypeScript strict mode compliance
- Proper React/Zustand patterns
- Non-destructive architecture

**Optional Improvements:**
- Memoize BackgroundLayer for performance
- Optimize checkerboard rendering with pattern fill
- Add JSDoc to exported components
- Export padding constants for reuse

---

## Next Phase

[Phase 06: Export System](./phase-06-export-system.md)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-06-export-system.md">
# Phase 06: Export System

**Status**: ✅ completed | **Effort**: 3h (actual: 4h) | **Priority**: P2
**Completed**: 2025-12-29 | **Code Review**: APPROVED (Grade A+ - 98/100, optimized)

## Objective

Implement PNG/JPEG export with quality control, high-DPI/Retina support (pixelRatio), quick-save with auto-naming, and clipboard copy option.

---

## Tasks

### 6.1 Export Store

**src/stores/export-store.ts:**
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

type ExportFormat = 'png' | 'jpeg';

interface ExportState {
  format: ExportFormat;
  quality: number; // 0.1 - 1.0 for JPEG
  pixelRatio: number; // 1, 2, 3 for resolution
  autoName: boolean;
  lastSavePath: string | null;

  setFormat: (format: ExportFormat) => void;
  setQuality: (quality: number) => void;
  setPixelRatio: (ratio: number) => void;
  setAutoName: (auto: boolean) => void;
  setLastSavePath: (path: string) => void;
}

export const useExportStore = create<ExportState>()(
  persist(
    (set) => ({
      format: 'png',
      quality: 0.9,
      pixelRatio: 1,
      autoName: true,
      lastSavePath: null,

      setFormat: (format) => set({ format }),
      setQuality: (quality) => set({ quality: Math.max(0.1, Math.min(1, quality)) }),
      setPixelRatio: (ratio) => set({ pixelRatio: Math.max(1, Math.min(3, ratio)) }),
      setAutoName: (auto) => set({ autoName: auto }),
      setLastSavePath: (path) => set({ lastSavePath: path }),
    }),
    {
      name: 'beautyshot-export-settings',
    }
  )
);
```

### 6.2 Export Utility Functions

**src/utils/export-utils.ts:**
```typescript
import Konva from 'konva';

export interface ExportOptions {
  format: 'png' | 'jpeg';
  quality: number;
  pixelRatio: number;
  cropRect?: { x: number; y: number; width: number; height: number } | null;
}

export function generateFilename(format: 'png' | 'jpeg'): string {
  const now = new Date();
  const timestamp = now.toISOString()
    .replace(/[-:]/g, '')
    .replace('T', '_')
    .slice(0, 15);
  return `beautyshot_${timestamp}.${format}`;
}

export function stageToDataURL(
  stage: Konva.Stage,
  options: ExportOptions
): string {
  const { format, quality, pixelRatio, cropRect } = options;

  const exportConfig: Konva.Stage.ToDataURLConfig = {
    mimeType: format === 'jpeg' ? 'image/jpeg' : 'image/png',
    quality: format === 'jpeg' ? quality : undefined,
    pixelRatio,
  };

  // If cropping, export specific region
  if (cropRect) {
    exportConfig.x = cropRect.x;
    exportConfig.y = cropRect.y;
    exportConfig.width = cropRect.width;
    exportConfig.height = cropRect.height;
  }

  return stage.toDataURL(exportConfig);
}

export function stageToBlob(
  stage: Konva.Stage,
  options: ExportOptions
): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const { format, quality, pixelRatio, cropRect } = options;

    const exportConfig: Konva.Stage.ToDataURLConfig = {
      mimeType: format === 'jpeg' ? 'image/jpeg' : 'image/png',
      quality: format === 'jpeg' ? quality : undefined,
      pixelRatio,
    };

    if (cropRect) {
      exportConfig.x = cropRect.x;
      exportConfig.y = cropRect.y;
      exportConfig.width = cropRect.width;
      exportConfig.height = cropRect.height;
    }

    stage.toBlob({
      ...exportConfig,
      callback: (blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('Failed to create blob'));
        }
      },
    });
  });
}

export function dataURLToBytes(dataURL: string): Uint8Array {
  const base64 = dataURL.split(',')[1];
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
```

### 6.3 Rust Save Command

**src-tauri/src/file_ops.rs:**
```rust
use std::path::PathBuf;
use tauri::command;

#[tauri::command]
pub async fn save_file(
    path: String,
    data: Vec<u8>,
) -> Result<String, String> {
    let path = PathBuf::from(&path);

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create directory: {}", e))?;
    }

    std::fs::write(&path, data)
        .map_err(|e| format!("Failed to save file: {}", e))?;

    Ok(path.to_string_lossy().to_string())
}

#[tauri::command]
pub fn get_pictures_dir() -> Result<String, String> {
    dirs::picture_dir()
        .map(|p| p.join("BeautyShot").to_string_lossy().to_string())
        .ok_or_else(|| "Could not find Pictures directory".to_string())
}

#[tauri::command]
pub fn get_desktop_dir() -> Result<String, String> {
    dirs::desktop_dir()
        .map(|p| p.to_string_lossy().to_string())
        .ok_or_else(|| "Could not find Desktop directory".to_string())
}
```

Add to `src-tauri/Cargo.toml`:
```toml
dirs = "5.0"
```

### 6.4 TypeScript Save API

**src/utils/file-api.ts:**
```typescript
import { invoke } from '@tauri-apps/api/core';
import { save } from '@tauri-apps/plugin-dialog';

export async function saveFile(path: string, data: Uint8Array): Promise<string> {
  return await invoke('save_file', {
    path,
    data: Array.from(data)
  });
}

export async function getPicturesDir(): Promise<string> {
  return await invoke('get_pictures_dir');
}

export async function getDesktopDir(): Promise<string> {
  return await invoke('get_desktop_dir');
}

export async function showSaveDialog(
  defaultName: string,
  format: 'png' | 'jpeg'
): Promise<string | null> {
  const filters = format === 'png'
    ? [{ name: 'PNG Image', extensions: ['png'] }]
    : [{ name: 'JPEG Image', extensions: ['jpg', 'jpeg'] }];

  const path = await save({
    defaultPath: defaultName,
    filters,
  });

  return path;
}
```

### 6.5 Export Hook

**src/hooks/use-export.ts:**
```typescript
import { useRef, useCallback } from 'react';
import Konva from 'konva';
import { useExportStore } from '../stores/export-store';
import { useCropStore } from '../stores/crop-store';
import {
  stageToDataURL,
  dataURLToBytes,
  generateFilename
} from '../utils/export-utils';
import { saveFile, getPicturesDir, showSaveDialog } from '../utils/file-api';
import { sendNotification } from '@tauri-apps/plugin-notification';

export function useExport(stageRef: React.RefObject<Konva.Stage>) {
  const { format, quality, pixelRatio, autoName, setLastSavePath } = useExportStore();
  const { cropRect } = useCropStore();

  const exportToDataURL = useCallback(() => {
    if (!stageRef.current) return null;

    return stageToDataURL(stageRef.current, {
      format,
      quality,
      pixelRatio,
      cropRect,
    });
  }, [stageRef, format, quality, pixelRatio, cropRect]);

  const copyToClipboard = useCallback(async () => {
    const dataURL = exportToDataURL();
    if (!dataURL) return false;

    try {
      const blob = await fetch(dataURL).then(r => r.blob());
      await navigator.clipboard.write([
        new ClipboardItem({ [blob.type]: blob })
      ]);

      await sendNotification({
        title: 'Copied!',
        body: 'Image copied to clipboard',
      });

      return true;
    } catch (e) {
      console.error('Clipboard copy failed:', e);
      return false;
    }
  }, [exportToDataURL]);

  const quickSave = useCallback(async () => {
    const dataURL = exportToDataURL();
    if (!dataURL) return null;

    try {
      const bytes = dataURLToBytes(dataURL);
      const picturesDir = await getPicturesDir();
      const filename = generateFilename(format);
      const fullPath = `${picturesDir}/${filename}`;

      const savedPath = await saveFile(fullPath, bytes);
      setLastSavePath(savedPath);

      await sendNotification({
        title: 'Saved!',
        body: `Image saved to ${filename}`,
      });

      return savedPath;
    } catch (e) {
      console.error('Quick save failed:', e);
      return null;
    }
  }, [exportToDataURL, format, setLastSavePath]);

  const saveAs = useCallback(async () => {
    const dataURL = exportToDataURL();
    if (!dataURL) return null;

    try {
      const defaultName = generateFilename(format);
      const path = await showSaveDialog(defaultName, format);

      if (!path) return null; // User cancelled

      const bytes = dataURLToBytes(dataURL);
      const savedPath = await saveFile(path, bytes);
      setLastSavePath(savedPath);

      await sendNotification({
        title: 'Saved!',
        body: `Image saved successfully`,
      });

      return savedPath;
    } catch (e) {
      console.error('Save as failed:', e);
      return null;
    }
  }, [exportToDataURL, format, setLastSavePath]);

  return {
    exportToDataURL,
    copyToClipboard,
    quickSave,
    saveAs,
  };
}
```

### 6.6 Export Panel UI

**src/components/sidebar/export-panel.tsx:**
```typescript
import { useRef } from 'react';
import Konva from 'konva';
import { useExportStore } from '../../stores/export-store';
import { useExport } from '../../hooks/use-export';

interface Props {
  stageRef: React.RefObject<Konva.Stage>;
}

export function ExportPanel({ stageRef }: Props) {
  const {
    format, quality, pixelRatio,
    setFormat, setQuality, setPixelRatio
  } = useExportStore();

  const { copyToClipboard, quickSave, saveAs } = useExport(stageRef);

  return (
    <div className="p-4 border-b">
      <h3 className="font-medium mb-3">Export</h3>

      {/* Format selection */}
      <div className="mb-4">
        <label className="block text-sm text-gray-600 mb-1">Format</label>
        <div className="flex gap-2">
          <button
            onClick={() => setFormat('png')}
            className={`flex-1 py-1 rounded ${
              format === 'png' ? 'bg-blue-500 text-white' : 'bg-gray-100'
            }`}
          >
            PNG
          </button>
          <button
            onClick={() => setFormat('jpeg')}
            className={`flex-1 py-1 rounded ${
              format === 'jpeg' ? 'bg-blue-500 text-white' : 'bg-gray-100'
            }`}
          >
            JPEG
          </button>
        </div>
      </div>

      {/* JPEG quality slider */}
      {format === 'jpeg' && (
        <div className="mb-4">
          <label className="block text-sm text-gray-600 mb-1">
            Quality: {Math.round(quality * 100)}%
          </label>
          <input
            type="range"
            min="10"
            max="100"
            value={quality * 100}
            onChange={(e) => setQuality(Number(e.target.value) / 100)}
            className="w-full"
          />
        </div>
      )}

      {/* Resolution (pixelRatio) */}
      <div className="mb-4">
        <label className="block text-sm text-gray-600 mb-1">Resolution</label>
        <div className="flex gap-2">
          {[1, 2, 3].map(ratio => (
            <button
              key={ratio}
              onClick={() => setPixelRatio(ratio)}
              className={`flex-1 py-1 rounded text-sm ${
                pixelRatio === ratio ? 'bg-blue-500 text-white' : 'bg-gray-100'
              }`}
            >
              {ratio}x
            </button>
          ))}
        </div>
        <span className="text-xs text-gray-500">
          Higher = larger file, sharper on Retina
        </span>
      </div>

      {/* Action buttons */}
      <div className="space-y-2">
        <button
          onClick={quickSave}
          className="w-full py-2 bg-green-500 text-white rounded hover:bg-green-600"
        >
          Quick Save (Pictures)
        </button>
        <button
          onClick={saveAs}
          className="w-full py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          Save As...
        </button>
        <button
          onClick={copyToClipboard}
          className="w-full py-2 bg-gray-200 rounded hover:bg-gray-300"
        >
          Copy to Clipboard
        </button>
      </div>
    </div>
  );
}
```

### 6.7 Add Dialog Plugin

```bash
npm install @tauri-apps/plugin-dialog
```

**src-tauri/src/main.rs** (add):
```rust
.plugin(tauri_plugin_dialog::init())
```

**src-tauri/capabilities/default.json** (add):
```json
"dialog:default"
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/stores/export-store.ts` | Create |
| `src/utils/export-utils.ts` | Create |
| `src/utils/file-api.ts` | Create |
| `src/hooks/use-export.ts` | Create |
| `src/components/sidebar/export-panel.tsx` | Create |
| `src-tauri/src/file_ops.rs` | Create |
| `src-tauri/src/main.rs` | Modify |
| `src-tauri/Cargo.toml` | Modify (add dirs) |
| `package.json` | Modify (add dialog plugin) |

---

## Success Criteria

- [x] PNG export works ✅
- [x] JPEG export with quality slider ✅
- [x] pixelRatio 1x/2x/3x working (Retina support) ✅
- [x] Quick save to Pictures/BeautyShot folder ✅
- [x] Save As dialog opens correctly ✅
- [x] Copy to clipboard works ✅
- [x] Auto-generated filenames with timestamp ✅
- [x] Notifications on save success ✅
- [x] Crop region exported correctly ✅

**Additional Achievements:**
- [x] 100% test coverage on export-store (36 tests)
- [x] 64 comprehensive tests added total (184 total suite)
- [x] TypeScript strict mode compliance
- [x] Build succeeds with no errors
- [x] Security audit passed (OWASP Top 10)
- [x] Code review Grade A+ (98/100) - all issues optimized

**Security Optimizations:**
- [x] Path canonicalization to prevent directory traversal
- [x] 50MB file size limit enforced in Rust
- [x] ExportError class with error codes for debugging
- [x] Loading states prevent double-submissions
- [x] User notifications on all error conditions

---

## Performance Notes

- Large images (4K+) may take 1-2s to export at 2x/3x
- Use loading indicator during export
- Blob generation is async, DataURL is sync

---

## Next Phase

[Phase 07: Native OS Integration](./phase-07-native-integration.md)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-07-native-integration.md">
# Phase 07: Native OS Integration

**Status**: ✅ completed | **Effort**: 5h (actual: 4h) | **Priority**: P2
**Completed**: 2025-12-29 | **Code Review**: APPROVED (Grade A - 95/100)

## Objective

Implement system tray with menu, configurable global hotkeys, notifications on save, and settings persistence.

---

## Tasks

### 7.1 System Tray Setup

**src-tauri/src/tray.rs:**
```rust
use tauri::{
    menu::{Menu, MenuItem, PredefinedMenuItem},
    tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent},
    Manager, Runtime,
};

pub fn create_tray<R: Runtime>(app: &tauri::AppHandle<R>) -> tauri::Result<()> {
    let quit_item = MenuItem::with_id(app, "quit", "Quit BeautyShot", true, None::<&str>)?;
    let show_item = MenuItem::with_id(app, "show", "Show Window", true, None::<&str>)?;
    let capture_item = MenuItem::with_id(app, "capture", "Capture Screen", true, Some("CmdOrCtrl+Shift+C"))?;
    let separator = PredefinedMenuItem::separator(app)?;

    let menu = Menu::with_items(app, &[
        &capture_item,
        &separator,
        &show_item,
        &quit_item,
    ])?;

    let _tray = TrayIconBuilder::new()
        .icon(app.default_window_icon().unwrap().clone())
        .menu(&menu)
        .menu_on_left_click(false)
        .on_menu_event(|app, event| {
            match event.id.as_ref() {
                "quit" => {
                    app.exit(0);
                }
                "show" => {
                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.show();
                        let _ = window.set_focus();
                    }
                }
                "capture" => {
                    // Emit event to frontend
                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.emit("tray-capture", ());
                    }
                }
                _ => {}
            }
        })
        .on_tray_icon_event(|tray, event| {
            if let TrayIconEvent::Click {
                button: MouseButton::Left,
                button_state: MouseButtonState::Up,
                ..
            } = event
            {
                let app = tray.app_handle();
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.show();
                    let _ = window.set_focus();
                }
            }
        })
        .build(app)?;

    Ok(())
}
```

### 7.2 Global Shortcuts

**src-tauri/src/shortcuts.rs:**
```rust
use tauri::{AppHandle, Manager};
use tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut};

pub fn register_shortcuts(app: &AppHandle) -> Result<(), Box<dyn std::error::Error>> {
    let shortcut = Shortcut::new(
        Some(Modifiers::SUPER | Modifiers::SHIFT),
        Code::KeyC
    );

    app.global_shortcut().on_shortcut(shortcut, |app, _shortcut, _event| {
        if let Some(window) = app.get_webview_window("main") {
            let _ = window.emit("hotkey-capture", ());
        }
    })?;

    Ok(())
}
```

**Update src-tauri/src/main.rs:**
```rust
mod tray;
mod shortcuts;

fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_global_shortcut::Builder::new().build())
        .plugin(tauri_plugin_notification::init())
        .plugin(tauri_plugin_dialog::init())
        .setup(|app| {
            // Create system tray
            tray::create_tray(app.handle())?;

            // Register global shortcuts
            if let Err(e) = shortcuts::register_shortcuts(app.handle()) {
                eprintln!("Failed to register shortcuts: {}", e);
            }

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            // ... existing commands
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 7.3 Frontend Hotkey Listener

**src/hooks/use-hotkeys.ts:**
```typescript
import { useEffect } from 'react';
import { listen } from '@tauri-apps/api/event';
import { useScreenshot } from './use-screenshot';

export function useHotkeys() {
  const { captureFullscreen } = useScreenshot();

  useEffect(() => {
    // Listen for tray capture event
    const unlistenTray = listen('tray-capture', () => {
      captureFullscreen();
    });

    // Listen for global hotkey event
    const unlistenHotkey = listen('hotkey-capture', () => {
      captureFullscreen();
    });

    return () => {
      unlistenTray.then(fn => fn());
      unlistenHotkey.then(fn => fn());
    };
  }, [captureFullscreen]);
}
```

### 7.4 Settings Store (Persisted)

**src/stores/settings-store.ts:**
```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface HotkeyConfig {
  capture: string;
  captureRegion: string;
  captureWindow: string;
  save: string;
  copy: string;
}

interface SettingsState {
  // Hotkeys
  hotkeys: HotkeyConfig;

  // Behavior
  startMinimized: boolean;
  closeToTray: boolean;
  showNotifications: boolean;

  // Default save location
  saveLocation: 'pictures' | 'desktop' | 'custom';
  customSavePath: string | null;

  // Actions
  setHotkey: (action: keyof HotkeyConfig, shortcut: string) => void;
  setStartMinimized: (value: boolean) => void;
  setCloseToTray: (value: boolean) => void;
  setShowNotifications: (value: boolean) => void;
  setSaveLocation: (location: 'pictures' | 'desktop' | 'custom') => void;
  setCustomSavePath: (path: string | null) => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      hotkeys: {
        capture: 'CommandOrControl+Shift+C',
        captureRegion: 'CommandOrControl+Shift+R',
        captureWindow: 'CommandOrControl+Shift+W',
        save: 'CommandOrControl+S',
        copy: 'CommandOrControl+Shift+V',
      },

      startMinimized: false,
      closeToTray: true,
      showNotifications: true,

      saveLocation: 'pictures',
      customSavePath: null,

      setHotkey: (action, shortcut) =>
        set(state => ({
          hotkeys: { ...state.hotkeys, [action]: shortcut }
        })),
      setStartMinimized: (value) => set({ startMinimized: value }),
      setCloseToTray: (value) => set({ closeToTray: value }),
      setShowNotifications: (value) => set({ showNotifications: value }),
      setSaveLocation: (location) => set({ saveLocation: location }),
      setCustomSavePath: (path) => set({ customSavePath: path }),
    }),
    {
      name: 'beautyshot-settings',
      storage: createJSONStorage(() => localStorage),
    }
  )
);
```

### 7.5 Settings Panel UI

**src/components/settings/settings-modal.tsx:**
```typescript
import { useState } from 'react';
import { useSettingsStore } from '../../stores/settings-store';

interface Props {
  isOpen: boolean;
  onClose: () => void;
}

export function SettingsModal({ isOpen, onClose }: Props) {
  const settings = useSettingsStore();

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg w-[500px] max-h-[80vh] overflow-y-auto">
        <div className="p-4 border-b flex justify-between items-center">
          <h2 className="text-lg font-medium">Settings</h2>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
            ✕
          </button>
        </div>

        <div className="p-4 space-y-6">
          {/* Hotkeys Section */}
          <section>
            <h3 className="font-medium mb-3">Keyboard Shortcuts</h3>
            <div className="space-y-2">
              {Object.entries(settings.hotkeys).map(([action, shortcut]) => (
                <div key={action} className="flex justify-between items-center">
                  <label className="text-sm capitalize">
                    {action.replace(/([A-Z])/g, ' $1').trim()}
                  </label>
                  <input
                    type="text"
                    value={shortcut}
                    onChange={(e) => settings.setHotkey(
                      action as keyof typeof settings.hotkeys,
                      e.target.value
                    )}
                    className="w-48 px-2 py-1 border rounded text-sm"
                    placeholder="Press keys..."
                  />
                </div>
              ))}
            </div>
          </section>

          {/* Behavior Section */}
          <section>
            <h3 className="font-medium mb-3">Behavior</h3>
            <div className="space-y-3">
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={settings.startMinimized}
                  onChange={(e) => settings.setStartMinimized(e.target.checked)}
                />
                <span className="text-sm">Start minimized to tray</span>
              </label>

              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={settings.closeToTray}
                  onChange={(e) => settings.setCloseToTray(e.target.checked)}
                />
                <span className="text-sm">Close to tray instead of quit</span>
              </label>

              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={settings.showNotifications}
                  onChange={(e) => settings.setShowNotifications(e.target.checked)}
                />
                <span className="text-sm">Show notifications</span>
              </label>
            </div>
          </section>

          {/* Save Location */}
          <section>
            <h3 className="font-medium mb-3">Default Save Location</h3>
            <div className="space-y-2">
              {(['pictures', 'desktop', 'custom'] as const).map(loc => (
                <label key={loc} className="flex items-center gap-2">
                  <input
                    type="radio"
                    name="saveLocation"
                    checked={settings.saveLocation === loc}
                    onChange={() => settings.setSaveLocation(loc)}
                  />
                  <span className="text-sm capitalize">{loc}</span>
                </label>
              ))}

              {settings.saveLocation === 'custom' && (
                <div className="ml-6">
                  <input
                    type="text"
                    value={settings.customSavePath || ''}
                    onChange={(e) => settings.setCustomSavePath(e.target.value)}
                    className="w-full px-2 py-1 border rounded text-sm"
                    placeholder="Custom path..."
                  />
                </div>
              )}
            </div>
          </section>
        </div>

        <div className="p-4 border-t flex justify-end">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Done
          </button>
        </div>
      </div>
    </div>
  );
}
```

### 7.6 Window Close Handler

**src/App.tsx** (add close handler):
```typescript
import { useEffect } from 'react';
import { getCurrentWindow } from '@tauri-apps/api/window';
import { useSettingsStore } from './stores/settings-store';

function App() {
  const { closeToTray } = useSettingsStore();

  useEffect(() => {
    const appWindow = getCurrentWindow();

    const unlisten = appWindow.onCloseRequested(async (event) => {
      if (closeToTray) {
        event.preventDefault();
        await appWindow.hide();
      }
    });

    return () => {
      unlisten.then(fn => fn());
    };
  }, [closeToTray]);

  // ... rest of component
}
```

### 7.7 macOS Template Icon

For macOS dark mode support, create template icon:

**src-tauri/icons/icon-template.png** (white icon on transparent background)

**Update tray.rs:**
```rust
#[cfg(target_os = "macos")]
let icon = tauri::image::Image::from_path("icons/icon-template.png")?;

#[cfg(not(target_os = "macos"))]
let icon = app.default_window_icon().unwrap().clone();
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src-tauri/src/tray.rs` | Create |
| `src-tauri/src/shortcuts.rs` | Create |
| `src-tauri/src/main.rs` | Modify |
| `src/stores/settings-store.ts` | Create |
| `src/hooks/use-hotkeys.ts` | Create |
| `src/components/settings/settings-modal.tsx` | Create |
| `src/App.tsx` | Modify (close handler) |
| `src-tauri/icons/icon-template.png` | Create (macOS) |

---

## Platform Considerations

### macOS
- Template icon required for proper dark mode tray
- Accessibility permissions may be needed for global shortcuts
- Notarization required for distribution

### Windows
- Tray icon works out of box
- Global shortcuts work without special permissions
- UAC not required for normal operation

### Linux
- Tray support varies by desktop environment
- GNOME needs extension for tray icons
- KDE/XFCE have native support
- Wayland may have hotkey limitations

---

## Success Criteria

- [x] System tray icon visible on all platforms ✅
- [x] Tray menu with Capture/Show/Quit options ✅
- [x] Click tray icon → show window ✅
- [x] Global hotkey triggers capture ✅
- [x] Settings saved to localStorage ✅
- [x] Close to tray works (when enabled) ✅
- [x] Notifications appear on save (when enabled) ✅
- [x] Settings modal opens and saves correctly ✅

**Additional Achievements:**
- [x] 28 tests for settings store + hotkey validation (212 total)
- [x] Safe error handling in tray.rs (no unwrap crashes)
- [x] Hotkey input validation with visual feedback
- [x] Notifications respect showNotifications setting

---

## Known Issues

- Linux GNOME: May need TopIcons extension
- Wayland: Some global hotkeys may not work
- macOS: First hotkey use needs Accessibility approval

---

## Next Phase

[Phase 08: Polish & Distribution](./phase-08-polish-distribution.md)
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-08-polish-distribution.md">
# Phase 08: Polish & Distribution

**Status**: completed | **Effort**: 4h | **Priority**: P3 | **Completed**: 2025-12-29

## Objective

Cross-platform testing, platform-specific fixes, build configurations for installers (Windows NSIS, macOS DMG, Linux AppImage), and documentation.

---

## Tasks

### 8.1 Cross-Platform Testing Checklist

| Test Case | Windows | macOS | Linux X11 | Linux Wayland |
|-----------|---------|-------|-----------|---------------|
| App launches | | | | |
| Screenshot fullscreen | | | | |
| Screenshot window | | | | |
| Screenshot region | | | | |
| Canvas zoom/pan | | | | |
| All annotation tools | | | | |
| Gradient backgrounds | | | | |
| Cropping | | | | |
| Export PNG | | | | |
| Export JPEG | | | | |
| Copy to clipboard | | | | |
| System tray | | | | |
| Global hotkey | | | | |
| Notifications | | | | |
| Settings persist | | | | |
| Close to tray | | | | |

### 8.2 Platform-Specific Fixes

#### macOS

**Info.plist additions** (src-tauri/Info.plist):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSScreenCaptureDescription</key>
    <string>BeautyShot needs screen recording permission to capture screenshots.</string>
    <key>LSUIElement</key>
    <true/>
</dict>
</plist>
```

**Entitlements** (src-tauri/entitlements.plist):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <false/>
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>
</dict>
</plist>
```

#### Windows

**WebView2 bundling** (tauri.conf.json):
```json
{
  "bundle": {
    "windows": {
      "webviewInstallMode": {
        "type": "downloadBootstrapper"
      }
    }
  }
}
```

#### Linux

**Desktop file** (src-tauri/beautyshot.desktop):
```ini
[Desktop Entry]
Name=BeautyShot
Comment=Screenshot beautification app
Exec=beautyshot
Icon=beautyshot
Type=Application
Categories=Graphics;Utility;
Keywords=screenshot;capture;annotation;
StartupWMClass=beautyshot
```

### 8.3 Build Configuration

**src-tauri/tauri.conf.json** (complete):
```json
{
  "$schema": "https://schema.tauri.app/config/2.0.0",
  "productName": "BeautyShot",
  "version": "1.0.0",
  "identifier": "com.beautyshot.app",
  "build": {
    "beforeBuildCommand": "npm run build",
    "devPath": "http://localhost:5173",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [{
      "title": "BeautyShot",
      "width": 1200,
      "height": 800,
      "minWidth": 800,
      "minHeight": 600,
      "resizable": true,
      "fullscreen": false,
      "decorations": true,
      "transparent": false,
      "center": true
    }],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "category": "Graphics",
    "shortDescription": "Screenshot beautification app",
    "longDescription": "Capture, annotate, and beautify screenshots with gradient backgrounds and export options.",
    "copyright": "2025 BeautyShot",
    "targets": "all",
    "windows": {
      "nsis": {
        "displayLanguageSelector": true,
        "installerIcon": "icons/icon.ico",
        "sidebarImage": "icons/nsis-sidebar.bmp",
        "license": "LICENSE"
      },
      "wix": null,
      "webviewInstallMode": {
        "type": "downloadBootstrapper"
      }
    },
    "macOS": {
      "minimumSystemVersion": "11.0",
      "entitlements": "entitlements.plist",
      "exceptionDomain": null,
      "signingIdentity": null
    },
    "linux": {
      "appimage": {
        "bundleMediaFramework": true
      },
      "deb": {
        "depends": ["libwebkit2gtk-4.1-0", "libgtk-3-0"],
        "section": "graphics"
      },
      "rpm": {
        "epoch": 0
      }
    }
  }
}
```

### 8.4 Build Commands

**package.json** scripts:
```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri",
    "tauri:dev": "tauri dev",
    "tauri:build": "tauri build",
    "tauri:build:debug": "tauri build --debug"
  }
}
```

**Build for each platform:**
```bash
# Windows (on Windows machine)
npm run tauri:build
# Output: src-tauri/target/release/bundle/nsis/BeautyShot_1.0.0_x64-setup.exe

# macOS (on Mac)
npm run tauri:build
# Output: src-tauri/target/release/bundle/dmg/BeautyShot_1.0.0_x64.dmg

# Linux (on Linux)
npm run tauri:build
# Output: src-tauri/target/release/bundle/appimage/BeautyShot_1.0.0_amd64.AppImage
```

### 8.5 Icon Generation

**Required icons:**
```
src-tauri/icons/
├── 32x32.png           # Windows/Linux small
├── 128x128.png         # Linux
├── 128x128@2x.png      # macOS Retina
├── icon.icns           # macOS app icon
├── icon.ico            # Windows app icon
├── icon-template.png   # macOS tray (white on transparent)
└── nsis-sidebar.bmp    # Windows installer sidebar (164x314)
```

**Generate from source icon:**
```bash
# Using ImageMagick
convert icon-1024.png -resize 32x32 32x32.png
convert icon-1024.png -resize 128x128 128x128.png
convert icon-1024.png -resize 256x256 128x128@2x.png

# macOS icns (requires iconutil)
mkdir icon.iconset
convert icon-1024.png -resize 16x16 icon.iconset/icon_16x16.png
convert icon-1024.png -resize 32x32 icon.iconset/icon_16x16@2x.png
convert icon-1024.png -resize 32x32 icon.iconset/icon_32x32.png
convert icon-1024.png -resize 64x64 icon.iconset/icon_32x32@2x.png
convert icon-1024.png -resize 128x128 icon.iconset/icon_128x128.png
convert icon-1024.png -resize 256x256 icon.iconset/icon_128x128@2x.png
convert icon-1024.png -resize 256x256 icon.iconset/icon_256x256.png
convert icon-1024.png -resize 512x512 icon.iconset/icon_256x256@2x.png
convert icon-1024.png -resize 512x512 icon.iconset/icon_512x512.png
convert icon-1024.png -resize 1024x1024 icon.iconset/icon_512x512@2x.png
iconutil -c icns icon.iconset

# Windows ico
convert icon-1024.png -define icon:auto-resize=256,128,64,48,32,16 icon.ico
```

### 8.6 Code Signing (Production)

#### macOS Notarization

```bash
# Sign with Developer ID
codesign --deep --force --verify --verbose \
  --sign "Developer ID Application: Your Name (TEAM_ID)" \
  --options runtime \
  target/release/bundle/macos/BeautyShot.app

# Create notarization zip
ditto -c -k --keepParent \
  target/release/bundle/macos/BeautyShot.app \
  BeautyShot.zip

# Submit for notarization
xcrun notarytool submit BeautyShot.zip \
  --apple-id "your@email.com" \
  --team-id "TEAM_ID" \
  --password "@keychain:AC_PASSWORD" \
  --wait

# Staple ticket
xcrun stapler staple target/release/bundle/macos/BeautyShot.app
```

#### Windows Code Signing

```bash
# With signtool.exe
signtool sign /a /t http://timestamp.digicert.com \
  /fd SHA256 \
  target/release/bundle/nsis/BeautyShot_1.0.0_x64-setup.exe
```

### 8.7 README Documentation

**README.md:**
```markdown
# BeautyShot

Cross-platform screenshot beautification app built with Tauri v2 + React.

## Features

- Screenshot capture (fullscreen, region, window)
- Annotation tools (shapes, arrows, text, numbers, spotlight)
- Gradient backgrounds (24+ presets)
- Aspect ratio cropping
- PNG/JPEG export with quality control
- System tray & global hotkeys
- Cross-platform (Windows, macOS, Linux)

## Installation

### Windows
Download `BeautyShot_x.x.x_x64-setup.exe` from Releases.

### macOS
Download `BeautyShot_x.x.x_x64.dmg` from Releases.
Drag to Applications folder.

### Linux
Download `BeautyShot_x.x.x_amd64.AppImage` from Releases.
```bash
chmod +x BeautyShot_*.AppImage
./BeautyShot_*.AppImage
```

## Keyboard Shortcuts

| Action | Shortcut |
|--------|----------|
| Capture Screen | Cmd/Ctrl+Shift+C |
| Capture Region | Cmd/Ctrl+Shift+R |
| Quick Save | Cmd/Ctrl+S |
| Copy to Clipboard | Cmd/Ctrl+Shift+V |

## Development

```bash
# Prerequisites
- Rust 1.70+
- Node.js 18+
- Platform build tools

# Install dependencies
npm install

# Run development
npm run tauri:dev

# Build for production
npm run tauri:build
```

## License

MIT
```

### 8.8 GitHub Release Workflow

**.github/workflows/release.yml:**
```yaml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    strategy:
      matrix:
        include:
          - platform: macos-latest
            target: aarch64-apple-darwin
          - platform: macos-latest
            target: x86_64-apple-darwin
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu

    runs-on: ${{ matrix.platform }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Rust
        uses: dtolnay/rust-action@stable

      - name: Install Linux deps
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev

      - name: Install deps
        run: npm install

      - name: Build
        run: npm run tauri:build
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_KEY }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.target }}
          path: |
            src-tauri/target/release/bundle/*/BeautyShot*

  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: binaries-*/*
          draft: true
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src-tauri/tauri.conf.json` | Modify (full config) |
| `src-tauri/Info.plist` | Create (macOS) |
| `src-tauri/entitlements.plist` | Create (macOS) |
| `src-tauri/beautyshot.desktop` | Create (Linux) |
| `src-tauri/icons/*` | Create (all icons) |
| `README.md` | Create |
| `.github/workflows/release.yml` | Create |
| `LICENSE` | Create |

---

## Success Criteria

- [x] App builds on Windows without errors
- [x] App builds on macOS without errors
- [x] App builds on Linux without errors
- [x] Windows NSIS installer works
- [x] macOS DMG mounts and installs
- [x] Linux AppImage runs
- [x] All icons display correctly
- [x] README complete and accurate
- [x] GitHub Actions workflow passes

---

## Bundle Size Targets

| Platform | Target | Max |
|----------|--------|-----|
| Windows (NSIS) | ~8MB | <15MB |
| macOS (DMG) | ~6MB | <12MB |
| Linux (AppImage) | ~10MB | <18MB |

---

## Final Checklist

- [x] Version number updated in tauri.conf.json
- [x] Changelog written
- [x] All tests passing
- [x] No console errors in production build
- [x] Code signed (production only)
- [x] README updated with latest screenshots
- [x] Release notes prepared

---

## Post-Release Tasks

1. Monitor GitHub Issues for bug reports
2. Collect user feedback
3. Plan v1.1 features (undo/redo, more shapes, etc.)
4. Consider auto-update mechanism (Tauri updater plugin)

---

## Unresolved Questions

1. macOS App Store distribution? (requires sandboxing changes)
2. Microsoft Store distribution?
3. Snapcraft for Linux?
4. Auto-update server hosting?
</file>

<file path="src/components/canvas/annotations/arrow-shape.tsx">
// ArrowShape - Line and Arrow annotation component

import { Arrow, Line } from 'react-konva';
import type { LineAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: LineAnnotation;
}

export function ArrowShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();
  const isArrow = annotation.type === 'arrow';

  const Component = isArrow ? Arrow : Line;

  return (
    <Component
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      points={annotation.points}
      stroke={annotation.stroke}
      strokeWidth={annotation.strokeWidth}
      pointerLength={isArrow ? annotation.pointerLength || 10 : undefined}
      pointerWidth={isArrow ? annotation.pointerWidth || 10 : undefined}
      draggable={annotation.draggable}
      hitStrokeWidth={Math.max(10, annotation.strokeWidth * 3)}
      onClick={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onTap={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
    />
  );
}
</file>

<file path="src/components/canvas/annotations/ellipse-shape.tsx">
// EllipseShape - Ellipse annotation component

import { Ellipse } from 'react-konva';
import type Konva from 'konva';
import type { EllipseAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';
import { useTransformHandler } from '../../../hooks/use-transform-handler';

interface Props {
  annotation: EllipseAnnotation;
}

export function EllipseShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();
  const handleTransformEnd = useTransformHandler(annotation.id, 'ellipse', {
    radiusX: annotation.radiusX,
    radiusY: annotation.radiusY,
  });

  // Custom hit function for transparent fills - ensures clicks inside shape register
  const hitFunc = (context: Konva.Context, shape: Konva.Shape) => {
    context.beginPath();
    context.ellipse(0, 0, annotation.radiusX, annotation.radiusY, 0, 0, Math.PI * 2);
    context.closePath();
    context.fillStrokeShape(shape);
  };

  return (
    <Ellipse
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      radiusX={annotation.radiusX}
      radiusY={annotation.radiusY}
      fill={annotation.fill}
      stroke={annotation.stroke}
      strokeWidth={annotation.strokeWidth}
      rotation={annotation.rotation}
      draggable={annotation.draggable}
      hitFunc={annotation.fill === 'transparent' ? hitFunc : undefined}
      onClick={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onTap={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
      onTransformEnd={handleTransformEnd}
    />
  );
}
</file>

<file path="src/components/canvas/annotations/freehand-shape.tsx">
// FreehandShape - Freehand drawing annotation component

import { Line } from 'react-konva';
import type { FreehandAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: FreehandAnnotation;
}

export function FreehandShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();

  return (
    <Line
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      points={annotation.points}
      stroke={annotation.stroke}
      strokeWidth={annotation.strokeWidth}
      tension={0.5}
      lineCap="round"
      lineJoin="round"
      draggable={annotation.draggable}
      hitStrokeWidth={Math.max(10, annotation.strokeWidth * 3)}
      onClick={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onTap={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
    />
  );
}
</file>

<file path="src/components/canvas/annotations/rect-shape.tsx">
// RectShape - Rectangle annotation component

import { Rect } from 'react-konva';
import type Konva from 'konva';
import type { RectAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';
import { useTransformHandler } from '../../../hooks/use-transform-handler';

interface Props {
  annotation: RectAnnotation;
}

export function RectShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();
  const handleTransformEnd = useTransformHandler(annotation.id, 'rect');

  // Custom hit function for transparent fills - ensures clicks inside shape register
  const hitFunc = (context: Konva.Context, shape: Konva.Shape) => {
    context.beginPath();
    context.rect(0, 0, annotation.width, annotation.height);
    context.closePath();
    context.fillStrokeShape(shape);
  };

  return (
    <Rect
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      width={annotation.width}
      height={annotation.height}
      fill={annotation.fill}
      stroke={annotation.stroke}
      strokeWidth={annotation.strokeWidth}
      rotation={annotation.rotation}
      draggable={annotation.draggable}
      hitFunc={annotation.fill === 'transparent' ? hitFunc : undefined}
      onClick={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onTap={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
      onTransformEnd={handleTransformEnd}
    />
  );
}
</file>

<file path="src/components/canvas/annotations/text-shape.tsx">
// TextShape - Text annotation component with double-click editing

import { Text } from 'react-konva';
import type { TextAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';
import { useTransformHandler } from '../../../hooks/use-transform-handler';

interface Props {
  annotation: TextAnnotation;
}

export function TextShape({ annotation }: Props) {
  const { updateAnnotation, setSelected, setEditingTextId, editingTextId } = useAnnotationStore();
  const handleTransformEnd = useTransformHandler(annotation.id, 'text', {
    fontSize: annotation.fontSize,
  });

  // Hide text when editing (overlay will show input)
  if (editingTextId === annotation.id) {
    return null;
  }

  return (
    <Text
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      text={annotation.text}
      fontSize={annotation.fontSize}
      fontFamily={annotation.fontFamily}
      fill={annotation.fill}
      rotation={annotation.rotation}
      draggable={annotation.draggable}
      onClick={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onTap={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onDblClick={(e) => {
        e.cancelBubble = true;
        setEditingTextId(annotation.id);
      }}
      onDblTap={(e) => {
        e.cancelBubble = true;
        setEditingTextId(annotation.id);
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
      onTransformEnd={handleTransformEnd}
    />
  );
}
</file>

<file path="src/components/canvas/text-input-overlay.tsx">
// TextInputOverlay - In-canvas text input for text annotations

import { useRef, useEffect, useState } from 'react';
import { useAnnotationStore } from '../../stores/annotation-store';

interface Props {
  position: { x: number; y: number; screenX: number; screenY: number };
  scale: number;
  onSubmit: (text: string) => void;
  onCancel: () => void;
}

export function TextInputOverlay({
  position,
  scale,
  onSubmit,
  onCancel,
}: Props) {
  const inputRef = useRef<HTMLInputElement>(null);
  const measureRef = useRef<HTMLSpanElement>(null);
  const [text, setText] = useState('');
  const [inputWidth, setInputWidth] = useState(20);
  const [isReady, setIsReady] = useState(false);
  const { fontSize, strokeColor } = useAnnotationStore();

  // Focus input on mount
  useEffect(() => {
    const timer = setTimeout(() => {
      inputRef.current?.focus();
      setIsReady(true);
    }, 50);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (measureRef.current) {
      const width = measureRef.current.offsetWidth;
      setInputWidth(Math.max(8, width + 2));
    }
  }, [text, fontSize, scale]);

  const screenX = position.screenX - 10;
  const screenY = position.screenY - 4;

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      onSubmit(text);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onCancel();
    }
  };

  const scaledFontSize = fontSize * scale;

  return (
    <div
      className="absolute z-50"
      style={{
        left: screenX,
        top: screenY,
      }}
    >
      <span
        ref={measureRef}
        className="absolute invisible whitespace-pre"
        style={{
          fontSize: `${scaledFontSize}px`,
          fontFamily: 'inherit',
        }}
      >
        {text || ' '}
      </span>
      <input
        ref={inputRef}
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        onKeyDown={handleKeyDown}
        onBlur={() => {
          if (!isReady) return;
          if (text.trim()) {
            onSubmit(text);
          } else {
            onCancel();
          }
        }}
        className="px-2 py-0.5 border-2 border-blue-500 rounded outline-none bg-white dark:bg-gray-800 dark:text-white box-content"
        style={{
          fontSize: `${scaledFontSize}px`,
          color: strokeColor,
          width: `${inputWidth}px`,
        }}
      />
    </div>
  );
}
</file>

<file path="src/components/common/toast.tsx">
// Toast notification component with action support

import { useEffect, useState } from 'react';
import { revealItemInDir } from '@tauri-apps/plugin-opener';

export interface ToastData {
  id: string;
  title: string;
  message: string;
  type: 'success' | 'error' | 'info';
  filePath?: string; // Optional file path for "Show in Folder" action
  duration?: number; // Auto-dismiss duration in ms
}

interface ToastProps {
  toast: ToastData;
  onDismiss: (id: string) => void;
}

function Toast({ toast, onDismiss }: ToastProps) {
  const [isExiting, setIsExiting] = useState(false);

  useEffect(() => {
    const duration = toast.duration ?? 5000;
    const timer = setTimeout(() => {
      setIsExiting(true);
      setTimeout(() => onDismiss(toast.id), 300);
    }, duration);

    return () => clearTimeout(timer);
  }, [toast.id, toast.duration, onDismiss]);

  const handleShowInFolder = async () => {
    if (toast.filePath) {
      await revealItemInDir(toast.filePath);
    }
  };

  const iconColors = {
    success: 'text-green-500',
    error: 'text-red-500',
    info: 'text-blue-500',
  }[toast.type];

  const icon = {
    success: (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
      </svg>
    ),
    error: (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    ),
    info: (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    ),
  }[toast.type];

  return (
    <div
      className={`flex items-start gap-3 p-4 glass floating-panel transition-all duration-300 ${
        isExiting ? 'opacity-0 translate-x-4' : 'opacity-100 translate-x-0'
      }`}
    >
      <div className={`flex-shrink-0 ${iconColors}`}>{icon}</div>
      <div className="flex-1 min-w-0">
        <p className="font-medium text-gray-800 dark:text-gray-100">{toast.title}</p>
        <p className="text-sm text-gray-600 dark:text-gray-300 truncate">{toast.message}</p>
        {toast.filePath && (
          <button
            onClick={handleShowInFolder}
            className="mt-2 text-sm text-orange-500 hover:text-orange-600 underline hover:no-underline transition-colors"
          >
            Show in Folder
          </button>
        )}
      </div>
      <button
        onClick={() => {
          setIsExiting(true);
          setTimeout(() => onDismiss(toast.id), 300);
        }}
        className="flex-shrink-0 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-colors"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
  );
}

interface ToastContainerProps {
  toasts: ToastData[];
  onDismiss: (id: string) => void;
}

export function ToastContainer({ toasts, onDismiss }: ToastContainerProps) {
  if (toasts.length === 0) return null;

  return (
    <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2 max-w-sm">
      {toasts.map((toast) => (
        <Toast key={toast.id} toast={toast} onDismiss={onDismiss} />
      ))}
    </div>
  );
}
</file>

<file path="src/components/toolbar/undo-redo-buttons.tsx">
// UndoRedoButtons - Undo and redo action buttons

import { useAnnotationStore } from '../../stores/annotation-store';
import { useHistoryStore } from '../../stores/history-store';

export function UndoRedoButtons() {
  const { undo, redo } = useAnnotationStore();
  // Subscribe to history store changes
  const canUndo = useHistoryStore((s) => s.past.length > 0);
  const canRedo = useHistoryStore((s) => s.future.length > 0);

  return (
    <div className="flex gap-1">
      {/* Undo button */}
      <button
        onClick={undo}
        disabled={!canUndo}
        aria-label="Undo (Ctrl+Z / Cmd+Z)"
        title="Undo (Ctrl+Z / Cmd+Z)"
        className={`w-9 h-9 flex items-center justify-center rounded-xl transition-all ${
          canUndo
            ? 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
            : 'glass-flat text-gray-300 dark:text-gray-600 cursor-not-allowed opacity-50'
        }`}
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M3 10h10a5 5 0 0 1 5 5v2M3 10l4-4M3 10l4 4"
          />
        </svg>
      </button>

      {/* Redo button */}
      <button
        onClick={redo}
        disabled={!canRedo}
        aria-label="Redo (Ctrl+Shift+Z / Cmd+Shift+Z)"
        title="Redo (Ctrl+Shift+Z / Cmd+Shift+Z)"
        className={`w-9 h-9 flex items-center justify-center rounded-xl transition-all ${
          canRedo
            ? 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
            : 'glass-flat text-gray-300 dark:text-gray-600 cursor-not-allowed opacity-50'
        }`}
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M21 10H11a5 5 0 0 0-5 5v2M21 10l-4-4M21 10l-4 4"
          />
        </svg>
      </button>
    </div>
  );
}
</file>

<file path="src/data/__tests__/aspect-ratios.test.ts">
import { describe, it, expect } from 'vitest';
import { ASPECT_RATIOS, OUTPUT_ASPECT_RATIOS, type AspectRatio, type OutputAspectRatio } from '../aspect-ratios';

describe('Aspect Ratios Data', () => {
  describe('ASPECT_RATIOS', () => {
    it('should exist and be an array', () => {
      expect(Array.isArray(ASPECT_RATIOS)).toBe(true);
    });

    it('should have multiple aspect ratio options', () => {
      expect(ASPECT_RATIOS.length).toBeGreaterThan(0);
    });

    it('should have at least 8 aspect ratios', () => {
      expect(ASPECT_RATIOS.length).toBeGreaterThanOrEqual(8);
    });

    it('should have unique IDs', () => {
      const ids = ASPECT_RATIOS.map(ar => ar.id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(ASPECT_RATIOS.length);
    });

    it('should have unique names', () => {
      const names = ASPECT_RATIOS.map(ar => ar.name);
      const uniqueNames = new Set(names);
      expect(uniqueNames.size).toBe(ASPECT_RATIOS.length);
    });

    it('should have Free option first', () => {
      expect(ASPECT_RATIOS[0].id).toBe('free');
      expect(ASPECT_RATIOS[0].ratio).toBeNull();
    });
  });

  describe('AspectRatio Structure', () => {
    it('should have all required properties', () => {
      ASPECT_RATIOS.forEach(aspectRatio => {
        expect(aspectRatio).toHaveProperty('id');
        expect(aspectRatio).toHaveProperty('name');
        expect(aspectRatio).toHaveProperty('ratio');
      });
    });

    it('should have valid ID format', () => {
      ASPECT_RATIOS.forEach(aspectRatio => {
        expect(typeof aspectRatio.id).toBe('string');
        expect(aspectRatio.id.length).toBeGreaterThan(0);
      });
    });

    it('should have non-empty names', () => {
      ASPECT_RATIOS.forEach(aspectRatio => {
        expect(aspectRatio.name.length).toBeGreaterThan(0);
      });
    });

    it('should have valid ratio values', () => {
      ASPECT_RATIOS.forEach(aspectRatio => {
        if (aspectRatio.ratio !== null) {
          expect(typeof aspectRatio.ratio).toBe('number');
          expect(aspectRatio.ratio).toBeGreaterThan(0);
        }
      });
    });

    it('should match AspectRatio interface', () => {
      ASPECT_RATIOS.forEach(aspectRatio => {
        const ar: AspectRatio = aspectRatio;
        expect(ar.id).toBeDefined();
        expect(ar.name).toBeDefined();
        expect(ar.ratio).toBeDefined();
      });
    });
  });

  describe('Specific Aspect Ratios', () => {
    it('should have Free (freeform) option', () => {
      const free = ASPECT_RATIOS.find(ar => ar.id === 'free');
      expect(free).toBeDefined();
      expect(free?.ratio).toBeNull();
      expect(free?.name).toBe('Free');
    });

    it('should have 1:1 Square ratio', () => {
      const square = ASPECT_RATIOS.find(ar => ar.id === '1:1');
      expect(square).toBeDefined();
      expect(square?.ratio).toBe(1);
      expect(square?.name).toMatch(/Square|1:1/i);
    });

    it('should have 4:3 ratio', () => {
      const ratio4_3 = ASPECT_RATIOS.find(ar => ar.id === '4:3');
      expect(ratio4_3).toBeDefined();
      expect(ratio4_3?.ratio).toBe(4 / 3);
      expect(ratio4_3?.name).toMatch(/4:3/);
    });

    it('should have 3:2 ratio', () => {
      const ratio3_2 = ASPECT_RATIOS.find(ar => ar.id === '3:2');
      expect(ratio3_2).toBeDefined();
      expect(ratio3_2?.ratio).toBe(3 / 2);
      expect(ratio3_2?.name).toMatch(/3:2/);
    });

    it('should have 16:9 Widescreen ratio', () => {
      const widescreen = ASPECT_RATIOS.find(ar => ar.id === '16:9');
      expect(widescreen).toBeDefined();
      expect(widescreen?.ratio).toBe(16 / 9);
      expect(widescreen?.name).toMatch(/16:9|Widescreen/i);
    });

    it('should have 21:9 Ultrawide ratio', () => {
      const ultrawide = ASPECT_RATIOS.find(ar => ar.id === '21:9');
      expect(ultrawide).toBeDefined();
      expect(ultrawide?.ratio).toBe(21 / 9);
      expect(ultrawide?.name).toMatch(/21:9|Ultrawide/i);
    });

    it('should have 9:16 Portrait ratio', () => {
      const portrait = ASPECT_RATIOS.find(ar => ar.id === '9:16');
      expect(portrait).toBeDefined();
      expect(portrait?.ratio).toBe(9 / 16);
      expect(portrait?.name).toMatch(/9:16|Portrait/i);
    });

    it('should have 3:4 Portrait ratio', () => {
      const portrait3_4 = ASPECT_RATIOS.find(ar => ar.id === '3:4');
      expect(portrait3_4).toBeDefined();
      expect(portrait3_4?.ratio).toBe(3 / 4);
      expect(portrait3_4?.name).toMatch(/3:4|Portrait/i);
    });
  });

  describe('Common Aspect Ratio Values', () => {
    it('1:1 should equal 1', () => {
      const square = ASPECT_RATIOS.find(ar => ar.id === '1:1');
      expect(square?.ratio).toBe(1);
    });

    it('4:3 should equal approximately 1.333', () => {
      const ratio4_3 = ASPECT_RATIOS.find(ar => ar.id === '4:3');
      expect(ratio4_3?.ratio).toBeCloseTo(4 / 3, 5);
    });

    it('3:2 should equal 1.5', () => {
      const ratio3_2 = ASPECT_RATIOS.find(ar => ar.id === '3:2');
      expect(ratio3_2?.ratio).toBeCloseTo(3 / 2, 5);
    });

    it('16:9 should equal approximately 1.777', () => {
      const ratio16_9 = ASPECT_RATIOS.find(ar => ar.id === '16:9');
      expect(ratio16_9?.ratio).toBeCloseTo(16 / 9, 5);
    });

    it('21:9 should equal approximately 2.333', () => {
      const ratio21_9 = ASPECT_RATIOS.find(ar => ar.id === '21:9');
      expect(ratio21_9?.ratio).toBeCloseTo(21 / 9, 5);
    });

    it('9:16 should equal approximately 0.5625', () => {
      const ratio9_16 = ASPECT_RATIOS.find(ar => ar.id === '9:16');
      expect(ratio9_16?.ratio).toBeCloseTo(9 / 16, 5);
    });

    it('3:4 should equal 0.75', () => {
      const ratio3_4 = ASPECT_RATIOS.find(ar => ar.id === '3:4');
      expect(ratio3_4?.ratio).toBeCloseTo(3 / 4, 5);
    });
  });

  describe('Aspect Ratio Categories', () => {
    it('should have landscape ratios', () => {
      const landscape = ASPECT_RATIOS.filter(ar => ar.ratio && ar.ratio > 1);
      expect(landscape.length).toBeGreaterThan(0);
      landscape.forEach(ar => {
        expect(ar.ratio).toBeGreaterThan(1);
      });
    });

    it('should have portrait ratios', () => {
      const portrait = ASPECT_RATIOS.filter(ar => ar.ratio && ar.ratio < 1);
      expect(portrait.length).toBeGreaterThan(0);
      portrait.forEach(ar => {
        expect(ar.ratio).toBeLessThan(1);
      });
    });

    it('should have square ratio', () => {
      const square = ASPECT_RATIOS.find(ar => ar.ratio === 1);
      expect(square).toBeDefined();
    });

    it('should have freeform option', () => {
      const freeform = ASPECT_RATIOS.find(ar => ar.ratio === null);
      expect(freeform).toBeDefined();
    });
  });

  describe('Ratio Calculations', () => {
    it('all landscape ratios should be > 1', () => {
      const landscapeRatios = [
        4 / 3,
        3 / 2,
        16 / 9,
        21 / 9,
      ];

      landscapeRatios.forEach(expected => {
        expect(expected).toBeGreaterThan(1);
      });
    });

    it('all portrait ratios should be < 1', () => {
      const portraitRatios = [
        9 / 16,
        3 / 4,
      ];

      portraitRatios.forEach(expected => {
        expect(expected).toBeLessThan(1);
      });
    });

    it('should support common calculation patterns', () => {
      // Test that ratios are correctly calculated for use
      const widescreen = ASPECT_RATIOS.find(ar => ar.id === '16:9');
      if (widescreen?.ratio) {
        // If width is 1920, height should be 1080
        const height = 1920 / widescreen.ratio;
        expect(height).toBeCloseTo(1080, 0);
      }
    });
  });

  describe('Missing or Unexpected Ratios', () => {
    it('should not have duplicate ratio values', () => {
      const ratios = ASPECT_RATIOS
        .filter(ar => ar.ratio !== null)
        .map(ar => ar.ratio);
      const uniqueRatios = new Set(ratios);
      expect(uniqueRatios.size).toBe(ratios.length);
    });

    it('should only have one freeform ratio', () => {
      const freeform = ASPECT_RATIOS.filter(ar => ar.ratio === null);
      expect(freeform.length).toBe(1);
    });
  });

  describe('Interface Compliance', () => {
    it('all items should match AspectRatio interface', () => {
      ASPECT_RATIOS.forEach(item => {
        const aspectRatio: AspectRatio = {
          id: item.id,
          name: item.name,
          ratio: item.ratio,
        };
        expect(aspectRatio.id).toBe(item.id);
        expect(aspectRatio.name).toBe(item.name);
        expect(aspectRatio.ratio).toBe(item.ratio);
      });
    });
  });
});

describe('Output Aspect Ratios Data', () => {
  describe('OUTPUT_ASPECT_RATIOS', () => {
    it('should exist and be an array', () => {
      expect(Array.isArray(OUTPUT_ASPECT_RATIOS)).toBe(true);
    });

    it('should have multiple output aspect ratio options', () => {
      expect(OUTPUT_ASPECT_RATIOS.length).toBeGreaterThan(0);
    });

    it('should have at least 8 aspect ratios', () => {
      expect(OUTPUT_ASPECT_RATIOS.length).toBeGreaterThanOrEqual(8);
    });

    it('should have unique IDs', () => {
      const ids = OUTPUT_ASPECT_RATIOS.map(ar => ar.id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(OUTPUT_ASPECT_RATIOS.length);
    });

    it('should have Auto option first', () => {
      expect(OUTPUT_ASPECT_RATIOS[0].id).toBe('auto');
      expect(OUTPUT_ASPECT_RATIOS[0].ratio).toBeNull();
    });
  });

  describe('OutputAspectRatio Structure', () => {
    it('should have all required properties', () => {
      OUTPUT_ASPECT_RATIOS.forEach(aspectRatio => {
        expect(aspectRatio).toHaveProperty('id');
        expect(aspectRatio).toHaveProperty('name');
        expect(aspectRatio).toHaveProperty('ratio');
      });
    });

    it('should have valid ratio values', () => {
      OUTPUT_ASPECT_RATIOS.forEach(aspectRatio => {
        if (aspectRatio.ratio !== null) {
          expect(typeof aspectRatio.ratio).toBe('number');
          expect(aspectRatio.ratio).toBeGreaterThan(0);
        }
      });
    });

    it('should match OutputAspectRatio interface', () => {
      OUTPUT_ASPECT_RATIOS.forEach(aspectRatio => {
        const ar: OutputAspectRatio = aspectRatio;
        expect(ar.id).toBeDefined();
        expect(ar.name).toBeDefined();
      });
    });
  });

  describe('Social Media Aspect Ratios', () => {
    it('should have Auto (match screenshot) option', () => {
      const auto = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === 'auto');
      expect(auto).toBeDefined();
      expect(auto?.ratio).toBeNull();
    });

    it('should have 1:1 Square ratio', () => {
      const square = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '1:1');
      expect(square).toBeDefined();
      expect(square?.ratio).toBe(1);
    });

    it('should have 4:5 Instagram ratio', () => {
      const instagram = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '4:5');
      expect(instagram).toBeDefined();
      expect(instagram?.ratio).toBeCloseTo(4 / 5, 5);
    });

    it('should have 9:16 Stories ratio', () => {
      const stories = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '9:16');
      expect(stories).toBeDefined();
      expect(stories?.ratio).toBeCloseTo(9 / 16, 5);
    });

    it('should have 16:9 YouTube ratio', () => {
      const youtube = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '16:9');
      expect(youtube).toBeDefined();
      expect(youtube?.ratio).toBeCloseTo(16 / 9, 5);
    });

    it('should have 2:1 Twitter ratio', () => {
      const twitter = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '2:1');
      expect(twitter).toBeDefined();
      expect(twitter?.ratio).toBe(2);
    });

    it('should have 1.91:1 Facebook ratio', () => {
      const facebook = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '1.91:1');
      expect(facebook).toBeDefined();
      expect(facebook?.ratio).toBeCloseTo(1.91, 5);
    });

    it('should have 3:4 Pinterest ratio', () => {
      const pinterest = OUTPUT_ASPECT_RATIOS.find(ar => ar.id === '3:4');
      expect(pinterest).toBeDefined();
      expect(pinterest?.ratio).toBeCloseTo(3 / 4, 5);
    });
  });
});
</file>

<file path="src/data/aspect-ratios.ts">
// Aspect ratio presets for cropping and export

export interface AspectRatio {
  id: string;
  name: string;
  ratio: number | null; // null = freeform/auto
  category?: 'general' | 'social';
}

// Crop aspect ratios (used in crop tool)
export const ASPECT_RATIOS: AspectRatio[] = [
  { id: 'free', name: 'Free', ratio: null, category: 'general' },
  { id: '1:1', name: '1:1 Square', ratio: 1, category: 'general' },
  { id: '4:3', name: '4:3', ratio: 4 / 3, category: 'general' },
  { id: '3:2', name: '3:2', ratio: 3 / 2, category: 'general' },
  { id: '16:9', name: '16:9 Widescreen', ratio: 16 / 9, category: 'general' },
  { id: '21:9', name: '21:9 Ultrawide', ratio: 21 / 9, category: 'general' },
  { id: '9:16', name: '9:16 Portrait', ratio: 9 / 16, category: 'general' },
  { id: '3:4', name: '3:4 Portrait', ratio: 3 / 4, category: 'general' },
];

// Output aspect ratios for export (includes social media presets)
export interface OutputAspectRatio {
  id: string;
  name: string;
  ratio: number | null; // null = auto (match screenshot)
  icon?: string; // emoji or icon identifier
}

export const OUTPUT_ASPECT_RATIOS: OutputAspectRatio[] = [
  // Auto - maintains original screenshot aspect ratio
  { id: 'auto', name: 'Auto', ratio: null, icon: '📐' },

  // Common social media ratios
  { id: '1:1', name: '1:1 Square', ratio: 1, icon: '⬜' },
  { id: '4:5', name: '4:5 Instagram', ratio: 4 / 5, icon: '📸' },
  { id: '9:16', name: '9:16 Stories', ratio: 9 / 16, icon: '📱' },
  { id: '16:9', name: '16:9 YouTube', ratio: 16 / 9, icon: '🎬' },
  { id: '2:1', name: '2:1 Twitter', ratio: 2, icon: '🐦' },
  { id: '1.91:1', name: '1.91:1 Facebook', ratio: 1.91, icon: '👤' },
  { id: '3:4', name: '3:4 Pinterest', ratio: 3 / 4, icon: '📌' },
];
</file>

<file path="src/hooks/use-image.ts">
// useImage hook - Load and track image loading status

import { useState, useEffect, useRef } from 'react';

type ImageStatus = 'loading' | 'loaded' | 'error';

export function useImage(url: string): [HTMLImageElement | null, ImageStatus] {
  const [image, setImage] = useState<HTMLImageElement | null>(null);
  const [status, setStatus] = useState<ImageStatus>('loading');
  // Track the URL we're currently loading to prevent stale updates
  const currentUrlRef = useRef<string>('');

  useEffect(() => {
    if (!url) {
      setImage(null);
      setStatus('loading');
      currentUrlRef.current = '';
      return;
    }

    // Track current URL to detect stale callbacks
    currentUrlRef.current = url;
    setStatus('loading');

    const img = new Image();
    // Store URL at time of creation for comparison in callbacks
    const loadingUrl = url;

    img.onload = () => {
      // Only update if this is still the current URL (not stale)
      if (currentUrlRef.current === loadingUrl) {
        setImage(img);
        setStatus('loaded');
      }
    };

    img.onerror = () => {
      // Only update if this is still the current URL (not stale)
      if (currentUrlRef.current === loadingUrl) {
        setImage(null);
        setStatus('error');
      }
    };

    img.src = url;

    return () => {
      img.onload = null;
      img.onerror = null;
    };
  }, [url]);

  return [image, status];
}
</file>

<file path="src/hooks/use-sync-shortcuts.ts">
// useSyncShortcuts - Sync frontend hotkey settings with Rust backend on startup

import { useEffect, useCallback, useState } from 'react';
import { useSettingsStore } from '../stores/settings-store';
import { updateShortcuts } from '../utils/screenshot-api';

interface UseSyncShortcutsReturn {
  syncErrors: string[];
}

/**
 * Syncs hotkey settings from localStorage to Rust backend on app startup.
 * This ensures global shortcuts match user's saved preferences.
 */
export function useSyncShortcuts(): UseSyncShortcutsReturn {
  const { hotkeys } = useSettingsStore();
  const [syncErrors, setSyncErrors] = useState<string[]>([]);

  const syncShortcuts = useCallback(async () => {
    try {
      const errors = await updateShortcuts(
        hotkeys.capture,
        hotkeys.captureRegion,
        hotkeys.captureWindow
      );
      setSyncErrors(errors);
    } catch (e) {
      console.error('Failed to sync shortcuts:', e);
      setSyncErrors([String(e)]);
    }
  }, [hotkeys.capture, hotkeys.captureRegion, hotkeys.captureWindow]);

  useEffect(() => {
    syncShortcuts();
  }, [syncShortcuts]);

  return { syncErrors };
}
</file>

<file path="src/stores/__tests__/crop-store.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useCropStore, type CropRect } from '../crop-store';

describe('Crop Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useCropStore.setState({
      isCropping: false,
      cropRect: null,
      aspectRatio: null,
    });
  });

  describe('Initial State', () => {
    it('should have cropping disabled by default', () => {
      const state = useCropStore.getState();
      expect(state.isCropping).toBe(false);
    });

    it('should have no crop rect initially', () => {
      const state = useCropStore.getState();
      expect(state.cropRect).toBeNull();
    });

    it('should have no aspect ratio initially', () => {
      const state = useCropStore.getState();
      expect(state.aspectRatio).toBeNull();
    });
  });

  describe('startCrop', () => {
    it('should enable cropping', () => {
      useCropStore.getState().startCrop();
      expect(useCropStore.getState().isCropping).toBe(true);
    });

    it('should clear previous crop rect when starting new crop', () => {
      useCropStore.setState({
        cropRect: { x: 10, y: 10, width: 100, height: 100 },
      });
      expect(useCropStore.getState().cropRect).not.toBeNull();

      useCropStore.getState().startCrop();
      expect(useCropStore.getState().cropRect).toBeNull();
    });

    it('should set aspect ratio when provided', () => {
      useCropStore.getState().startCrop(1); // 1:1 square
      expect(useCropStore.getState().aspectRatio).toBe(1);
    });

    it('should set aspect ratio to null for freeform', () => {
      useCropStore.getState().startCrop(16 / 9);
      useCropStore.getState().startCrop(null); // Freeform
      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should handle default parameter (no ratio)', () => {
      useCropStore.getState().startCrop();
      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should accept common aspect ratios', () => {
      const ratios = [1, 4 / 3, 3 / 2, 16 / 9, 21 / 9, 9 / 16, 3 / 4];

      ratios.forEach(ratio => {
        useCropStore.getState().startCrop(ratio);
        expect(useCropStore.getState().aspectRatio).toBe(ratio);
      });
    });
  });

  describe('setCropRect', () => {
    it('should set crop rectangle', () => {
      const rect: CropRect = { x: 10, y: 20, width: 100, height: 150 };
      useCropStore.getState().setCropRect(rect);

      const state = useCropStore.getState();
      expect(state.cropRect).toEqual(rect);
    });

    it('should update crop rect preserving all values', () => {
      const rect: CropRect = { x: 50, y: 75, width: 200, height: 300 };
      useCropStore.getState().setCropRect(rect);

      const cropRect = useCropStore.getState().cropRect;
      expect(cropRect?.x).toBe(50);
      expect(cropRect?.y).toBe(75);
      expect(cropRect?.width).toBe(200);
      expect(cropRect?.height).toBe(300);
    });

    it('should replace previous crop rect', () => {
      const rect1: CropRect = { x: 10, y: 10, width: 100, height: 100 };
      const rect2: CropRect = { x: 50, y: 50, width: 200, height: 200 };

      useCropStore.getState().setCropRect(rect1);
      expect(useCropStore.getState().cropRect).toEqual(rect1);

      useCropStore.getState().setCropRect(rect2);
      expect(useCropStore.getState().cropRect).toEqual(rect2);
    });

    it('should accept zero values', () => {
      const rect: CropRect = { x: 0, y: 0, width: 100, height: 100 };
      useCropStore.getState().setCropRect(rect);

      const cropRect = useCropStore.getState().cropRect;
      expect(cropRect?.x).toBe(0);
      expect(cropRect?.y).toBe(0);
    });

    it('should accept decimal values', () => {
      const rect: CropRect = { x: 10.5, y: 20.3, width: 100.7, height: 150.2 };
      useCropStore.getState().setCropRect(rect);

      const cropRect = useCropStore.getState().cropRect;
      expect(cropRect?.x).toBe(10.5);
      expect(cropRect?.y).toBe(20.3);
      expect(cropRect?.width).toBe(100.7);
      expect(cropRect?.height).toBe(150.2);
    });
  });

  describe('applyCrop', () => {
    it('should disable cropping when applied', () => {
      useCropStore.getState().startCrop();
      expect(useCropStore.getState().isCropping).toBe(true);

      useCropStore.getState().applyCrop();
      expect(useCropStore.getState().isCropping).toBe(false);
    });

    it('should clear crop rect when applied (image dimensions change)', () => {
      const rect: CropRect = { x: 10, y: 10, width: 100, height: 100 };
      useCropStore.getState().startCrop();
      useCropStore.getState().setCropRect(rect);

      useCropStore.getState().applyCrop();

      expect(useCropStore.getState().cropRect).toBeNull();
    });

    it('should clear aspect ratio when applied (fresh state for new image)', () => {
      useCropStore.getState().startCrop(16 / 9);
      useCropStore.getState().applyCrop();

      expect(useCropStore.getState().aspectRatio).toBeNull();
    });
  });

  describe('cancelCrop', () => {
    it('should disable cropping', () => {
      useCropStore.getState().startCrop();
      useCropStore.getState().cancelCrop();

      expect(useCropStore.getState().isCropping).toBe(false);
    });

    it('should clear crop rect', () => {
      useCropStore.getState().startCrop();
      useCropStore.getState().setCropRect({ x: 10, y: 10, width: 100, height: 100 });

      useCropStore.getState().cancelCrop();

      expect(useCropStore.getState().cropRect).toBeNull();
    });

    it('should clear aspect ratio when canceled (fresh state)', () => {
      useCropStore.getState().startCrop(1);
      useCropStore.getState().setCropRect({ x: 10, y: 10, width: 100, height: 100 });

      useCropStore.getState().cancelCrop();

      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should clear aspect ratio on cancel for fresh next session', () => {
      useCropStore.getState().setAspectRatio(16 / 9);
      useCropStore.getState().startCrop(1);
      useCropStore.getState().cancelCrop();

      expect(useCropStore.getState().aspectRatio).toBeNull();
    });
  });

  describe('setAspectRatio', () => {
    it('should set aspect ratio', () => {
      useCropStore.getState().setAspectRatio(16 / 9);
      expect(useCropStore.getState().aspectRatio).toBe(16 / 9);
    });

    it('should set aspect ratio to null for freeform', () => {
      useCropStore.getState().setAspectRatio(1);
      useCropStore.getState().setAspectRatio(null);

      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should replace previous aspect ratio', () => {
      useCropStore.getState().setAspectRatio(4 / 3);
      expect(useCropStore.getState().aspectRatio).toBe(4 / 3);

      useCropStore.getState().setAspectRatio(16 / 9);
      expect(useCropStore.getState().aspectRatio).toBe(16 / 9);
    });

    it('should not affect cropping state', () => {
      useCropStore.getState().startCrop();
      useCropStore.getState().setAspectRatio(1);

      expect(useCropStore.getState().isCropping).toBe(true);
    });

    it('should not affect crop rect', () => {
      const rect: CropRect = { x: 10, y: 10, width: 100, height: 100 };
      useCropStore.getState().setCropRect(rect);

      useCropStore.getState().setAspectRatio(16 / 9);

      expect(useCropStore.getState().cropRect).toEqual(rect);
    });

    it('should accept common aspect ratios', () => {
      const ratios = [1, 4 / 3, 3 / 2, 16 / 9, 21 / 9, 9 / 16, 3 / 4];

      ratios.forEach(ratio => {
        useCropStore.getState().setAspectRatio(ratio);
        expect(useCropStore.getState().aspectRatio).toBe(ratio);
      });
    });
  });

  describe('Crop Workflow', () => {
    it('should handle complete crop workflow', () => {
      // Start crop with aspect ratio
      useCropStore.getState().startCrop(16 / 9);
      expect(useCropStore.getState().isCropping).toBe(true);
      expect(useCropStore.getState().aspectRatio).toBe(16 / 9);

      // Set crop rect
      const rect: CropRect = { x: 10, y: 20, width: 800, height: 450 };
      useCropStore.getState().setCropRect(rect);
      expect(useCropStore.getState().cropRect).toEqual(rect);

      // Apply crop - state cleared for new image dimensions
      useCropStore.getState().applyCrop();
      expect(useCropStore.getState().isCropping).toBe(false);
      expect(useCropStore.getState().cropRect).toBeNull();
      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should handle cancel workflow', () => {
      // Start crop
      useCropStore.getState().startCrop(1);
      useCropStore.getState().setCropRect({ x: 5, y: 5, width: 100, height: 100 });

      // Cancel crop - state cleared for fresh next session
      useCropStore.getState().cancelCrop();

      expect(useCropStore.getState().isCropping).toBe(false);
      expect(useCropStore.getState().cropRect).toBeNull();
      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should support changing aspect ratio mid-crop', () => {
      useCropStore.getState().startCrop(1);
      expect(useCropStore.getState().aspectRatio).toBe(1);

      useCropStore.getState().setAspectRatio(16 / 9);
      expect(useCropStore.getState().aspectRatio).toBe(16 / 9);

      useCropStore.getState().setAspectRatio(null);
      expect(useCropStore.getState().aspectRatio).toBeNull();
    });

    it('should allow starting new crop after applying', () => {
      // First crop
      useCropStore.getState().startCrop(1);
      useCropStore.getState().setCropRect({ x: 0, y: 0, width: 100, height: 100 });
      useCropStore.getState().applyCrop();

      // Second crop
      useCropStore.getState().startCrop(16 / 9);
      expect(useCropStore.getState().isCropping).toBe(true);
      expect(useCropStore.getState().cropRect).toBeNull(); // Cleared
      expect(useCropStore.getState().aspectRatio).toBe(16 / 9);
    });
  });
});
</file>

<file path="src/stores/__tests__/export-store.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useExportStore } from '../export-store';

describe('Export Store', () => {
  beforeEach(() => {
    // Reset store before each test (including transient state)
    useExportStore.setState({
      format: 'png',
      quality: 0.9,
      pixelRatio: 1,
      outputAspectRatio: 'auto',
      autoName: true,
      lastSavePath: null,
      isExporting: false,
      exportOperation: 'idle',
    });
  });

  describe('Initial State', () => {
    it('should have default PNG format', () => {
      const state = useExportStore.getState();
      expect(state.format).toBe('png');
    });

    it('should have default quality of 0.9', () => {
      const state = useExportStore.getState();
      expect(state.quality).toBe(0.9);
    });

    it('should have default pixelRatio of 1', () => {
      const state = useExportStore.getState();
      expect(state.pixelRatio).toBe(1);
    });

    it('should have autoName enabled by default', () => {
      const state = useExportStore.getState();
      expect(state.autoName).toBe(true);
    });

    it('should have null lastSavePath initially', () => {
      const state = useExportStore.getState();
      expect(state.lastSavePath).toBeNull();
    });

    it('should have default outputAspectRatio of auto', () => {
      const state = useExportStore.getState();
      expect(state.outputAspectRatio).toBe('auto');
    });
  });

  describe('setFormat', () => {
    it('should set format to png', () => {
      useExportStore.getState().setFormat('png');
      expect(useExportStore.getState().format).toBe('png');
    });

    it('should set format to jpeg', () => {
      useExportStore.getState().setFormat('jpeg');
      expect(useExportStore.getState().format).toBe('jpeg');
    });

    it('should replace previous format', () => {
      useExportStore.getState().setFormat('jpeg');
      expect(useExportStore.getState().format).toBe('jpeg');

      useExportStore.getState().setFormat('png');
      expect(useExportStore.getState().format).toBe('png');
    });
  });

  describe('setQuality', () => {
    it('should set quality value', () => {
      useExportStore.getState().setQuality(0.85);
      expect(useExportStore.getState().quality).toBe(0.85);
    });

    it('should clamp quality to minimum 0.1', () => {
      useExportStore.getState().setQuality(0.05);
      expect(useExportStore.getState().quality).toBe(0.1);
    });

    it('should clamp quality to maximum 1.0', () => {
      useExportStore.getState().setQuality(1.5);
      expect(useExportStore.getState().quality).toBe(1);
    });

    it('should accept valid quality values', () => {
      const validValues = [0.1, 0.25, 0.5, 0.75, 0.9, 1];

      validValues.forEach(value => {
        useExportStore.getState().setQuality(value);
        expect(useExportStore.getState().quality).toBe(value);
      });
    });

    it('should handle edge case: minimum', () => {
      useExportStore.getState().setQuality(0.1);
      expect(useExportStore.getState().quality).toBe(0.1);
    });

    it('should handle edge case: maximum', () => {
      useExportStore.getState().setQuality(1);
      expect(useExportStore.getState().quality).toBe(1);
    });
  });

  describe('setPixelRatio', () => {
    it('should set pixelRatio to 1', () => {
      useExportStore.getState().setPixelRatio(1);
      expect(useExportStore.getState().pixelRatio).toBe(1);
    });

    it('should set pixelRatio to 2', () => {
      useExportStore.getState().setPixelRatio(2);
      expect(useExportStore.getState().pixelRatio).toBe(2);
    });

    it('should set pixelRatio to 3', () => {
      useExportStore.getState().setPixelRatio(3);
      expect(useExportStore.getState().pixelRatio).toBe(3);
    });

    it('should clamp pixelRatio to minimum 1', () => {
      useExportStore.getState().setPixelRatio(0);
      expect(useExportStore.getState().pixelRatio).toBe(1);
    });

    it('should clamp pixelRatio to maximum 3', () => {
      useExportStore.getState().setPixelRatio(5);
      expect(useExportStore.getState().pixelRatio).toBe(3);
    });

    it('should accept all valid resolution ratios', () => {
      const validRatios = [1, 2, 3];

      validRatios.forEach(ratio => {
        useExportStore.getState().setPixelRatio(ratio);
        expect(useExportStore.getState().pixelRatio).toBe(ratio);
      });
    });
  });

  describe('setOutputAspectRatio', () => {
    it('should set output aspect ratio to auto', () => {
      useExportStore.getState().setOutputAspectRatio('auto');
      expect(useExportStore.getState().outputAspectRatio).toBe('auto');
    });

    it('should set output aspect ratio to 1:1', () => {
      useExportStore.getState().setOutputAspectRatio('1:1');
      expect(useExportStore.getState().outputAspectRatio).toBe('1:1');
    });

    it('should set output aspect ratio to 16:9', () => {
      useExportStore.getState().setOutputAspectRatio('16:9');
      expect(useExportStore.getState().outputAspectRatio).toBe('16:9');
    });

    it('should set social media aspect ratios', () => {
      const socialRatios = ['4:5', '9:16', '2:1', '1.91:1', '3:4'];

      socialRatios.forEach((ratio) => {
        useExportStore.getState().setOutputAspectRatio(ratio);
        expect(useExportStore.getState().outputAspectRatio).toBe(ratio);
      });
    });

    it('should replace previous output aspect ratio', () => {
      useExportStore.getState().setOutputAspectRatio('1:1');
      expect(useExportStore.getState().outputAspectRatio).toBe('1:1');

      useExportStore.getState().setOutputAspectRatio('16:9');
      expect(useExportStore.getState().outputAspectRatio).toBe('16:9');
    });
  });

  describe('setAutoName', () => {
    it('should enable autoName', () => {
      useExportStore.getState().setAutoName(true);
      expect(useExportStore.getState().autoName).toBe(true);
    });

    it('should disable autoName', () => {
      useExportStore.getState().setAutoName(false);
      expect(useExportStore.getState().autoName).toBe(false);
    });

    it('should toggle autoName', () => {
      useExportStore.getState().setAutoName(false);
      expect(useExportStore.getState().autoName).toBe(false);

      useExportStore.getState().setAutoName(true);
      expect(useExportStore.getState().autoName).toBe(true);
    });
  });

  describe('setLastSavePath', () => {
    it('should set lastSavePath', () => {
      const path = '/Users/test/Pictures/BeautyShot/image.png';
      useExportStore.getState().setLastSavePath(path);
      expect(useExportStore.getState().lastSavePath).toBe(path);
    });

    it('should replace previous lastSavePath', () => {
      const path1 = '/path/to/image1.png';
      const path2 = '/path/to/image2.jpeg';

      useExportStore.getState().setLastSavePath(path1);
      expect(useExportStore.getState().lastSavePath).toBe(path1);

      useExportStore.getState().setLastSavePath(path2);
      expect(useExportStore.getState().lastSavePath).toBe(path2);
    });

    it('should handle windows paths', () => {
      const windowsPath = 'C:\\Users\\test\\Pictures\\image.png';
      useExportStore.getState().setLastSavePath(windowsPath);
      expect(useExportStore.getState().lastSavePath).toBe(windowsPath);
    });
  });

  describe('Combined Actions', () => {
    it('should allow setting all properties independently', () => {
      useExportStore.getState().setFormat('jpeg');
      useExportStore.getState().setQuality(0.8);
      useExportStore.getState().setPixelRatio(2);
      useExportStore.getState().setOutputAspectRatio('16:9');
      useExportStore.getState().setAutoName(false);
      useExportStore.getState().setLastSavePath('/test/path.jpeg');

      const state = useExportStore.getState();
      expect(state.format).toBe('jpeg');
      expect(state.quality).toBe(0.8);
      expect(state.pixelRatio).toBe(2);
      expect(state.outputAspectRatio).toBe('16:9');
      expect(state.autoName).toBe(false);
      expect(state.lastSavePath).toBe('/test/path.jpeg');
    });

    it('should preserve other values when updating one', () => {
      const originalPath = '/original/path.png';

      useExportStore.getState().setLastSavePath(originalPath);
      useExportStore.getState().setFormat('jpeg');

      const state = useExportStore.getState();
      expect(state.lastSavePath).toBe(originalPath);
      expect(state.quality).toBe(0.9); // Unchanged
      expect(state.pixelRatio).toBe(1); // Unchanged
    });
  });

  describe('Type Safety', () => {
    it('should only accept valid export formats', () => {
      useExportStore.getState().setFormat('png');
      expect(useExportStore.getState().format).toBe('png');

      useExportStore.getState().setFormat('jpeg');
      expect(useExportStore.getState().format).toBe('jpeg');
    });

    it('should have proper bounds for numeric values', () => {
      // Quality bounds
      useExportStore.getState().setQuality(0);
      expect(useExportStore.getState().quality).toBeGreaterThanOrEqual(0.1);

      useExportStore.getState().setQuality(2);
      expect(useExportStore.getState().quality).toBeLessThanOrEqual(1);

      // PixelRatio bounds
      useExportStore.getState().setPixelRatio(-1);
      expect(useExportStore.getState().pixelRatio).toBeGreaterThanOrEqual(1);

      useExportStore.getState().setPixelRatio(10);
      expect(useExportStore.getState().pixelRatio).toBeLessThanOrEqual(3);
    });
  });

  describe('Export State (Transient)', () => {
    it('should have idle export state by default', () => {
      const state = useExportStore.getState();
      expect(state.isExporting).toBe(false);
      expect(state.exportOperation).toBe('idle');
    });

    it('should set isExporting to true when startExport is called', () => {
      useExportStore.getState().startExport('quickSave');
      const state = useExportStore.getState();
      expect(state.isExporting).toBe(true);
      expect(state.exportOperation).toBe('quickSave');
    });

    it('should reset to idle when finishExport is called', () => {
      useExportStore.getState().startExport('saveAs');
      useExportStore.getState().finishExport();
      const state = useExportStore.getState();
      expect(state.isExporting).toBe(false);
      expect(state.exportOperation).toBe('idle');
    });

    it('should handle clipboard operation', () => {
      useExportStore.getState().startExport('clipboard');
      expect(useExportStore.getState().exportOperation).toBe('clipboard');
    });

    it('should handle all export operation types', () => {
      const operations = ['quickSave', 'saveAs', 'clipboard'] as const;

      operations.forEach((op) => {
        useExportStore.getState().startExport(op);
        expect(useExportStore.getState().exportOperation).toBe(op);
        useExportStore.getState().finishExport();
      });
    });

    it('should not affect persisted state when modifying export state', () => {
      useExportStore.getState().setFormat('jpeg');
      useExportStore.getState().setQuality(0.7);

      useExportStore.getState().startExport('quickSave');

      const state = useExportStore.getState();
      expect(state.format).toBe('jpeg');
      expect(state.quality).toBe(0.7);
      expect(state.isExporting).toBe(true);
    });
  });
});
</file>

<file path="src/stores/__tests__/settings-store.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useSettingsStore, isValidHotkey } from '../settings-store';

describe('Settings Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useSettingsStore.setState({
      hotkeys: {
        capture: 'CommandOrControl+Shift+C',
        captureRegion: 'CommandOrControl+Shift+R',
        captureWindow: 'CommandOrControl+Shift+W',
        save: 'CommandOrControl+S',
        copy: 'CommandOrControl+Shift+V',
      },
      startMinimized: false,
      closeToTray: true,
      showNotifications: true,
      saveLocation: 'pictures',
      customSavePath: null,
    });
  });

  describe('Initial State', () => {
    it('should have default hotkeys', () => {
      const state = useSettingsStore.getState();
      expect(state.hotkeys.capture).toBe('CommandOrControl+Shift+C');
      expect(state.hotkeys.save).toBe('CommandOrControl+S');
    });

    it('should have closeToTray enabled by default', () => {
      const state = useSettingsStore.getState();
      expect(state.closeToTray).toBe(true);
    });

    it('should have showNotifications enabled by default', () => {
      const state = useSettingsStore.getState();
      expect(state.showNotifications).toBe(true);
    });

    it('should have startMinimized disabled by default', () => {
      const state = useSettingsStore.getState();
      expect(state.startMinimized).toBe(false);
    });

    it('should have pictures as default save location', () => {
      const state = useSettingsStore.getState();
      expect(state.saveLocation).toBe('pictures');
    });

    it('should have null customSavePath by default', () => {
      const state = useSettingsStore.getState();
      expect(state.customSavePath).toBeNull();
    });
  });

  describe('setHotkey', () => {
    it('should update capture hotkey', () => {
      useSettingsStore.getState().setHotkey('capture', 'Alt+C');
      expect(useSettingsStore.getState().hotkeys.capture).toBe('Alt+C');
    });

    it('should update save hotkey', () => {
      useSettingsStore.getState().setHotkey('save', 'CommandOrControl+Shift+S');
      expect(useSettingsStore.getState().hotkeys.save).toBe('CommandOrControl+Shift+S');
    });

    it('should preserve other hotkeys when updating one', () => {
      const originalCopy = useSettingsStore.getState().hotkeys.copy;
      useSettingsStore.getState().setHotkey('capture', 'Alt+X');
      expect(useSettingsStore.getState().hotkeys.copy).toBe(originalCopy);
    });
  });

  describe('Behavior Settings', () => {
    it('should toggle startMinimized', () => {
      useSettingsStore.getState().setStartMinimized(true);
      expect(useSettingsStore.getState().startMinimized).toBe(true);

      useSettingsStore.getState().setStartMinimized(false);
      expect(useSettingsStore.getState().startMinimized).toBe(false);
    });

    it('should toggle closeToTray', () => {
      useSettingsStore.getState().setCloseToTray(false);
      expect(useSettingsStore.getState().closeToTray).toBe(false);

      useSettingsStore.getState().setCloseToTray(true);
      expect(useSettingsStore.getState().closeToTray).toBe(true);
    });

    it('should toggle showNotifications', () => {
      useSettingsStore.getState().setShowNotifications(false);
      expect(useSettingsStore.getState().showNotifications).toBe(false);

      useSettingsStore.getState().setShowNotifications(true);
      expect(useSettingsStore.getState().showNotifications).toBe(true);
    });
  });

  describe('Save Location', () => {
    it('should set save location to desktop', () => {
      useSettingsStore.getState().setSaveLocation('desktop');
      expect(useSettingsStore.getState().saveLocation).toBe('desktop');
    });

    it('should set save location to custom', () => {
      useSettingsStore.getState().setSaveLocation('custom');
      expect(useSettingsStore.getState().saveLocation).toBe('custom');
    });

    it('should set custom save path', () => {
      const customPath = '/Users/test/Screenshots';
      useSettingsStore.getState().setCustomSavePath(customPath);
      expect(useSettingsStore.getState().customSavePath).toBe(customPath);
    });

    it('should clear custom save path with null', () => {
      useSettingsStore.getState().setCustomSavePath('/some/path');
      useSettingsStore.getState().setCustomSavePath(null);
      expect(useSettingsStore.getState().customSavePath).toBeNull();
    });
  });

  describe('resetToDefaults', () => {
    it('should reset all settings to defaults', () => {
      // Modify some settings
      useSettingsStore.getState().setHotkey('capture', 'Alt+X');
      useSettingsStore.getState().setCloseToTray(false);
      useSettingsStore.getState().setSaveLocation('custom');
      useSettingsStore.getState().setCustomSavePath('/custom/path');

      // Reset
      useSettingsStore.getState().resetToDefaults();

      const state = useSettingsStore.getState();
      // Check reset to actual DEFAULT_HOTKEYS from settings-store.ts
      expect(state.hotkeys.capture).toBe('CommandOrControl+Option+1');
      expect(state.closeToTray).toBe(true);
      expect(state.saveLocation).toBe('pictures');
      expect(state.customSavePath).toBeNull();
    });
  });

  describe('Combined Actions', () => {
    it('should allow updating multiple settings independently', () => {
      useSettingsStore.getState().setHotkey('capture', 'Alt+C');
      useSettingsStore.getState().setCloseToTray(false);
      useSettingsStore.getState().setSaveLocation('desktop');

      const state = useSettingsStore.getState();
      expect(state.hotkeys.capture).toBe('Alt+C');
      expect(state.closeToTray).toBe(false);
      expect(state.saveLocation).toBe('desktop');
    });
  });

  describe('Hotkey Validation', () => {
    it('should reject hotkeys without modifiers', () => {
      const original = useSettingsStore.getState().hotkeys.capture;
      useSettingsStore.getState().setHotkey('capture', 'C');
      // Should not change because invalid
      expect(useSettingsStore.getState().hotkeys.capture).toBe(original);
    });

    it('should reject invalid key names', () => {
      const original = useSettingsStore.getState().hotkeys.capture;
      useSettingsStore.getState().setHotkey('capture', 'Ctrl+InvalidKey');
      expect(useSettingsStore.getState().hotkeys.capture).toBe(original);
    });

    it('should accept valid hotkey combinations', () => {
      useSettingsStore.getState().setHotkey('capture', 'Alt+Shift+X');
      expect(useSettingsStore.getState().hotkeys.capture).toBe('Alt+Shift+X');
    });

    it('should allow empty string to clear hotkey', () => {
      useSettingsStore.getState().setHotkey('capture', '');
      expect(useSettingsStore.getState().hotkeys.capture).toBe('');
    });
  });
});

describe('isValidHotkey', () => {
  it('should return true for valid hotkeys', () => {
    expect(isValidHotkey('CommandOrControl+Shift+C')).toBe(true);
    expect(isValidHotkey('Alt+S')).toBe(true);
    expect(isValidHotkey('Ctrl+Shift+F1')).toBe(true);
    expect(isValidHotkey('Meta+Space')).toBe(true);
  });

  it('should return false for hotkeys without modifiers', () => {
    expect(isValidHotkey('C')).toBe(false);
    expect(isValidHotkey('F1')).toBe(false);
  });

  it('should return false for invalid modifiers', () => {
    expect(isValidHotkey('NotAModifier+C')).toBe(false);
  });

  it('should return false for invalid keys', () => {
    expect(isValidHotkey('Ctrl+NotAKey')).toBe(false);
    expect(isValidHotkey('Alt+@')).toBe(false);
  });

  it('should return false for empty or null input', () => {
    expect(isValidHotkey('')).toBe(false);
    // @ts-expect-error testing invalid input
    expect(isValidHotkey(null)).toBe(false);
    // @ts-expect-error testing invalid input
    expect(isValidHotkey(undefined)).toBe(false);
  });

  it('should be case-insensitive for validation', () => {
    expect(isValidHotkey('ctrl+shift+c')).toBe(true);
    expect(isValidHotkey('CTRL+SHIFT+C')).toBe(true);
  });
});
</file>

<file path="src/stores/export-store.ts">
// Export store - Zustand state for export settings with persistence

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export type ExportFormat = 'png' | 'jpeg';

export type ExportOperation = 'idle' | 'quickSave' | 'saveAs' | 'clipboard';

interface ExportState {
  // Persisted settings
  format: ExportFormat;
  quality: number; // 0.1 - 1.0 for JPEG
  pixelRatio: number; // 1, 2, 3 for resolution
  outputAspectRatio: string; // 'auto' or aspect ratio id like '1:1', '16:9'
  autoName: boolean;
  lastSavePath: string | null;

  // Transient UI state (not persisted)
  isExporting: boolean;
  exportOperation: ExportOperation;

  // Settings actions
  setFormat: (format: ExportFormat) => void;
  setQuality: (quality: number) => void;
  setPixelRatio: (ratio: number) => void;
  setOutputAspectRatio: (ratio: string) => void;
  setAutoName: (auto: boolean) => void;
  setLastSavePath: (path: string) => void;

  // Export state actions
  startExport: (operation: ExportOperation) => void;
  finishExport: () => void;
}

export const useExportStore = create<ExportState>()(
  persist(
    (set) => ({
      format: 'png',
      quality: 0.9,
      pixelRatio: 1,
      outputAspectRatio: 'auto', // Default to auto (match screenshot)
      autoName: true,
      lastSavePath: null,

      // Transient state
      isExporting: false,
      exportOperation: 'idle',

      setFormat: (format) => set({ format }),
      setQuality: (quality) =>
        set({ quality: Math.max(0.1, Math.min(1, quality)) }),
      setPixelRatio: (ratio) =>
        set({ pixelRatio: Math.max(1, Math.min(3, ratio)) }),
      setOutputAspectRatio: (ratio) => set({ outputAspectRatio: ratio }),
      setAutoName: (auto) => set({ autoName: auto }),
      setLastSavePath: (path) => set({ lastSavePath: path }),

      startExport: (operation) =>
        set({ isExporting: true, exportOperation: operation }),
      finishExport: () =>
        set({ isExporting: false, exportOperation: 'idle' }),
    }),
    {
      name: 'beautyshot-export-settings',
      // Exclude transient state from persistence
      partialize: (state) => ({
        format: state.format,
        quality: state.quality,
        pixelRatio: state.pixelRatio,
        outputAspectRatio: state.outputAspectRatio,
        autoName: state.autoName,
        lastSavePath: state.lastSavePath,
      }),
    }
  )
);
</file>

<file path="src/stores/history-store.ts">
// History store - Undo/redo functionality for annotations and canvas
// Tracks snapshots of annotation and image state for history navigation

import { create } from 'zustand';
import type { Annotation } from '../types/annotations';

// Image state snapshot for undo/redo
export interface ImageSnapshot {
  imageBytes: Uint8Array | null;
  originalWidth: number;
  originalHeight: number;
}

// Snapshot of state that can be undone/redone
export interface HistorySnapshot {
  annotations: Annotation[];
  image?: ImageSnapshot; // Optional - only included when image changes
}

interface HistoryState {
  past: HistorySnapshot[];
  future: HistorySnapshot[];
  maxHistory: number;

  // Actions
  pushState: (snapshot: HistorySnapshot) => void;
  undo: () => HistorySnapshot | null;
  redo: () => HistorySnapshot | null;
  canUndo: () => boolean;
  canRedo: () => boolean;
  clear: () => void;
}

const MAX_HISTORY = 50;

export const useHistoryStore = create<HistoryState>((set, get) => ({
  past: [],
  future: [],
  maxHistory: MAX_HISTORY,

  pushState: (snapshot) => {
    set((state) => {
      const newPast = [...state.past, snapshot];
      // Trim history if exceeds max
      if (newPast.length > state.maxHistory) {
        newPast.shift();
      }
      return {
        past: newPast,
        future: [], // Clear redo stack on new action
      };
    });
  },

  undo: () => {
    const { past } = get();
    if (past.length === 0) return null;

    const previous = past[past.length - 1];
    set((state) => ({
      past: state.past.slice(0, -1),
      future: state.future, // Will be updated by caller with current state
    }));
    return previous;
  },

  redo: () => {
    const { future } = get();
    if (future.length === 0) return null;

    const next = future[future.length - 1];
    set((state) => ({
      future: state.future.slice(0, -1),
      past: state.past, // Will be updated by caller with current state
    }));
    return next;
  },

  canUndo: () => get().past.length > 0,
  canRedo: () => get().future.length > 0,

  clear: () => set({ past: [], future: [] }),
}));

// Helper to push current state to future (for undo operation)
export function pushToFuture(snapshot: HistorySnapshot) {
  useHistoryStore.setState((state) => ({
    future: [...state.future, snapshot],
  }));
}

// Helper to push current state to past (for redo operation)
export function pushToPast(snapshot: HistorySnapshot) {
  useHistoryStore.setState((state) => ({
    past: [...state.past, snapshot],
  }));
}
</file>

<file path="src/utils/file-api.ts">
// File API - TypeScript wrappers for Tauri file operations

import { invoke } from '@tauri-apps/api/core';
import { save } from '@tauri-apps/plugin-dialog';
import type { ExportFormat } from '../stores/export-store';

/**
 * Normalize Windows extended-length path prefix (\\?\)
 * Windows dialog can return paths like \\?\C:\Users\... which need cleanup for display
 */
export function normalizePath(path: string): string {
  // Remove Windows extended-length path prefix
  if (path.startsWith('\\\\?\\')) {
    return path.slice(4);
  }
  return path;
}

/**
 * Extract filename from path (cross-platform)
 */
export function extractFilename(path: string): string {
  // Normalize first to handle \\?\ prefix
  const normalized = normalizePath(path);
  // Handle both Windows (\) and Unix (/) separators
  const parts = normalized.split(/[\\/]/);
  return parts[parts.length - 1] || 'image';
}

/**
 * Save file using Tauri backend
 */
export async function saveFile(
  path: string,
  data: Uint8Array
): Promise<string> {
  return await invoke('save_file', {
    path,
    data: Array.from(data),
  });
}

/**
 * Get Pictures directory with BeautyShot subfolder
 */
export async function getPicturesDir(): Promise<string> {
  return await invoke('get_pictures_dir');
}

/**
 * Get Desktop directory
 */
export async function getDesktopDir(): Promise<string> {
  return await invoke('get_desktop_dir');
}

/**
 * Show native save dialog
 */
export async function showSaveDialog(
  defaultName: string,
  format: ExportFormat
): Promise<string | null> {
  const filters =
    format === 'png'
      ? [{ name: 'PNG Image', extensions: ['png'] }]
      : [{ name: 'JPEG Image', extensions: ['jpg', 'jpeg'] }];

  const path = await save({
    defaultPath: defaultName,
    filters,
  });

  return path;
}
</file>

<file path="src-tauri/src/clipboard.rs">
// Clipboard operations - copy image to system clipboard

use arboard::{Clipboard, ImageData};
use base64::{engine::general_purpose::STANDARD, Engine};
use image::GenericImageView;

// Maximum allowed image size: 50MB (prevents memory DoS attacks)
const MAX_IMAGE_SIZE: usize = 50 * 1024 * 1024;

/// Copy PNG image data to system clipboard
/// Accepts base64-encoded PNG data (without data URL prefix)
#[tauri::command]
pub fn copy_image_to_clipboard(base64_data: &str) -> Result<(), String> {
    // Validate size before decoding (base64 is ~33% larger than binary)
    let estimated_size = base64_data.len() * 3 / 4;
    if estimated_size > MAX_IMAGE_SIZE {
        return Err(format!(
            "Image too large: {} bytes (max {} bytes)",
            estimated_size, MAX_IMAGE_SIZE
        ));
    }

    // Decode base64 to bytes
    let png_bytes = STANDARD
        .decode(base64_data)
        .map_err(|e| format!("Failed to decode base64: {}", e))?;

    // Double-check actual decoded size
    if png_bytes.len() > MAX_IMAGE_SIZE {
        return Err(format!(
            "Decoded image too large: {} bytes (max {} bytes)",
            png_bytes.len(),
            MAX_IMAGE_SIZE
        ));
    }

    // Load image to get dimensions and RGBA data
    let img = image::load_from_memory(&png_bytes)
        .map_err(|e| format!("Failed to load image: {}", e))?;

    let (width, height) = img.dimensions();
    let rgba = img.to_rgba8();

    // Create clipboard image data
    let img_data = ImageData {
        width: width as usize,
        height: height as usize,
        bytes: rgba.into_raw().into(),
    };

    // Copy to clipboard
    let mut clipboard =
        Clipboard::new().map_err(|e| format!("Failed to access clipboard: {}", e))?;

    clipboard
        .set_image(img_data)
        .map_err(|e| format!("Failed to copy to clipboard: {}", e))?;

    Ok(())
}
</file>

<file path="src-tauri/entitlements.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <false/>
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
</dict>
</plist>
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>beautiFULLshot</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="overlay.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Region Selection</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
    }
    #root {
      width: 100%;
      height: 100%;
      visibility: hidden;
    }
    #root.ready {
      visibility: visible;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/overlay-main.tsx"></script>
</body>
</html>
</file>

<file path="docs/code-standards.md">
# BeautyShot - Code Standards & Guidelines

## Overview

This document establishes code quality standards, naming conventions, and best practices for the BeautyShot codebase. All contributions must adhere to these standards to maintain consistency and maintainability.

---

## Directory Structure

```
src/
├── components/                # React components (feature-organized)
│   ├── canvas/               # Canvas layer components
│   │   ├── canvas-editor.tsx
│   │   ├── zoom-controls.tsx
│   │   ├── background-layer.tsx       # Phase 05: Beautification
│   │   ├── crop-overlay.tsx           # Phase 05: Cropping
│   │   ├── annotation-layer.tsx       # Phase 04: Annotations
│   │   └── annotations/               # Phase 04: Annotation shapes
│   │       ├── arrow-shape.tsx
│   │       ├── rect-shape.tsx
│   │       ├── ellipse-shape.tsx
│   │       ├── text-shape.tsx
│   │       └── ...
│   ├── layout/               # Layout components
│   │   └── editor-layout.tsx
│   ├── toolbar/              # Toolbar components
│   │   ├── toolbar.tsx
│   │   ├── tool-buttons.tsx  # Phase 04
│   │   └── tool-settings.tsx # Phase 04
│   ├── sidebar/              # Sidebar panels (Phase 05+)
│   │   ├── sidebar.tsx
│   │   ├── background-panel.tsx       # Phase 05
│   │   └── crop-panel.tsx             # Phase 05
│   └── .gitkeep
├── data/                      # Data constants (Phase 05+)
│   ├── gradients.ts          # Gradient & color presets
│   └── aspect-ratios.ts      # Crop aspect ratio presets
├── hooks/                     # Custom React hooks
│   ├── use-image.ts          # Image loading hook
│   ├── use-screenshot.ts     # Screenshot capture hook
│   ├── use-drawing.ts        # Phase 04: Drawing logic
│   ├── use-keyboard-shortcuts.ts  # Phase 04: Keyboard input
│   └── .gitkeep
├── stores/                    # Zustand state stores
│   ├── canvas-store.ts       # Canvas state management
│   ├── annotation-store.ts   # Phase 04: Annotations
│   ├── background-store.ts   # Phase 05: Background & padding
│   ├── crop-store.ts         # Phase 05: Crop tool
│   └── .gitkeep
├── types/                     # TypeScript type definitions
│   ├── screenshot.ts         # Screenshot-related types
│   ├── annotations.ts        # Phase 04: Annotation types
│   └── .gitkeep
├── utils/                     # Utility functions
│   ├── screenshot-api.ts     # Screenshot API wrapper
│   ├── logger.ts             # Phase 04: Logging utility
│   └── sanitize.ts           # Phase 04: Input sanitization
├── App.tsx                    # Root component
├── main.tsx                   # Entry point
├── styles.css                 # Global styles
└── vite-env.d.ts             # Vite environment types
```

### Organization Rules
- **Components:** One file per component, organized by feature domain
- **Hooks:** Custom hooks grouped by responsibility
- **Stores:** Separate file per store (Zustand)
- **Types:** Centralized type definitions by domain
- **Utils:** Pure functions, no React dependencies

---

## Naming Conventions

### TypeScript Files
- **Components:** PascalCase (e.g., `CanvasEditor.tsx`, `ZoomControls.tsx`)
- **Hooks:** camelCase with `use` prefix (e.g., `useImage.ts`, `useScreenshot.ts`)
- **Stores:** camelCase with suffix (e.g., `canvas-store.ts`)
- **Types:** PascalCase (e.g., `screenshot.ts` contains `WindowInfo`, `ImageData`)
- **Utils:** camelCase (e.g., `screenshot-api.ts`)

### Variables & Functions
- **Constants:** `UPPER_SNAKE_CASE` (e.g., `MAX_SCALE`, `MIN_SCALE`, `ZOOM_FACTOR`)
- **Functions:** `camelCase` (e.g., `captureFullscreen()`, `getImageDimensions()`)
- **Event handlers:** `handle<Action>` (e.g., `handleWheel`, `handleDragEnd`, `handleCaptureFullscreen`)
- **State variables:** `camelCase` (e.g., `imageUrl`, `scale`, `position`)
- **React state setters:** `set<Property>` (e.g., `setImageFromBytes`, `setScale`)

### Class & Interface Names
- **Interfaces:** PascalCase (e.g., `CanvasState`, `WindowInfo`)
- **Type Aliases:** PascalCase (e.g., `ImageStatus`)
- **Enums:** PascalCase (e.g., `CaptureMode`)

### CSS Classes
- **Tailwind utilities:** Use utility-first approach (e.g., `flex-1`, `bg-gray-100`, `px-4`)
- **Custom classes:** kebab-case in CSS modules (if needed)

---

## TypeScript Standards

### Type Safety
- **Strict Mode:** `"strict": true` in `tsconfig.json`
- **No `any`:** Use `unknown` with type narrowing if necessary
- **No implicit `any`:** All function parameters and returns must have explicit types
- **Type Imports:** Use `type` keyword for type-only imports (ES modules optimization)

```typescript
// Good
import type { WindowInfo } from '../../types/screenshot';
import { useCallback } from 'react';

// Avoid
import { WindowInfo } from '../../types/screenshot';
import * as React from 'react';
```

### Function Types
```typescript
// Good: Explicit return type
export function useImage(url: string): [HTMLImageElement | null, ImageStatus] {
  // ...
}

// Good: Event handler type
const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
  // ...
}, [dependencies]);
```

### Generic Types
- Use meaningful type variable names (not just `T`, `U`)
- Document generic constraints when complex

```typescript
// Good
interface Store<TState> {
  getState: () => TState;
  setState: (state: TState) => void;
}
```

---

## React Component Standards

### Component Structure
```typescript
// Good: Clear component structure
import { useState, useCallback } from 'react';
import { useCanvasStore } from '../../stores/canvas-store';
import type { WindowInfo } from '../../types/screenshot';

export function ComponentName() {
  // 1. Hooks
  const { property, action } = useCanvasStore();
  const [local, setLocal] = useState<Type>(initial);

  // 2. Callbacks
  const handleAction = useCallback(() => {
    // ...
  }, [dependencies]);

  // 3. Effects (if needed)
  // useEffect(() => { ... }, [deps]);

  // 4. Render
  return (
    <div className="container">
      {/* JSX */}
    </div>
  );
}
```

### Hook Rules
- Extract logic into custom hooks
- Use `useCallback` for event handlers to prevent re-renders
- Use `useEffect` only when necessary; prefer hooks for state
- Clean up side effects in effect cleanup functions

```typescript
// Good: Custom hook
export function useImage(url: string): [HTMLImageElement | null, ImageStatus] {
  const [image, setImage] = useState<HTMLImageElement | null>(null);
  const [status, setStatus] = useState<ImageStatus>('loading');

  useEffect(() => {
    if (!url) {
      setImage(null);
      return;
    }

    // ... loading logic

    return () => {
      // Cleanup
    };
  }, [url]);

  return [image, status];
}
```

### Props & Interfaces
```typescript
// Good: Explicit props interface
interface CanvasEditorProps {
  imageUrl: string | null;
  onZoom?: (scale: number) => void;
}

export function CanvasEditor({ imageUrl, onZoom }: CanvasEditorProps) {
  // ...
}

// Avoid: Inline props type
export function CanvasEditor(props: any) { }
```

---

## State Management (Zustand)

### Store Structure
```typescript
// Good: Clear store structure with types
import { create } from 'zustand';

interface CanvasState {
  // State properties
  imageUrl: string | null;
  imageBytes: Uint8Array | null;

  // Actions
  setImageFromBytes: (bytes: Uint8Array, width: number, height: number) => void;
  clearCanvas: () => void;
}

export const useCanvasStore = create<CanvasState>((set, get) => ({
  // Initial state
  imageUrl: null,
  imageBytes: null,

  // Actions
  setImageFromBytes: (bytes, width, height) => {
    const oldUrl = get().imageUrl;
    if (oldUrl) URL.revokeObjectURL(oldUrl);
    set({ imageUrl: bytesToUrl(bytes), imageBytes: bytes });
  },

  clearCanvas: () => {
    const oldUrl = get().imageUrl;
    if (oldUrl) URL.revokeObjectURL(oldUrl);
    set({ imageUrl: null, imageBytes: null });
  },
}));
```

### Store Rules
- One file per store
- Group related state and actions together
- Document state properties with JSDoc comments
- Include memory cleanup (URL revocation, event listener cleanup)

---

## Error Handling

### Try-Catch Pattern
```typescript
// Good: Specific error handling
const handleCaptureFullscreen = useCallback(async () => {
  try {
    const bytes = await captureFullscreen();
    if (bytes) {
      const { width, height } = await getImageDimensions(bytes);
      setImageFromBytes(bytes, width, height);
    }
  } catch (e) {
    console.error('Failed to capture fullscreen:', e);
    setError('Screenshot failed. Check permissions.');
  }
}, [captureFullscreen, setImageFromBytes]);
```

### Error Messages
- User-facing: Clear, actionable messages
- Console: Detailed error context with component/function name
- Never silent failures; always log or display

```typescript
// Good error logging
console.error('Failed to get image dimensions:', e);
console.warn('Wayland detected; screenshot may have limitations');

// Avoid
console.log('error');  // Too vague
console.error(e);      // No context
```

---

## CSS & Tailwind Standards

### Tailwind Usage
- Use utility-first approach
- Avoid custom CSS unless necessary
- Use responsive prefixes: `sm:`, `md:`, `lg:`, `xl:`
- Use dark mode classes: `dark:bg-gray-800`

```tsx
// Good
<div className="flex-1 bg-gray-100 hover:bg-gray-200 dark:bg-gray-900">
  <button className="px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:opacity-50">
    Click me
  </button>
</div>

// Avoid
<div style={{ flex: 1, backgroundColor: '#f3f4f6' }}>
  <button style={{ padding: '8px 16px' }}>Click me</button>
</div>
```

### Common Tailwind Classes
| Purpose | Classes |
|---------|---------|
| **Layout** | `flex`, `grid`, `h-screen`, `w-full` |
| **Spacing** | `px-4`, `py-2`, `gap-2`, `m-4` |
| **Colors** | `bg-gray-100`, `text-blue-600`, `border-red-400` |
| **Interactive** | `hover:bg-gray-200`, `disabled:opacity-50` |
| **Responsive** | `md:flex-col`, `lg:px-8` |

---

## Documentation Standards

### Comments
- Use JSDoc for exported functions and components
- Inline comments for non-obvious logic only
- Update comments when code changes

```typescript
/**
 * Load image from URL and track loading status
 * @param url - Image URL to load
 * @returns [image element, loading status]
 */
export function useImage(url: string): [HTMLImageElement | null, ImageStatus] {
  // Implementation
}
```

### File Headers
```typescript
// <Brief description of what this component/function does>
// <Additional context if needed>

import { ... };

// Component/function code
```

### Commit Messages
- Format: `type(scope): description`
- Types: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`
- Scope: feature/component name
- Description: imperative, present tense

```
feat(canvas-editor): implement zoom with mouse wheel
fix(toolbar): prevent multiple captures during loading
docs(code-standards): add type safety guidelines
```

---

## Performance Guidelines

### React Optimization
- Use `useCallback` for event handlers passed to children
- Memoize expensive computations with `useMemo` if needed
- Avoid creating objects/arrays in render

```typescript
// Good: useCallback for event handler
const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
  // ...
}, [scale, position, setScale, setPosition]);

// Bad: Function recreated on every render
const handleWheel = (e: Konva.KonvaEventObject<WheelEvent>) => {
  // ...
};
```

### Memory Management
- Revoke blob URLs when no longer needed
- Clean up event listeners in effect cleanup
- Clear Uint8Array references when replacing images

```typescript
// Good: Memory cleanup
const oldUrl = get().imageUrl;
if (oldUrl) URL.revokeObjectURL(oldUrl);  // Prevent memory leak

useEffect(() => {
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);  // Cleanup
}, []);
```

### Bundle Size
- Tree-shake unused code (ES modules)
- Lazy load heavy libraries if needed
- Use type-only imports for types

---

## Phase 05: Beautification & Cropping Patterns

### Data Constants Pattern
Store preset configurations in `src/data/` files for reusability:

```typescript
// src/data/gradients.ts
export interface GradientPreset {
  id: string;
  name: string;
  colors: string[];
  direction: 'linear' | 'radial';
  angle?: number;
}

export const GRADIENT_PRESETS: GradientPreset[] = [
  { id: 'ocean', name: 'Ocean', colors: ['#667eea', '#764ba2'], direction: 'linear', angle: 135 },
  // ... more presets
];
```

### Zustand Multi-Store Pattern
Multiple stores for independent concerns (background, crop, canvas):

```typescript
// Each store manages isolated feature state
export const useBackgroundStore = create<BackgroundState>((set) => ({
  type: 'gradient',
  gradient: GRADIENT_PRESETS[0],
  solidColor: '#ffffff',
  padding: 40,
  setGradient: (gradient) => set({ type: 'gradient', gradient }),
  setPadding: (padding) => set({ padding: Math.max(0, Math.min(200, padding)) }),
}));

export const useCropStore = create<CropState>((set) => ({
  isCropping: false,
  cropRect: null,
  aspectRatio: null,
  startCrop: (ratio = null) => set({ isCropping: true, aspectRatio: ratio }),
}));
```

### Konva Shape Rendering
Use `Shape` component for custom rendering (gradients, patterns):

```typescript
// Complex gradients with Konva Shape
<Shape
  sceneFunc={(ctx) => {
    const grd = ctx.createLinearGradient(x1, y1, x2, y2);
    gradient.colors.forEach((color, i) => {
      grd.addColorStop(i / (gradient.colors.length - 1), color);
    });
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, width, height);
  }}
  listening={false}
/>
```

### Sidebar Panel Pattern
Encapsulate feature UI in dedicated panel components:

```typescript
// src/components/sidebar/background-panel.tsx
export function BackgroundPanel() {
  const { type, gradient, padding, setGradient, setPadding } = useBackgroundStore();

  return (
    <div className="p-4 border-b">
      {/* Grid of presets */}
      <div className="grid grid-cols-6 gap-2">
        {GRADIENT_PRESETS.map((preset) => (
          <button
            key={preset.id}
            onClick={() => setGradient(preset)}
            className={`w-8 h-8 ${type === 'gradient' && gradient?.id === preset.id ? 'ring-2' : ''}`}
            style={{ background: `linear-gradient(${preset.angle}deg, ${preset.colors.join(', ')})` }}
          />
        ))}
      </div>

      {/* Slider control */}
      <input type="range" min="0" max="200" value={padding} onChange={(e) => setPadding(Number(e.target.value))} />
    </div>
  );
}
```

### Transformer Aspect Ratio Constraint
Enforce aspect ratios during resize:

```typescript
<Transformer
  keepRatio={aspectRatio !== null}
  boundBoxFunc={(oldBox, newBox) => {
    if (aspectRatio !== null) {
      if (newBox.width / newBox.height > aspectRatio) {
        newBox.height = newBox.width / aspectRatio;
      } else {
        newBox.width = newBox.height * aspectRatio;
      }
    }
    return newBox;
  }}
/>
```

---

## Testing Guidelines

### Unit Tests ✓
**Tool:** Vitest with @testing-library/react
**Coverage:** Test files in `__tests__` directories across stores and utils
- Test hooks in isolation (useScreenshot, useImage, etc.)
- Test store actions independently (canvas-store, annotation-store, etc.)
- Test utility functions (export-utils, screenshot-api)
- Current coverage: Estimated 70%+
- Target: > 80% coverage

### Integration Tests ✓
- Test capture → store → render flow
- Test zoom/pan interactions via Konva events
- Test error handling and permission checks
- Test cross-store communication (annotation ↔ canvas)

### E2E Tests ✓
- Test complete screenshot workflow (capture → edit → export)
- Test export to PNG/JPEG formats
- Test annotation tool interactions
- Platform-specific testing via CI/CD matrix

---

## Security Standards

### Screenshot Data
- Store only in memory (Uint8Array in Zustand)
- Never cache to disk without user consent
- Revoke blob URLs after use to free memory
- No network transmission (offline-first)

### Input Validation
- Validate window IDs before capturing
- Check image dimensions are within reasonable bounds
- Validate zoom scale: 0.1x to 5x

### Dependencies
- Keep dependencies updated
- Review security advisories
- Minimize dependency count

---

## Git Workflow

### Branch Naming
- Feature: `feat/<feature-name>`
- Bug fix: `fix/<issue-name>`
- Docs: `docs/<doc-name>`
- Example: `feat/annotation-tools`, `fix/zoom-bug`

### Commit Strategy
- Atomic commits (one logical change per commit)
- Write meaningful commit messages
- Push to feature branch before PR
- All commits must pass lint/type checks

---

## Code Review Checklist

Before submitting PR, ensure:
- [ ] TypeScript strict mode passes (no errors)
- [ ] ESLint passes (run `npm run lint` if configured)
- [ ] Code follows naming conventions
- [ ] No `any` types (use `unknown` if needed)
- [ ] Error handling implemented
- [ ] Memory cleanup included (URLs, listeners)
- [ ] JSDoc comments for public functions
- [ ] No console.log left in code (use console.error/warn for important logs)
- [ ] Commit messages follow convention
- [ ] Related documentation updated

---

## Tools & Linting

### TypeScript Configuration
- `strict: true` for full type checking
- `noImplicitAny: true` to catch type errors
- `esModuleInterop: true` for better module compatibility

### Recommended VS Code Extensions
- ESLint
- Prettier (if configured)
- Tailwind CSS IntelliSense
- TypeScript Vue Plugin (if using Vue)

---

## Glossary

- **Store:** Zustand state management container
- **Hook:** Custom React function that uses state/effects
- **Component:** Reusable React function
- **Action:** Store method that modifies state
- **Selector:** Function that extracts state subset
- **Blob URL:** JavaScript object URL from binary data

---

---

## Phase 06-08 Implementation Details

### Phase 06: Export System (Complete ✓)
**Files Added:**
- `stores/export-store.ts` - Export settings with persistence
- `stores/history-store.ts` - Undo/redo with image snapshots (50 limit)
- `components/sidebar/export-panel.tsx` - Export UI controls
- `utils/export-utils.ts` - Canvas render, crop apply, format conversion

**Key Patterns:**
```typescript
// Persistent export settings
export const useExportStore = create<ExportState>(
  (set) => ({
    format: 'png',
    quality: 0.9,
    pixelRatio: 1,
    outputAspectRatio: 'auto',
    lastSavePath: null,
    // ... actions
  }),
  { name: 'beautyshot-export-settings' }  // localStorage key
);

// Aspect ratio extension calculation
const calculateAspectRatioExtend = (imageSize, targetRatio) => {
  // Extends canvas while keeping image centered
};
```

### Phase 07: Native Integration (Complete ✓)
**Files Added:**
- `stores/settings-store.ts` - Hotkey/behavior/theme preferences
- `stores/ui-store.ts` - Transient UI state (modals, windows)
- `components/settings/settings-modal.tsx` - Settings UI
- `hooks/use-hotkeys.ts` - Global hotkey event listener
- `hooks/use-sync-shortcuts.ts` - Backend sync
- `hooks/use-keyboard-shortcuts.ts` - In-app shortcuts (Ctrl+Z, etc.)

**Backend Commands Added:**
- `update_shortcuts(capture, region, window)` - Global hotkey registration
- `check_screen_permission()` - macOS Screen Recording check
- `check_wayland()` - Linux Wayland detection
- System tray menu with capture, show, quit actions

### Phase 08: Distribution & Packaging (Complete ✓)
**Platform Build Config:**
- macOS: Universal binary, DMG installer, entitlements for screen recording
- Windows: NSIS installer with language selector
- Linux: AppImage + DEB packages with dependencies

**CI/CD Automation:**
- GitHub Actions with multi-platform matrix (macOS, Windows, Linux)
- Auto-signing with TAURI_SIGNING_PRIVATE_KEY
- Release automation on version tags
- Test suite runs pre-build

---

**Document Version:** 2.1
**Last Updated:** 2026-01-13
**Phase:** 08 - Polish & Distribution (Complete ✓)
</file>

<file path="docs/project-overview-pdr.md">
# BeautyShot - Project Overview & Product Development Requirements

## Project Vision

BeautyShot is a modern, cross-platform screenshot beautification tool that empowers content creators, developers, and professionals to capture and enhance screenshots with intuitive editing and annotation features. The application combines native screenshot capabilities with a powerful canvas editor, enabling users to add annotations, apply filters, and export polished visual content.

**Target Users:** Content creators, developers, technical writers, UI/UX designers
**Primary Platforms:** macOS, Linux, Windows
**Positioning:** Fast, beautiful, developer-friendly screenshot editor

---

## Product Development Requirements (PDR)

### 1. Core Functional Requirements

#### F1: Screenshot Capture
- **Requirement:** Application must capture full-screen and individual window screenshots
- **Scope:** Phase 02 ✓
- **Acceptance Criteria:**
  - Fullscreen capture works on macOS, Linux, Windows
  - Window enumeration displays all open windows
  - Window capture targets specific application window
  - Captured output: raw PNG bytes (lossless)
  - Max resolution: native screen resolution

#### F2: Canvas Editing & Viewport
- **Requirement:** Display captured screenshots in interactive canvas with zoom and pan
- **Scope:** Phase 03 ✓
- **Acceptance Criteria:**
  - Image displays correctly in Konva stage
  - Zoom: 10% to 500% (0.1x to 5x) via mouse wheel
  - Pan: click-drag to move around canvas
  - Responsive: canvas resizes with window
  - Zoom controls UI: in, out, fit-to-screen buttons
  - Performance: smooth interactions at full resolution images

#### F3: Annotation Tools
- **Requirement:** Tools to add drawings, shapes, text to screenshots
- **Scope:** Phase 04 ✓
- **Acceptance Criteria:**
  - Brush tool with adjustable size/color ✓
  - Shape tools: rectangle, ellipse, arrow, line ✓
  - Text tool with font selection ✓
  - Color picker for all tools ✓
  - Undo/redo functionality ✓
  - Layer management ✓

#### F4: Beautification & Padding
- **Requirement:** Add backgrounds and padding to screenshots for beautification
- **Scope:** Phase 05 ✓
- **Acceptance Criteria:**
  - Gradient backgrounds: 24+ presets with direction/angle support ✓
  - Solid color backgrounds: 6 colors + custom color selection ✓
  - Transparent mode with checkerboard pattern ✓
  - Padding slider: 0-200px around image ✓
  - Non-destructive (can change/remove background) ✓
  - Real-time preview on canvas ✓

#### F4b: Crop Tool (Phase 05)
- **Requirement:** Non-destructive image cropping with aspect ratio support
- **Scope:** Phase 05 ✓
- **Acceptance Criteria:**
  - 8 aspect ratio presets (1:1, 4:3, 3:2, 16:9, 21:9, 9:16, 3:4, freeform) ✓
  - Draggable crop box with transformer handles ✓
  - Real-time aspect ratio enforcement ✓
  - Dimmed overlay outside crop area ✓
  - Minimum 50px size validation ✓
  - Non-destructive (applied during export) ✓

#### F5: Export & Sharing
- **Requirement:** Save edited screenshots in multiple formats
- **Scope:** Phase 06 ✓
- **Acceptance Criteria:**
  - Export formats: PNG, JPEG ✓
  - Quality/resolution settings (1x/2x/3x) ✓
  - Save to file with dialog ✓
  - Copy to clipboard ✓
  - Quick save with customizable location ✓

#### F6: Native Integration
- **Requirement:** Seamless OS integration
- **Scope:** Phase 07 ✓
- **Acceptance Criteria:**
  - Global hotkey for screenshot ✓
  - System tray icon and menu ✓
  - Auto-save quick export ✓
  - System notifications ✓
  - Hotkey customization in settings ✓

---

### 2. Non-Functional Requirements

#### NFR1: Performance
- **Requirement:** Application must handle high-resolution images smoothly
- **Target:**
  - Full-screen capture completion: < 500ms
  - Canvas render: 60 FPS at native resolution
  - Memory: < 200MB for typical screenshots
  - Zoom/pan operations: < 16ms latency

#### NFR2: Security
- **Requirement:** Sensitive data handling and privacy
- **Implementation:**
  - Screenshots stored in memory (not cached)
  - No data collection or telemetry
  - No network requests (offline-first)
  - User controls all file I/O

#### NFR3: Compatibility
- **Requirement:** Work reliably across platforms
- **Targets:**
  - macOS 11.0+
  - Ubuntu 20.04+, Fedora 35+
  - Windows 10+
  - Touch support (future: Phase 08)

#### NFR4: User Experience
- **Requirement:** Intuitive, responsive interface
- **Implementation:**
  - < 100ms feedback for all interactions
  - Clear error messages
  - Loading indicators for async operations
  - Keyboard shortcuts for power users (Phase 08)

#### NFR5: Maintainability
- **Requirement:** Clean, well-documented codebase
- **Implementation:**
  - TypeScript strict mode
  - Component-based architecture
  - Zustand for centralized state
  - Clear separation of concerns
  - Comprehensive documentation

---

### 3. Technical Constraints

| Constraint | Details |
|-----------|---------|
| **Framework** | Tauri 2 for native integration + React 19 frontend |
| **State Management** | Zustand (lightweight, minimal boilerplate) |
| **Canvas Rendering** | Konva.js (performant 2D canvas library) |
| **Styling** | Tailwind CSS v4 (utility-first) |
| **Language** | TypeScript strict mode |
| **Screenshot Library** | xcap (Rust crate) for native captures |
| **Build Tool** | Vite for frontend bundling |

---

### 4. Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Launch Time** | < 1s | Cold startup |
| **Capture Speed** | < 500ms | Full-screen capture |
| **Memory Usage** | < 200MB | Typical workflow |
| **Zoom FPS** | 60 FPS | Smooth interaction |
| **Code Coverage** | > 80% | Unit tests |
| **Platform Support** | 3 (macOS, Linux, Windows) | CI/CD validation |

---

## Architecture Decisions

### Decision 1: Tauri vs Electron
**Choice:** Tauri 2
**Rationale:**
- Native performance (Rust backend)
- Smaller bundle size (~30MB vs 150MB+)
- Better resource utilization
- macOS, Linux, Windows support
- Growing ecosystem

### Decision 2: Zustand for State
**Choice:** Zustand (not Redux/Context)
**Rationale:**
- Minimal boilerplate
- Excellent TypeScript support
- Perfect for canvas-centric app
- Easy to test and debug
- No wrapper component overhead

### Decision 3: Konva Canvas Library
**Choice:** Konva.js (not Fabric.js or Three.js)
**Rationale:**
- Excellent 2D performance
- Built-in zoom/pan support
- React wrapper (react-konva)
- Supports layers for annotations
- Active maintenance

---

## Development Roadmap

| Phase | Title | Status | Timeline |
|-------|-------|--------|----------|
| 01 | Project Setup | ✓ | Complete |
| 02 | Screenshot Capture | ✓ | Complete |
| 03 | Canvas Editor Foundation | ✓ | Complete |
| 04 | Annotation Tools | ✓ | Complete |
| 05 | Beautification & Cropping | ✓ | Complete |
| 06 | Export System | ✓ | Complete |
| 07 | Native Integration | ✓ | Complete |
| 08 | Polish & Distribution | ✓ | Complete (v1.0.0) |

---

## Known Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|-----------|
| **Wayland Screenshot Limitations** | Low | Warning displayed; fallback to X11 |
| **High-Res Image Performance** | Medium | Implement image tiling; lazy rendering |
| **Cross-Platform Divergence** | Medium | Comprehensive CI/CD testing; platform-specific handlers |
| **Annotation Complexity** | Low | Phase 04 design planned; modular implementation |
| **Export Format Support** | Low | Use native OS APIs; third-party libraries as fallback |

---

## Team & Responsibilities

| Role | Responsibility |
|------|-----------------|
| **Developer** | Implementation across all phases |
| **QA** | Testing on macOS, Linux, Windows; performance validation |
| **UX Designer** | UI/UX polish (Phase 08); user feedback integration |
| **Documentation** | Docs/wiki maintenance; user guide creation |

---

## Glossary

- **Canvas:** Konva Stage + Layers for rendering images and annotations
- **Stage:** Konva rendering surface with zoom/pan
- **Layer:** Konva grouping mechanism (image layer, annotation layer)
- **Blob URL:** JavaScript object URL created from Uint8Array bytes
- **Xcap:** Rust screenshot library used by Tauri backend
- **PDR:** Product Development Requirements (this document)

---

## References

- [Tauri 2 Documentation](https://tauri.app/v2/)
- [Konva.js API Docs](https://konvajs.org/api/Konva.html)
- [Zustand GitHub](https://github.com/pmndrs/zustand)
- [Xcap Screenshot Library](https://github.com/nashaofu/xcap)

---

**Document Version:** 2.2
**Last Updated:** 2026-01-13
**Phase Completed:** 08 - Polish & Distribution
**Release Status:** v1.0.0 - Production Ready
</file>

<file path="plans/251226-1356-tauri-screenshot-app/phase-03-canvas-editor.md">
# Phase 03: Canvas Editor Foundation

**Status**: ✅ DONE | **Effort**: 4h | **Priority**: P1 | **Completed**: 2025-12-27

## Objective

Build react-konva canvas editor with image display, responsive sizing, zoom/pan controls, and layer management.

---

## Tasks

### 3.1 Canvas Store (State Management)

**src/stores/canvas-store.ts:**
```typescript
import { create } from 'zustand';

interface CanvasState {
  // Image
  imageUrl: string | null;
  imageBytes: Uint8Array | null;
  originalWidth: number;
  originalHeight: number;

  // Canvas viewport
  stageWidth: number;
  stageHeight: number;
  scale: number;
  position: { x: number; y: number };

  // Actions
  setImage: (url: string, bytes: Uint8Array, width: number, height: number) => void;
  setStageSize: (width: number, height: number) => void;
  setScale: (scale: number) => void;
  setPosition: (x: number, y: number) => void;
  resetView: () => void;
  clearCanvas: () => void;
}

export const useCanvasStore = create<CanvasState>((set) => ({
  imageUrl: null,
  imageBytes: null,
  originalWidth: 0,
  originalHeight: 0,
  stageWidth: 800,
  stageHeight: 600,
  scale: 1,
  position: { x: 0, y: 0 },

  setImage: (url, bytes, width, height) => set({
    imageUrl: url,
    imageBytes: bytes,
    originalWidth: width,
    originalHeight: height,
  }),

  setStageSize: (width, height) => set({ stageWidth: width, stageHeight: height }),
  setScale: (scale) => set({ scale: Math.max(0.1, Math.min(5, scale)) }),
  setPosition: (x, y) => set({ position: { x, y } }),
  resetView: () => set({ scale: 1, position: { x: 0, y: 0 } }),
  clearCanvas: () => set({
    imageUrl: null,
    imageBytes: null,
    originalWidth: 0,
    originalHeight: 0,
  }),
}));
```

### 3.2 Canvas Editor Component

**src/components/canvas/canvas-editor.tsx:**
```typescript
import { useRef, useEffect, useCallback } from 'react';
import { Stage, Layer, Image as KonvaImage } from 'react-konva';
import Konva from 'konva';
import { useCanvasStore } from '../../stores/canvas-store';
import { useImage } from '../../hooks/use-image';

const MIN_SCALE = 0.1;
const MAX_SCALE = 5;
const ZOOM_FACTOR = 1.1;

export function CanvasEditor() {
  const stageRef = useRef<Konva.Stage>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const {
    imageUrl,
    stageWidth,
    stageHeight,
    scale,
    position,
    setStageSize,
    setScale,
    setPosition,
  } = useCanvasStore();

  const [image] = useImage(imageUrl || '');

  // Responsive resize
  useEffect(() => {
    const handleResize = () => {
      if (containerRef.current) {
        setStageSize(
          containerRef.current.offsetWidth,
          containerRef.current.offsetHeight
        );
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [setStageSize]);

  // Zoom with mouse wheel
  const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
    e.evt.preventDefault();

    const stage = stageRef.current;
    if (!stage) return;

    const oldScale = scale;
    const pointer = stage.getPointerPosition();
    if (!pointer) return;

    const mousePointTo = {
      x: (pointer.x - position.x) / oldScale,
      y: (pointer.y - position.y) / oldScale,
    };

    const direction = e.evt.deltaY > 0 ? -1 : 1;
    const newScale = direction > 0
      ? oldScale * ZOOM_FACTOR
      : oldScale / ZOOM_FACTOR;

    const clampedScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

    setScale(clampedScale);
    setPosition(
      pointer.x - mousePointTo.x * clampedScale,
      pointer.y - mousePointTo.y * clampedScale
    );
  }, [scale, position, setScale, setPosition]);

  // Pan with drag
  const handleDragEnd = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {
    setPosition(e.target.x(), e.target.y());
  }, [setPosition]);

  return (
    <div
      ref={containerRef}
      className="flex-1 bg-gray-100 overflow-hidden"
    >
      <Stage
        ref={stageRef}
        width={stageWidth}
        height={stageHeight}
        scaleX={scale}
        scaleY={scale}
        x={position.x}
        y={position.y}
        draggable
        onWheel={handleWheel}
        onDragEnd={handleDragEnd}
      >
        <Layer>
          {image && (
            <KonvaImage
              image={image}
              x={0}
              y={0}
            />
          )}
        </Layer>
        {/* Annotation layer will be added in Phase 04 */}
        <Layer name="annotations" />
      </Stage>
    </div>
  );
}
```

### 3.3 Image Loading Hook

**src/hooks/use-image.ts:**
```typescript
import { useState, useEffect } from 'react';

export function useImage(url: string): [HTMLImageElement | null, 'loading' | 'loaded' | 'error'] {
  const [image, setImage] = useState<HTMLImageElement | null>(null);
  const [status, setStatus] = useState<'loading' | 'loaded' | 'error'>('loading');

  useEffect(() => {
    if (!url) {
      setImage(null);
      return;
    }

    setStatus('loading');
    const img = new Image();

    img.onload = () => {
      setImage(img);
      setStatus('loaded');
    };

    img.onerror = () => {
      setImage(null);
      setStatus('error');
    };

    img.src = url;

    return () => {
      img.onload = null;
      img.onerror = null;
    };
  }, [url]);

  return [image, status];
}
```

### 3.4 Zoom Controls Component

**src/components/canvas/zoom-controls.tsx:**
```typescript
import { useCanvasStore } from '../../stores/canvas-store';

export function ZoomControls() {
  const { scale, setScale, resetView } = useCanvasStore();

  const zoomIn = () => setScale(scale * 1.2);
  const zoomOut = () => setScale(scale / 1.2);
  const zoomFit = () => resetView();

  return (
    <div className="absolute bottom-4 right-4 flex gap-2 bg-white rounded-lg shadow p-2">
      <button
        onClick={zoomOut}
        className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded"
        title="Zoom Out"
      >
        -
      </button>
      <span className="w-16 text-center text-sm leading-8">
        {Math.round(scale * 100)}%
      </span>
      <button
        onClick={zoomIn}
        className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded"
        title="Zoom In"
      >
        +
      </button>
      <button
        onClick={zoomFit}
        className="px-2 h-8 text-sm hover:bg-gray-100 rounded"
        title="Fit to Screen"
      >
        Fit
      </button>
    </div>
  );
}
```

### 3.5 Main Layout

**src/components/layout/editor-layout.tsx:**
```typescript
import { CanvasEditor } from '../canvas/canvas-editor';
import { ZoomControls } from '../canvas/zoom-controls';
import { Toolbar } from '../toolbar/toolbar';

export function EditorLayout() {
  return (
    <div className="h-screen flex flex-col">
      {/* Top toolbar */}
      <Toolbar />

      {/* Main canvas area */}
      <div className="flex-1 relative">
        <CanvasEditor />
        <ZoomControls />
      </div>
    </div>
  );
}
```

### 3.6 Basic Toolbar Placeholder

**src/components/toolbar/toolbar.tsx:**
```typescript
import { useScreenshot } from '../../hooks/use-screenshot';
import { useCanvasStore } from '../../stores/canvas-store';

export function Toolbar() {
  const { captureFullscreen, loading } = useScreenshot();
  const { setImage } = useCanvasStore();

  const handleCapture = async () => {
    const result = await captureFullscreen();
    if (result) {
      // Create image to get dimensions
      const img = new Image();
      img.onload = () => {
        setImage(result.url, result.bytes, img.width, img.height);
      };
      img.src = result.url;
    }
  };

  return (
    <div className="h-12 bg-white border-b flex items-center px-4 gap-4">
      <button
        onClick={handleCapture}
        disabled={loading}
        className="px-4 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
      >
        {loading ? 'Capturing...' : 'Capture Screen'}
      </button>

      {/* Tool buttons will be added in Phase 04 */}
      <div className="flex-1" />

      <span className="text-sm text-gray-500">BeautyShot</span>
    </div>
  );
}
```

---

## Install Zustand

```bash
npm install zustand
```

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/stores/canvas-store.ts` | Create |
| `src/components/canvas/canvas-editor.tsx` | Create |
| `src/components/canvas/zoom-controls.tsx` | Create |
| `src/components/layout/editor-layout.tsx` | Create |
| `src/components/toolbar/toolbar.tsx` | Create |
| `src/hooks/use-image.ts` | Create |
| `src/App.tsx` | Modify (use EditorLayout) |

---

## Verification

1. Capture screenshot → displays on canvas
2. Scroll wheel → zooms in/out
3. Drag canvas → pans around
4. Resize window → canvas resizes
5. Zoom controls → work correctly

---

## Success Criteria

- [x] Screenshot displays on Konva canvas ✅
- [x] Zoom in/out with scroll wheel ✅
- [x] Pan by dragging stage ✅
- [x] Responsive canvas sizing ✅
- [x] Zoom controls UI working ✅
- [x] Performance: smooth 60fps drag/zoom ✅

**All criteria met. Critical issues fixed.**

---

## Performance Notes

- Use `batchDraw()` for multiple shape updates
- Limit canvas redraws during drag
- Cache complex shapes when needed

---

## Code Review Results

**Review Date**: 2025-12-27
**Report**: `../reports/code-reviewer-251227-0356-phase03-canvas-editor.md`
**Status**: ✅ PASS - All Critical Issues Fixed

### Fixed Issues

1. **Memory Leak** ✅ FIXED - canvas-store.ts now revokes blob URLs in `setImageFromBytes` and `clearCanvas`
2. **State Duplication** ✅ FIXED - use-screenshot.ts returns raw bytes only, canvas-store manages URLs
3. **Zoom Factor** ✅ FIXED - Both files use `ZOOM_FACTOR = 1.1`

### Remaining (Non-blocking)

- Bundle size 502KB (can optimize later with code splitting)
- Missing ARIA labels (accessibility - Phase 04+)

---

## Next Phase

✅ **READY** - All blockers resolved.

[Phase 04: Annotation Tools](./phase-04-annotation-tools.md)
</file>

<file path="src/components/canvas/annotations/spotlight-shape.tsx">
// SpotlightShape - Spotlight/dimming effect annotation component

import { Group, Rect, Shape } from 'react-konva';
import type { SpotlightAnnotation } from '../../../types/annotations';
import { useCanvasStore } from '../../../stores/canvas-store';
import { useBackgroundStore } from '../../../stores/background-store';
import { useAnnotationStore } from '../../../stores/annotation-store';
import { useTransformHandler } from '../../../hooks/use-transform-handler';
import { ANNOTATION_DEFAULTS, CANVAS_FALLBACK } from '../../../constants/annotations';

interface Props {
  annotation: SpotlightAnnotation;
}

export function SpotlightShape({ annotation }: Props) {
  const { originalWidth, originalHeight, stageWidth, stageHeight } = useCanvasStore();
  const { cornerRadius } = useBackgroundStore();
  const { updateAnnotation, setSelected } = useAnnotationStore();
  const handleTransformEnd = useTransformHandler(annotation.id, 'spotlight');

  // Use actual stage dimensions, then original image, then fallback
  const canvasWidth = originalWidth || stageWidth || CANVAS_FALLBACK.WIDTH;
  const canvasHeight = originalHeight || stageHeight || CANVAS_FALLBACK.HEIGHT;

  return (
    <Group>
      {/* Dimmed overlay with cutout - respects image corner radius */}
      <Shape
        sceneFunc={(ctx, shape) => {
          ctx.beginPath();

          // Draw rounded rectangle for canvas (matching image corner radius)
          if (cornerRadius > 0) {
            const r = cornerRadius;
            ctx.moveTo(r, 0);
            ctx.lineTo(canvasWidth - r, 0);
            ctx.arcTo(canvasWidth, 0, canvasWidth, r, r);
            ctx.lineTo(canvasWidth, canvasHeight - r);
            ctx.arcTo(canvasWidth, canvasHeight, canvasWidth - r, canvasHeight, r);
            ctx.lineTo(r, canvasHeight);
            ctx.arcTo(0, canvasHeight, 0, canvasHeight - r, r);
            ctx.lineTo(0, r);
            ctx.arcTo(0, 0, r, 0, r);
          } else {
            // No corner radius - use simple rectangle
            ctx.rect(0, 0, canvasWidth, canvasHeight);
          }

          // Cutout (spotlight area) - uses even-odd fill rule
          if (annotation.shape === 'ellipse') {
            ctx.ellipse(
              annotation.x + annotation.width / 2,
              annotation.y + annotation.height / 2,
              annotation.width / 2,
              annotation.height / 2,
              0,
              0,
              Math.PI * 2,
              true
            );
          } else {
            // Rectangle cutout - draw counter-clockwise
            ctx.moveTo(annotation.x, annotation.y);
            ctx.lineTo(annotation.x, annotation.y + annotation.height);
            ctx.lineTo(annotation.x + annotation.width, annotation.y + annotation.height);
            ctx.lineTo(annotation.x + annotation.width, annotation.y);
            ctx.closePath();
          }
          ctx.fillStrokeShape(shape);
        }}
        fill={ANNOTATION_DEFAULTS.SPOTLIGHT.DIMMED_COLOR}
        listening={false}
      />

      {/* Invisible draggable handle for the spotlight area */}
      <Rect
        id={annotation.id}
        x={annotation.x}
        y={annotation.y}
        width={annotation.width}
        height={annotation.height}
        fill="rgba(255,255,255,0.01)"
        stroke="white"
        strokeWidth={2}
        dash={[5, 5]}
        draggable={annotation.draggable}
        onClick={(e) => {
          e.cancelBubble = true;
          setSelected(annotation.id);
        }}
        onTap={(e) => {
          e.cancelBubble = true;
          setSelected(annotation.id);
        }}
        onDragEnd={(e) => {
          updateAnnotation(annotation.id, {
            x: e.target.x(),
            y: e.target.y(),
          });
        }}
        onTransformEnd={handleTransformEnd}
      />
    </Group>
  );
}
</file>

<file path="src/components/capture/window-picker-modal.tsx">
// WindowPickerModal - Modal for selecting a window to capture

import { useState, useEffect, useRef, useCallback } from 'react';
import type { WindowInfo } from '../../types/screenshot';
import * as screenshotApi from '../../utils/screenshot-api';
import { logError } from '../../utils/logger';

interface WindowWithThumbnail extends WindowInfo {
  thumbnail?: string;
  thumbnailLoading?: boolean;
  thumbnailError?: boolean;
}

interface Props {
  isOpen: boolean;
  onClose: () => void;
  onCapture: (bytes: Uint8Array, width: number, height: number) => void;
}

const THUMBNAIL_SIZE = 80;

export function WindowPickerModal({ isOpen, onClose, onCapture }: Props) {
  const [windows, setWindows] = useState<WindowWithThumbnail[]>([]);
  const [loading, setLoading] = useState(true);
  const [capturing, setCapturing] = useState(false);
  const [selectedId, setSelectedId] = useState<number | null>(null);
  const modalRef = useRef<HTMLDivElement>(null);
  const closeButtonRef = useRef<HTMLButtonElement>(null);

  // Fetch windows list
  const fetchWindows = useCallback(async () => {
    setLoading(true);
    try {
      const list = await screenshotApi.getWindows();
      // Filter out windows with empty titles and sort by app name
      const filtered = list
        .filter((w) => w.title.trim() !== '' && w.width > 0 && w.height > 0)
        .sort((a, b) => a.app_name.localeCompare(b.app_name));

      const windowsWithThumbnails: WindowWithThumbnail[] = filtered.map((w) => ({
        ...w,
        thumbnailLoading: true,
      }));
      setWindows(windowsWithThumbnails);

      const batchSize = 5;
      for (let i = 0; i < filtered.length; i += batchSize) {
        const batch = filtered.slice(i, i + batchSize);
        await Promise.all(
          batch.map(async (win) => {
            try {
              const thumbnail = await screenshotApi.getWindowThumbnail(win.id, THUMBNAIL_SIZE);
              setWindows((prev) =>
                prev.map((w) =>
                  w.id === win.id
                    ? { ...w, thumbnail: `data:image/png;base64,${thumbnail}`, thumbnailLoading: false }
                    : w
                )
              );
            } catch {
              setWindows((prev) =>
                prev.map((w) =>
                  w.id === win.id ? { ...w, thumbnailLoading: false, thumbnailError: true } : w
                )
              );
            }
          })
        );
      }
    } catch (e) {
      logError('WindowPickerModal:fetchWindows', e);
      setWindows([]);
    } finally {
      setLoading(false);
    }
  }, []);

  // Load windows when modal opens
  useEffect(() => {
    if (isOpen) {
      fetchWindows();
      setSelectedId(null);
    }
  }, [isOpen, fetchWindows]);

  // Handle ESC key to close modal
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);

  // Focus management
  useEffect(() => {
    if (isOpen && closeButtonRef.current) {
      closeButtonRef.current.focus();
    }
  }, [isOpen]);

  // Capture selected window (no need to hide app - capturing specific window)
  const handleCapture = async () => {
    if (selectedId === null) return;

    setCapturing(true);
    try {
      // Capture window directly without hiding app
      const bytes = await screenshotApi.captureWindow(selectedId);

      if (bytes) {
        // Get dimensions from the captured image
        const { width, height } = await getImageDimensions(bytes);
        onCapture(bytes, width, height);
        onClose();
      }
    } catch (e) {
      logError('WindowPickerModal:capture', e);
    } finally {
      setCapturing(false);
    }
  };

  // Double-click to capture
  const handleDoubleClick = async (windowId: number) => {
    setSelectedId(windowId);
    setCapturing(true);
    try {
      const bytes = await screenshotApi.captureWindow(windowId);
      if (bytes) {
        const { width, height } = await getImageDimensions(bytes);
        onCapture(bytes, width, height);
        onClose();
      }
    } catch (e) {
      logError('WindowPickerModal:capture', e);
    } finally {
      setCapturing(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 bg-black/50 flex items-center justify-center z-50"
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      <div
        ref={modalRef}
        className="bg-white dark:bg-gray-800 rounded-lg w-[500px] max-h-[70vh] flex flex-col shadow-xl"
        role="dialog"
        aria-modal="true"
        aria-labelledby="window-picker-title"
      >
        {/* Header */}
        <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
          <h2
            id="window-picker-title"
            className="text-lg font-medium text-gray-800 dark:text-gray-100"
          >
            Select Window to Capture
          </h2>
          <div className="flex items-center gap-2">
            <button
              onClick={fetchWindows}
              disabled={loading}
              className="px-2 py-1 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100 disabled:opacity-50"
              aria-label="Refresh window list"
            >
              ↻ Refresh
            </button>
            <button
              ref={closeButtonRef}
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-xl leading-none"
              aria-label="Close (Escape)"
            >
              ×
            </button>
          </div>
        </div>

        {/* Window List */}
        <div className="flex-1 overflow-y-auto p-2">
          {loading ? (
            <div className="flex items-center justify-center py-8 text-gray-500 dark:text-gray-400">
              Loading windows...
            </div>
          ) : windows.length === 0 ? (
            <div className="flex items-center justify-center py-8 text-gray-500 dark:text-gray-400">
              No windows found
            </div>
          ) : (
            <div className="flex flex-col gap-2">
              {windows.map((win) => (
                <button
                  key={win.id}
                  onClick={() => setSelectedId(win.id)}
                  onDoubleClick={() => handleDoubleClick(win.id)}
                  className={`flex items-center gap-3 p-3 rounded-lg transition-all ${
                    selectedId === win.id
                      ? 'bg-orange-50 dark:bg-orange-900/30 ring-2 ring-orange-500'
                      : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  {/* Thumbnail */}
                  <div className="w-20 h-16 flex-shrink-0 bg-gray-100 dark:bg-gray-900 rounded flex items-center justify-center overflow-hidden">
                    {win.thumbnailLoading ? (
                      <div className="text-gray-400 text-xs">...</div>
                    ) : win.thumbnailError ? (
                      <div className="text-gray-400 text-xs">✕</div>
                    ) : win.thumbnail ? (
                      <img
                        src={win.thumbnail}
                        alt={win.title}
                        className="w-full h-full object-contain"
                      />
                    ) : (
                      <div className="text-gray-400 text-xs">?</div>
                    )}
                  </div>

                  {/* Window info */}
                  <div className="flex-1 min-w-0 text-left">
                    <div className="font-medium text-sm text-gray-800 dark:text-gray-200 truncate">
                      {win.title}
                    </div>
                    <div className="text-xs text-gray-500 dark:text-gray-400 truncate">
                      {win.app_name} • {win.width}×{win.height}
                    </div>
                  </div>
                </button>
              ))}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center">
          <span className="text-sm text-gray-500 dark:text-gray-400">
            Double-click to capture instantly
          </span>
          <div className="flex gap-2">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100"
            >
              Cancel
            </button>
            <button
              onClick={handleCapture}
              disabled={selectedId === null || capturing}
              className="px-4 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {capturing ? 'Capturing...' : 'Capture'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// Helper: Get image dimensions from bytes
function getImageDimensions(
  bytes: Uint8Array
): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const blob = new Blob([bytes], { type: 'image/png' });
    const url = URL.createObjectURL(blob);
    const img = new Image();

    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve({ width: img.width, height: img.height });
    };

    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };

    img.src = url;
  });
}
</file>

<file path="src/data/wallpapers.ts">
// Wallpaper presets for background beautification
// Using curated collection of beautiful, royalty-free wallpapers from Unsplash
// All IDs verified working as of 2026-01-16

export interface WallpaperCategory {
  id: string;
  name: string;
  icon?: string;
}

export interface WallpaperPreset {
  id: string;
  name: string;
  categoryId: string;
  url: string;
  thumbnailUrl?: string;
  colors: string[];
}

export const WALLPAPER_CATEGORIES: WallpaperCategory[] = [
  { id: 'professional', name: 'Professional', icon: 'briefcase' },
  { id: 'nature', name: 'Nature', icon: 'leaf' },
  { id: 'abstract', name: 'Abstract', icon: 'shapes' },
  { id: 'minimal', name: 'Minimal', icon: 'square' },
];

// Helper for Unsplash URLs
const unsplash = (id: string, width = 1920) =>
  `https://images.unsplash.com/photo-${id}?auto=format&fit=crop&w=${width}&q=80`;

export const WALLPAPER_PRESETS: WallpaperPreset[] = [
  // ============ PROFESSIONAL (12) - Workspace, Office, Desk ============
  {
    id: 'prof-1',
    name: 'Modern Desk',
    categoryId: 'professional',
    url: unsplash('1497215728101-856f4ea42174'),
    thumbnailUrl: unsplash('1497215728101-856f4ea42174', 400),
    colors: ['#e0e0e0', '#ffffff'],
  },
  {
    id: 'prof-2',
    name: 'Clean Workspace',
    categoryId: 'professional',
    url: unsplash('1497366216548-37526070297c'),
    thumbnailUrl: unsplash('1497366216548-37526070297c', 400),
    colors: ['#f5f5f5', '#dddddd'],
  },
  {
    id: 'prof-3',
    name: 'Office Building',
    categoryId: 'professional',
    url: unsplash('1486406146926-c627a92ad1ab'),
    thumbnailUrl: unsplash('1486406146926-c627a92ad1ab', 400),
    colors: ['#ffffff', '#f0f0f0'],
  },
  {
    id: 'prof-4',
    name: 'MacBook Setup',
    categoryId: 'professional',
    url: unsplash('1519389950473-47ba0277781c'),
    thumbnailUrl: unsplash('1519389950473-47ba0277781c', 400),
    colors: ['#333333', '#444444'],
  },
  {
    id: 'prof-5',
    name: 'Writing Desk',
    categoryId: 'professional',
    url: unsplash('1455390582262-044cdead277a'),
    thumbnailUrl: unsplash('1455390582262-044cdead277a', 400),
    colors: ['#555555', '#222222'],
  },
  {
    id: 'prof-6',
    name: 'Coffee & Work',
    categoryId: 'professional',
    url: unsplash('1495474472287-4d71bcdd2085'),
    thumbnailUrl: unsplash('1495474472287-4d71bcdd2085', 400),
    colors: ['#3e2723', '#5d4037'],
  },
  {
    id: 'prof-7',
    name: 'Notebook',
    categoryId: 'professional',
    url: unsplash('1517842645767-c639042777db'),
    thumbnailUrl: unsplash('1517842645767-c639042777db', 400),
    colors: ['#f5f5f5', '#e0e0e0'],
  },
  {
    id: 'prof-8',
    name: 'Modern Office',
    categoryId: 'professional',
    url: unsplash('1497366811353-6870744d04b2'),
    thumbnailUrl: unsplash('1497366811353-6870744d04b2', 400),
    colors: ['#fafafa', '#eeeeee'],
  },
  {
    id: 'prof-9',
    name: 'Desk Setup',
    categoryId: 'professional',
    url: unsplash('1518455027359-f3f8164ba6bd'),
    thumbnailUrl: unsplash('1518455027359-f3f8164ba6bd', 400),
    colors: ['#2c2c2c', '#1a1a1a'],
  },
  {
    id: 'prof-10',
    name: 'Library',
    categoryId: 'professional',
    url: unsplash('1521587760476-6c12a4b040da'),
    thumbnailUrl: unsplash('1521587760476-6c12a4b040da', 400),
    colors: ['#8b4513', '#654321'],
  },
  {
    id: 'prof-11',
    name: 'Meeting Room',
    categoryId: 'professional',
    url: unsplash('1497215842964-222b430dc094'),
    thumbnailUrl: unsplash('1497215842964-222b430dc094', 400),
    colors: ['#f0f0f0', '#e0e0e0'],
  },
  {
    id: 'prof-12',
    name: 'Tech Workspace',
    categoryId: 'professional',
    url: unsplash('1498050108023-c5249f4df085'),
    thumbnailUrl: unsplash('1498050108023-c5249f4df085', 400),
    colors: ['#2d2d2d', '#1f1f1f'],
  },

  // ============ NATURE (12) - Landscapes, Mountains, Ocean ============
  {
    id: 'nature-1',
    name: 'Misty Mountains',
    categoryId: 'nature',
    url: unsplash('1472214103451-9374bd1c798e'),
    thumbnailUrl: unsplash('1472214103451-9374bd1c798e', 400),
    colors: ['#6b7b8c', '#a0aab5'],
  },
  {
    id: 'nature-2',
    name: 'Deep Forest',
    categoryId: 'nature',
    url: unsplash('1441974231531-c6227db76b6e'),
    thumbnailUrl: unsplash('1441974231531-c6227db76b6e', 400),
    colors: ['#1e2f23', '#2d4435'],
  },
  {
    id: 'nature-3',
    name: 'Ocean Beach',
    categoryId: 'nature',
    url: unsplash('1507525428034-b723cf961d3e'),
    thumbnailUrl: unsplash('1507525428034-b723cf961d3e', 400),
    colors: ['#006994', '#009dc4'],
  },
  {
    id: 'nature-4',
    name: 'Golden Desert',
    categoryId: 'nature',
    url: unsplash('1473580044384-7ba9967e16a0'),
    thumbnailUrl: unsplash('1473580044384-7ba9967e16a0', 400),
    colors: ['#c2b280', '#e6d8ad'],
  },
  {
    id: 'nature-5',
    name: 'Blue Sky',
    categoryId: 'nature',
    url: unsplash('1513002749550-c59d786b8e6c'),
    thumbnailUrl: unsplash('1513002749550-c59d786b8e6c', 400),
    colors: ['#87CEEB', '#E0F4FF'],
  },
  {
    id: 'nature-6',
    name: 'Lake Reflection',
    categoryId: 'nature',
    url: unsplash('1439066615861-d1af74d74000'),
    thumbnailUrl: unsplash('1439066615861-d1af74d74000', 400),
    colors: ['#2c5364', '#203a43'],
  },
  {
    id: 'nature-7',
    name: 'Autumn Forest',
    categoryId: 'nature',
    url: unsplash('1508193638397-1c4234db14d8'),
    thumbnailUrl: unsplash('1508193638397-1c4234db14d8', 400),
    colors: ['#ff6b35', '#f7931e'],
  },
  {
    id: 'nature-8',
    name: 'Waterfall',
    categoryId: 'nature',
    url: unsplash('1432405972618-c60b0225b8f9'),
    thumbnailUrl: unsplash('1432405972618-c60b0225b8f9', 400),
    colors: ['#1e3a5f', '#3d6b99'],
  },
  {
    id: 'nature-9',
    name: 'Mountain Peak',
    categoryId: 'nature',
    url: unsplash('1464822759023-fed622ff2c3b'),
    thumbnailUrl: unsplash('1464822759023-fed622ff2c3b', 400),
    colors: ['#4a5568', '#2d3748'],
  },
  {
    id: 'nature-10',
    name: 'Green Valley',
    categoryId: 'nature',
    url: unsplash('1501854140801-50d01698950b'),
    thumbnailUrl: unsplash('1501854140801-50d01698950b', 400),
    colors: ['#228b22', '#006400'],
  },
  {
    id: 'nature-11',
    name: 'Sunset',
    categoryId: 'nature',
    url: unsplash('1495616811223-4d98c6e9c869'),
    thumbnailUrl: unsplash('1495616811223-4d98c6e9c869', 400),
    colors: ['#ff7e5f', '#feb47b'],
  },
  {
    id: 'nature-12',
    name: 'Northern Lights',
    categoryId: 'nature',
    url: unsplash('1531366936337-7c912a4589a7'),
    thumbnailUrl: unsplash('1531366936337-7c912a4589a7', 400),
    colors: ['#00d4aa', '#7b68ee'],
  },

  // ============ ABSTRACT (12) - Colorful, Artistic, Patterns ============
  {
    id: 'abstract-1',
    name: 'Fluid Art',
    categoryId: 'abstract',
    url: unsplash('1550684848-fac1c5b4e853'),
    thumbnailUrl: unsplash('1550684848-fac1c5b4e853', 400),
    colors: ['#ff6b6b', '#feca57'],
  },
  {
    id: 'abstract-2',
    name: 'Color Splash',
    categoryId: 'abstract',
    url: unsplash('1541701494587-cb58502866ab'),
    thumbnailUrl: unsplash('1541701494587-cb58502866ab', 400),
    colors: ['#ff0000', '#00ff00', '#0000ff'],
  },
  {
    id: 'abstract-3',
    name: 'Dark Clouds',
    categoryId: 'abstract',
    url: unsplash('1478760329108-5c3ed9d495a0'),
    thumbnailUrl: unsplash('1478760329108-5c3ed9d495a0', 400),
    colors: ['#1a1a2e', '#16213e'],
  },
  {
    id: 'abstract-4',
    name: 'Neon Gradient',
    categoryId: 'abstract',
    url: unsplash('1579546929662-711aa81148cf'),
    thumbnailUrl: unsplash('1579546929662-711aa81148cf', 400),
    colors: ['#667eea', '#764ba2'],
  },
  {
    id: 'abstract-5',
    name: 'Colorful Waves',
    categoryId: 'abstract',
    url: unsplash('1620641788421-7a1c342ea42e'),
    thumbnailUrl: unsplash('1620641788421-7a1c342ea42e', 400),
    colors: ['#fc466b', '#3f5efb'],
  },
  {
    id: 'abstract-6',
    name: 'Gradient Mesh',
    categoryId: 'abstract',
    url: unsplash('1618005182384-a83a8bd57fbe'),
    thumbnailUrl: unsplash('1618005182384-a83a8bd57fbe', 400),
    colors: ['#a8edea', '#fed6e3'],
  },
  {
    id: 'abstract-7',
    name: 'Ink Drops',
    categoryId: 'abstract',
    url: unsplash('1553356084-58ef4a67b2a7'),
    thumbnailUrl: unsplash('1553356084-58ef4a67b2a7', 400),
    colors: ['#e8e8e8', '#c0c0c0'],
  },
  {
    id: 'abstract-8',
    name: 'Purple Smoke',
    categoryId: 'abstract',
    url: unsplash('1557672172-298e090bd0f1'),
    thumbnailUrl: unsplash('1557672172-298e090bd0f1', 400),
    colors: ['#9b59b6', '#8e44ad'],
  },
  {
    id: 'abstract-9',
    name: 'Geometric',
    categoryId: 'abstract',
    url: unsplash('1558591710-4b4a1ae0f04d'),
    thumbnailUrl: unsplash('1558591710-4b4a1ae0f04d', 400),
    colors: ['#2193b0', '#6dd5ed'],
  },
  {
    id: 'abstract-10',
    name: 'Light Leaks',
    categoryId: 'abstract',
    url: unsplash('1557682224-5b8590cd9ec5'),
    thumbnailUrl: unsplash('1557682224-5b8590cd9ec5', 400),
    colors: ['#ff9a9e', '#fad0c4'],
  },
  {
    id: 'abstract-11',
    name: 'Bokeh Lights',
    categoryId: 'abstract',
    url: unsplash('1519751138087-5bf79df62d5b'),
    thumbnailUrl: unsplash('1519751138087-5bf79df62d5b', 400),
    colors: ['#ffd700', '#ff8c00'],
  },
  {
    id: 'abstract-12',
    name: 'Crystal',
    categoryId: 'abstract',
    url: unsplash('1518837695005-2083093ee35b'),
    thumbnailUrl: unsplash('1518837695005-2083093ee35b', 400),
    colors: ['#00d4ff', '#090979'],
  },

  // ============ MINIMAL (12) - Clean, Simple, White Space ============
  {
    id: 'minimal-1',
    name: 'White Interior',
    categoryId: 'minimal',
    url: unsplash('1586023492125-27b2c045efd7'),
    thumbnailUrl: unsplash('1586023492125-27b2c045efd7', 400),
    colors: ['#ffffff', '#f8f8f8'],
  },
  {
    id: 'minimal-2',
    name: 'Minimal Room',
    categoryId: 'minimal',
    url: unsplash('1519710164239-da123dc03ef4'),
    thumbnailUrl: unsplash('1519710164239-da123dc03ef4', 400),
    colors: ['#f5f5f5', '#eeeeee'],
  },
  {
    id: 'minimal-3',
    name: 'White Marble',
    categoryId: 'minimal',
    url: unsplash('1520607162513-77705c0f0d4a'),
    thumbnailUrl: unsplash('1520607162513-77705c0f0d4a', 400),
    colors: ['#e0e0e0', '#d0d0d0'],
  },
  {
    id: 'minimal-4',
    name: 'Cream Paper',
    categoryId: 'minimal',
    url: unsplash('1523821741446-edb2b68bb7a0'),
    thumbnailUrl: unsplash('1523821741446-edb2b68bb7a0', 400),
    colors: ['#fafafa', '#f0f0f0'],
  },
  {
    id: 'minimal-5',
    name: 'White Paint',
    categoryId: 'minimal',
    url: unsplash('1507652313519-d4e9174996dd'),
    thumbnailUrl: unsplash('1507652313519-d4e9174996dd', 400),
    colors: ['#ffffff', '#f5f5f5'],
  },
  {
    id: 'minimal-6',
    name: 'Clean Wall',
    categoryId: 'minimal',
    url: unsplash('1560448205-17d3a46c84de'),
    thumbnailUrl: unsplash('1560448205-17d3a46c84de', 400),
    colors: ['#f8f8f8', '#e8e8e8'],
  },
  {
    id: 'minimal-7',
    name: 'Minimal Furniture',
    categoryId: 'minimal',
    url: unsplash('1533090161767-e6ffed986c88'),
    thumbnailUrl: unsplash('1533090161767-e6ffed986c88', 400),
    colors: ['#f5f5dc', '#eeeecc'],
  },
  {
    id: 'minimal-8',
    name: 'Abstract Lines',
    categoryId: 'minimal',
    url: unsplash('1558591710-4b4a1ae0f04d'),
    thumbnailUrl: unsplash('1558591710-4b4a1ae0f04d', 400),
    colors: ['#e0e0e0', '#c0c0c0'],
  },
  {
    id: 'minimal-9',
    name: 'Soft Gradient',
    categoryId: 'minimal',
    url: unsplash('1557682260-96773eb01377'),
    thumbnailUrl: unsplash('1557682260-96773eb01377', 400),
    colors: ['#ffecd2', '#fcb69f'],
  },
  {
    id: 'minimal-10',
    name: 'Soft Pink',
    categoryId: 'minimal',
    url: unsplash('1557682268-e3955ed5d83f'),
    thumbnailUrl: unsplash('1557682268-e3955ed5d83f', 400),
    colors: ['#ffe4e6', '#ffc0cb'],
  },
  {
    id: 'minimal-11',
    name: 'Light Texture',
    categoryId: 'minimal',
    url: unsplash('1517816428104-797678c7cf0c'),
    thumbnailUrl: unsplash('1517816428104-797678c7cf0c', 400),
    colors: ['#f0f0f0', '#e0e0e0'],
  },
  {
    id: 'minimal-12',
    name: 'Simple White',
    categoryId: 'minimal',
    url: unsplash('1449247709967-d4461a6a6103'),
    thumbnailUrl: unsplash('1449247709967-d4461a6a6103', 400),
    colors: ['#ffffff', '#fafafa'],
  },
];

// Helper to get wallpapers by category
export function getWallpapersByCategory(categoryId: string): WallpaperPreset[] {
  return WALLPAPER_PRESETS.filter((w) => w.categoryId === categoryId);
}

// Helper to get a random wallpaper
export function getRandomWallpaper(): WallpaperPreset {
  const randomIndex = Math.floor(Math.random() * WALLPAPER_PRESETS.length);
  return WALLPAPER_PRESETS[randomIndex];
}

// Parse gradient URL to CSS
export function parseWallpaperUrl(url: string): { type: 'gradient' | 'image'; value: string } {
  if (url.startsWith('gradient:')) {
    return { type: 'gradient', value: url.replace('gradient:', '') };
  }
  return { type: 'image', value: url };
}
</file>

<file path="src/stores/__tests__/background-store.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useBackgroundStore } from '../background-store';
import { GRADIENT_PRESETS } from '../../data/gradients';
import { WALLPAPER_PRESETS } from '../../data/wallpapers';

describe('Background Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useBackgroundStore.setState({
      type: 'gradient',
      gradient: GRADIENT_PRESETS[0],
      solidColor: '#ffffff',
      wallpaper: null,
      customImageUrl: null,
      customImageBytes: null,
      blurAmount: 0,
      shadowBlur: 50,
      cornerRadius: 12,
      paddingPercent: 5,
    });
  });

  describe('Initial State', () => {
    it('should have default gradient background', () => {
      const state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');
      expect(state.gradient).toEqual(GRADIENT_PRESETS[0]);
    });

    it('should have default padding of 5%', () => {
      const state = useBackgroundStore.getState();
      expect(state.paddingPercent).toBe(5);
    });

    it('should have default solid color as white', () => {
      const state = useBackgroundStore.getState();
      expect(state.solidColor).toBe('#ffffff');
    });

    it('should have default blur amount of 0', () => {
      const state = useBackgroundStore.getState();
      expect(state.blurAmount).toBe(0);
    });

    it('should have default shadow blur of 50', () => {
      const state = useBackgroundStore.getState();
      expect(state.shadowBlur).toBe(50);
    });

    it('should have default corner radius of 12', () => {
      const state = useBackgroundStore.getState();
      expect(state.cornerRadius).toBe(12);
    });

    it('should have null wallpaper initially', () => {
      const state = useBackgroundStore.getState();
      expect(state.wallpaper).toBeNull();
    });

    it('should have null custom image initially', () => {
      const state = useBackgroundStore.getState();
      expect(state.customImageUrl).toBeNull();
      expect(state.customImageBytes).toBeNull();
    });
  });

  describe('setGradient', () => {
    it('should set gradient and type to gradient', () => {
      const gradient = GRADIENT_PRESETS[1]; // Royal gradient
      useBackgroundStore.getState().setGradient(gradient);

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');
      expect(state.gradient).toEqual(gradient);
    });

    it('should replace previous gradient', () => {
      const gradient1 = GRADIENT_PRESETS[0];
      const gradient2 = GRADIENT_PRESETS[5];

      useBackgroundStore.getState().setGradient(gradient1);
      expect(useBackgroundStore.getState().gradient).toEqual(gradient1);

      useBackgroundStore.getState().setGradient(gradient2);
      expect(useBackgroundStore.getState().gradient).toEqual(gradient2);
    });

    it('should preserve gradient properties', () => {
      const gradient = GRADIENT_PRESETS[3]; // Velvet
      useBackgroundStore.getState().setGradient(gradient);

      const state = useBackgroundStore.getState();
      expect(state.gradient?.id).toBe(gradient.id);
      expect(state.gradient?.name).toBe(gradient.name);
      expect(state.gradient?.colors).toEqual(gradient.colors);
      expect(state.gradient?.direction).toBe(gradient.direction);
    });
  });

  describe('setSolidColor', () => {
    it('should set solid color and type to solid', () => {
      useBackgroundStore.getState().setSolidColor('#000000');

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('solid');
      expect(state.solidColor).toBe('#000000');
    });

    it('should accept hex color codes', () => {
      const colors = ['#FF0000', '#00FF00', '#0000FF', '#ABCDEF'];

      colors.forEach(color => {
        useBackgroundStore.getState().setSolidColor(color);
        expect(useBackgroundStore.getState().solidColor).toBe(color);
      });
    });

    it('should replace previous solid color', () => {
      useBackgroundStore.getState().setSolidColor('#FF0000');
      expect(useBackgroundStore.getState().solidColor).toBe('#FF0000');

      useBackgroundStore.getState().setSolidColor('#0000FF');
      expect(useBackgroundStore.getState().solidColor).toBe('#0000FF');
    });
  });

  describe('setTransparent', () => {
    it('should set type to transparent', () => {
      useBackgroundStore.getState().setTransparent();

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('transparent');
    });

    it('should work after setting gradient', () => {
      useBackgroundStore.getState().setGradient(GRADIENT_PRESETS[2]);
      expect(useBackgroundStore.getState().type).toBe('gradient');

      useBackgroundStore.getState().setTransparent();
      expect(useBackgroundStore.getState().type).toBe('transparent');
    });

    it('should work after setting solid color', () => {
      useBackgroundStore.getState().setSolidColor('#FF0000');
      expect(useBackgroundStore.getState().type).toBe('solid');

      useBackgroundStore.getState().setTransparent();
      expect(useBackgroundStore.getState().type).toBe('transparent');
    });
  });

  describe('setWallpaper', () => {
    it('should set wallpaper and type to wallpaper', () => {
      const wallpaper = WALLPAPER_PRESETS[0];
      useBackgroundStore.getState().setWallpaper(wallpaper);

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('wallpaper');
      expect(state.wallpaper).toEqual(wallpaper);
    });

    it('should replace previous wallpaper', () => {
      const wallpaper1 = WALLPAPER_PRESETS[0];
      const wallpaper2 = WALLPAPER_PRESETS[1];

      useBackgroundStore.getState().setWallpaper(wallpaper1);
      expect(useBackgroundStore.getState().wallpaper).toEqual(wallpaper1);

      useBackgroundStore.getState().setWallpaper(wallpaper2);
      expect(useBackgroundStore.getState().wallpaper).toEqual(wallpaper2);
    });

    it('should preserve wallpaper properties', () => {
      const wallpaper = WALLPAPER_PRESETS[0];
      useBackgroundStore.getState().setWallpaper(wallpaper);

      const state = useBackgroundStore.getState();
      expect(state.wallpaper?.id).toBe(wallpaper.id);
      expect(state.wallpaper?.name).toBe(wallpaper.name);
      expect(state.wallpaper?.categoryId).toBe(wallpaper.categoryId);
      expect(state.wallpaper?.url).toBe(wallpaper.url);
    });
  });

  describe('setCustomImage', () => {
    it('should set custom image URL and type to image', () => {
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('image');
      expect(state.customImageUrl).toBe('https://example.com/image.jpg');
    });

    it('should set custom image bytes if provided', () => {
      const bytes = new Uint8Array([1, 2, 3, 4]);
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg', bytes);

      const state = useBackgroundStore.getState();
      expect(state.customImageBytes).toEqual(bytes);
    });

    it('should set bytes to null if not provided', () => {
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');

      const state = useBackgroundStore.getState();
      expect(state.customImageBytes).toBeNull();
    });
  });

  describe('clearCustomImage', () => {
    it('should clear custom image URL and bytes', () => {
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg', new Uint8Array([1, 2, 3]));
      useBackgroundStore.getState().clearCustomImage();

      const state = useBackgroundStore.getState();
      expect(state.customImageUrl).toBeNull();
      expect(state.customImageBytes).toBeNull();
    });

    it('should switch to gradient type when clearing from image type', () => {
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');
      expect(useBackgroundStore.getState().type).toBe('image');

      useBackgroundStore.getState().clearCustomImage();
      expect(useBackgroundStore.getState().type).toBe('gradient');
    });

    it('should not change type when clearing from non-image type', () => {
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');
      useBackgroundStore.getState().setSolidColor('#FF0000');
      expect(useBackgroundStore.getState().type).toBe('solid');

      useBackgroundStore.getState().clearCustomImage();
      expect(useBackgroundStore.getState().type).toBe('solid');
    });
  });

  describe('setBlurAmount', () => {
    it('should set blur amount', () => {
      useBackgroundStore.getState().setBlurAmount(10);
      expect(useBackgroundStore.getState().blurAmount).toBe(10);
    });

    it('should clamp blur to minimum 0', () => {
      useBackgroundStore.getState().setBlurAmount(-5);
      expect(useBackgroundStore.getState().blurAmount).toBe(0);
    });

    it('should clamp blur to maximum 500', () => {
      useBackgroundStore.getState().setBlurAmount(600);
      expect(useBackgroundStore.getState().blurAmount).toBe(500);
    });

    it('should accept values within valid range', () => {
      const validValues = [0, 10, 25, 40, 50];

      validValues.forEach(value => {
        useBackgroundStore.getState().setBlurAmount(value);
        expect(useBackgroundStore.getState().blurAmount).toBe(value);
      });
    });
  });

  describe('setShadowBlur', () => {
    it('should set shadow blur amount', () => {
      useBackgroundStore.getState().setShadowBlur(30);
      expect(useBackgroundStore.getState().shadowBlur).toBe(30);
    });

    it('should clamp shadow blur to minimum 0', () => {
      useBackgroundStore.getState().setShadowBlur(-10);
      expect(useBackgroundStore.getState().shadowBlur).toBe(0);
    });

    it('should clamp shadow blur to maximum 500', () => {
      useBackgroundStore.getState().setShadowBlur(600);
      expect(useBackgroundStore.getState().shadowBlur).toBe(500);
    });

    it('should accept values within valid range', () => {
      const validValues = [0, 100, 250, 400, 500];

      validValues.forEach(value => {
        useBackgroundStore.getState().setShadowBlur(value);
        expect(useBackgroundStore.getState().shadowBlur).toBe(value);
      });
    });
  });

  describe('setCornerRadius', () => {
    it('should set corner radius', () => {
      useBackgroundStore.getState().setCornerRadius(20);
      expect(useBackgroundStore.getState().cornerRadius).toBe(20);
    });

    it('should clamp corner radius to minimum 0', () => {
      useBackgroundStore.getState().setCornerRadius(-5);
      expect(useBackgroundStore.getState().cornerRadius).toBe(0);
    });

    it('should clamp corner radius to maximum 100', () => {
      useBackgroundStore.getState().setCornerRadius(150);
      expect(useBackgroundStore.getState().cornerRadius).toBe(100);
    });

    it('should accept values within valid range', () => {
      const validValues = [0, 12, 24, 50, 100];

      validValues.forEach(value => {
        useBackgroundStore.getState().setCornerRadius(value);
        expect(useBackgroundStore.getState().cornerRadius).toBe(value);
      });
    });
  });

  describe('setPaddingPercent', () => {
    it('should set padding percentage value', () => {
      useBackgroundStore.getState().setPaddingPercent(10);
      expect(useBackgroundStore.getState().paddingPercent).toBe(10);
    });

    it('should clamp padding to minimum 0%', () => {
      useBackgroundStore.getState().setPaddingPercent(-10);
      expect(useBackgroundStore.getState().paddingPercent).toBe(0);
    });

    it('should clamp padding to maximum 50%', () => {
      useBackgroundStore.getState().setPaddingPercent(80);
      expect(useBackgroundStore.getState().paddingPercent).toBe(50);
    });

    it('should accept values within valid range', () => {
      const validValues = [0, 5, 10, 25, 40, 50];

      validValues.forEach(value => {
        useBackgroundStore.getState().setPaddingPercent(value);
        expect(useBackgroundStore.getState().paddingPercent).toBe(value);
      });
    });

    it('should handle edge cases', () => {
      useBackgroundStore.getState().setPaddingPercent(0);
      expect(useBackgroundStore.getState().paddingPercent).toBe(0);

      useBackgroundStore.getState().setPaddingPercent(50);
      expect(useBackgroundStore.getState().paddingPercent).toBe(50);
    });
  });

  describe('getPaddingPx', () => {
    it('should calculate pixel padding based on smaller dimension', () => {
      useBackgroundStore.getState().setPaddingPercent(10);

      // 10% of 800 (smaller) = 80px
      expect(useBackgroundStore.getState().getPaddingPx(1000, 800)).toBe(80);

      // 10% of 600 (smaller) = 60px
      expect(useBackgroundStore.getState().getPaddingPx(600, 1200)).toBe(60);
    });

    it('should return 0 when padding is 0%', () => {
      useBackgroundStore.getState().setPaddingPercent(0);
      expect(useBackgroundStore.getState().getPaddingPx(1000, 800)).toBe(0);
    });

    it('should handle square images', () => {
      useBackgroundStore.getState().setPaddingPercent(20);
      // 20% of 500 = 100px
      expect(useBackgroundStore.getState().getPaddingPx(500, 500)).toBe(100);
    });
  });

  describe('reset', () => {
    it('should reset to default state', () => {
      useBackgroundStore.getState().setGradient(GRADIENT_PRESETS[5]);
      useBackgroundStore.getState().setPaddingPercent(25);
      useBackgroundStore.getState().setBlurAmount(20);

      useBackgroundStore.getState().reset();

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');
      expect(state.gradient).toEqual(GRADIENT_PRESETS[0]);
      expect(state.solidColor).toBe('#ffffff');
      expect(state.paddingPercent).toBe(5);
      expect(state.blurAmount).toBe(0);
    });

    it('should reset from transparent state', () => {
      useBackgroundStore.getState().setTransparent();
      useBackgroundStore.getState().setPaddingPercent(30);

      useBackgroundStore.getState().reset();

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');
      expect(state.paddingPercent).toBe(5);
    });

    it('should reset from solid color state', () => {
      useBackgroundStore.getState().setSolidColor('#FF0000');
      useBackgroundStore.getState().setPaddingPercent(15);

      useBackgroundStore.getState().reset();

      const state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');
      expect(state.solidColor).toBe('#ffffff');
      expect(state.paddingPercent).toBe(5);
    });

    it('should reset wallpaper and custom image', () => {
      useBackgroundStore.getState().setWallpaper(WALLPAPER_PRESETS[0]);
      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');
      useBackgroundStore.getState().setBlurAmount(30);

      useBackgroundStore.getState().reset();

      const state = useBackgroundStore.getState();
      expect(state.customImageUrl).toBeNull();
      expect(state.customImageBytes).toBeNull();
      expect(state.blurAmount).toBe(0);
    });

    it('should reset shadow blur to default 50', () => {
      useBackgroundStore.getState().setShadowBlur(80);

      useBackgroundStore.getState().reset();

      const state = useBackgroundStore.getState();
      expect(state.shadowBlur).toBe(50);
    });

    it('should reset corner radius to default 12', () => {
      useBackgroundStore.getState().setCornerRadius(50);

      useBackgroundStore.getState().reset();

      const state = useBackgroundStore.getState();
      expect(state.cornerRadius).toBe(12);
    });
  });

  describe('Type switching', () => {
    it('should switch between all five types correctly', () => {
      let state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');

      useBackgroundStore.getState().setSolidColor('#FF0000');
      state = useBackgroundStore.getState();
      expect(state.type).toBe('solid');

      useBackgroundStore.getState().setTransparent();
      state = useBackgroundStore.getState();
      expect(state.type).toBe('transparent');

      useBackgroundStore.getState().setWallpaper(WALLPAPER_PRESETS[0]);
      state = useBackgroundStore.getState();
      expect(state.type).toBe('wallpaper');

      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');
      state = useBackgroundStore.getState();
      expect(state.type).toBe('image');

      useBackgroundStore.getState().setGradient(GRADIENT_PRESETS[3]);
      state = useBackgroundStore.getState();
      expect(state.type).toBe('gradient');
    });

    it('should maintain padding across type switches', () => {
      useBackgroundStore.getState().setPaddingPercent(20);

      useBackgroundStore.getState().setSolidColor('#FF0000');
      expect(useBackgroundStore.getState().paddingPercent).toBe(20);

      useBackgroundStore.getState().setTransparent();
      expect(useBackgroundStore.getState().paddingPercent).toBe(20);

      useBackgroundStore.getState().setWallpaper(WALLPAPER_PRESETS[0]);
      expect(useBackgroundStore.getState().paddingPercent).toBe(20);

      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');
      expect(useBackgroundStore.getState().paddingPercent).toBe(20);

      useBackgroundStore.getState().setGradient(GRADIENT_PRESETS[2]);
      expect(useBackgroundStore.getState().paddingPercent).toBe(20);
    });

    it('should maintain blur amount across type switches', () => {
      useBackgroundStore.getState().setBlurAmount(15);

      useBackgroundStore.getState().setSolidColor('#FF0000');
      expect(useBackgroundStore.getState().blurAmount).toBe(15);

      useBackgroundStore.getState().setWallpaper(WALLPAPER_PRESETS[0]);
      expect(useBackgroundStore.getState().blurAmount).toBe(15);

      useBackgroundStore.getState().setCustomImage('https://example.com/image.jpg');
      expect(useBackgroundStore.getState().blurAmount).toBe(15);
    });
  });
});
</file>

<file path="src/stores/crop-store.ts">
// Crop store - Zustand state for non-destructive cropping

import { create } from 'zustand';

export interface CropRect {
  x: number;
  y: number;
  width: number;
  height: number;
}

interface CropState {
  isCropping: boolean;
  cropRect: CropRect | null;
  aspectRatio: number | null; // null = freeform

  startCrop: (ratio?: number | null) => void;
  setCropRect: (rect: CropRect) => void;
  applyCrop: () => void;
  clearCrop: () => void;
  cancelCrop: () => void;
  setAspectRatio: (ratio: number | null) => void;
}

export const useCropStore = create<CropState>((set) => ({
  isCropping: false,
  cropRect: null,
  aspectRatio: null,

  startCrop: (ratio = null) =>
    set({
      isCropping: true,
      aspectRatio: ratio,
      cropRect: null,
    }),

  setCropRect: (rect) => set({ cropRect: rect }),

  applyCrop: () => {
    // After cropImage() is called, the image is actually cropped
    // Clear cropRect since it's no longer valid for the new cropped image
    set({ isCropping: false, cropRect: null, aspectRatio: null });
  },

  clearCrop: () =>
    set({
      isCropping: false,
      cropRect: null,
      aspectRatio: null,
    }),

  cancelCrop: () =>
    set({
      isCropping: false,
      cropRect: null,
      aspectRatio: null,
    }),

  setAspectRatio: (ratio) => set({ aspectRatio: ratio }),
}));
</file>

<file path="src/types/annotations.ts">
// Annotation types for canvas shapes and tools

export type AnnotationType =
  | 'rectangle'
  | 'ellipse'
  | 'line'
  | 'arrow'
  | 'freehand'
  | 'text'
  | 'number'
  | 'spotlight';

export interface BaseAnnotation {
  id: string;
  type: AnnotationType;
  x: number;
  y: number;
  rotation: number;
  draggable: boolean;
}

export interface RectAnnotation extends BaseAnnotation {
  type: 'rectangle';
  width: number;
  height: number;
  fill: string;
  stroke: string;
  strokeWidth: number;
}

export interface EllipseAnnotation extends BaseAnnotation {
  type: 'ellipse';
  radiusX: number;
  radiusY: number;
  fill: string;
  stroke: string;
  strokeWidth: number;
}

export interface LineAnnotation extends BaseAnnotation {
  type: 'line' | 'arrow';
  points: number[]; // [x1, y1, x2, y2]
  stroke: string;
  strokeWidth: number;
  pointerLength?: number;
  pointerWidth?: number;
}

export interface TextAnnotation extends BaseAnnotation {
  type: 'text';
  text: string;
  fontSize: number;
  fontFamily: string;
  fill: string;
}

export interface FreehandAnnotation extends BaseAnnotation {
  type: 'freehand';
  points: number[]; // [x1, y1, x2, y2, ...]
  stroke: string;
  strokeWidth: number;
}

export interface NumberAnnotation extends BaseAnnotation {
  type: 'number';
  number: number;
  radius: number;
  fill: string;
  textColor: string;
  fontSize: number;
}

export interface SpotlightAnnotation extends BaseAnnotation {
  type: 'spotlight';
  width: number;
  height: number;
  shape: 'rectangle' | 'ellipse';
}

export type Annotation =
  | RectAnnotation
  | EllipseAnnotation
  | LineAnnotation
  | FreehandAnnotation
  | TextAnnotation
  | NumberAnnotation
  | SpotlightAnnotation;

export type ToolType = AnnotationType | 'select';
</file>

<file path="src/utils/__tests__/export-utils.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  generateFilename,
  stageToDataURL,
  stageToBlob,
  dataURLToBytes,
  calculateAspectRatioExtend,
  ExportError,
  type ExportOptions,
} from '../export-utils';
import type Konva from 'konva';

// Typed mock config interface for better type safety
interface MockStageConfig {
  mimeType?: string;
  quality?: number;
  pixelRatio?: number;
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  callback?: (blob: Blob | null) => void;
}

// Mock stage structure type
interface MockStage {
  toDataURL: ReturnType<typeof vi.fn>;
  toBlob: ReturnType<typeof vi.fn>;
  x: ReturnType<typeof vi.fn>;
  y: ReturnType<typeof vi.fn>;
  scaleX: ReturnType<typeof vi.fn>;
  scaleY: ReturnType<typeof vi.fn>;
  position: ReturnType<typeof vi.fn>;
  scale: ReturnType<typeof vi.fn>;
}

// Mock Konva Stage for testing
const createMockStage = (): Konva.Stage & MockStage => {
  const mockStage = {
    // Transform getters (used to save state before export)
    x: vi.fn(() => 0),
    y: vi.fn(() => 0),
    scaleX: vi.fn(() => 1),
    scaleY: vi.fn(() => 1),
    // Transform setters (used to reset/restore state during export)
    position: vi.fn(),
    scale: vi.fn(),
    // Export methods
    toDataURL: vi.fn().mockReturnValue(
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFhAJ/wlseKgAAAABJRU5ErkJggg=='
    ),
    toBlob: vi.fn((config: MockStageConfig) => {
      if (config.callback) {
        const blob = new Blob(['fake image data'], { type: 'image/png' });
        config.callback(blob);
      }
    }),
  };
  return mockStage as Konva.Stage & MockStage;
};

// Helper to get mock call config - accepts a mock with .mock.calls
const getMockCallConfig = (mockStage: MockStage, method: 'toDataURL' | 'toBlob'): MockStageConfig => {
  return mockStage[method].mock.calls[0]?.[0] as MockStageConfig;
};

describe('Export Utils', () => {
  describe('generateFilename', () => {
    beforeEach(() => {
      vi.useFakeTimers();
      vi.setSystemTime(new Date('2024-12-25T10:30:45.123Z'));
    });

    it('should generate PNG filename with timestamp', () => {
      const filename = generateFilename('png');
      expect(filename).toMatch(/^beautyshot_\d{8}_\d{6}\.png$/);
      expect(filename).toContain('beautyshot_');
      expect(filename).toMatch(/\.png$/);
    });

    it('should generate JPEG filename with timestamp', () => {
      const filename = generateFilename('jpeg');
      expect(filename).toMatch(/^beautyshot_\d{8}_\d{6}\.jpeg$/);
      expect(filename).toContain('beautyshot_');
      expect(filename).toMatch(/\.jpeg$/);
    });

    it('should use ISO timestamp format (YYYYMMDD_HHMMSS)', () => {
      const filename = generateFilename('png');
      // Timestamp should be 20241225_103045
      expect(filename).toContain('beautyshot_20241225_103045');
    });

    it('should generate different filenames for different times', () => {
      const filename1 = generateFilename('png');

      vi.setSystemTime(new Date('2024-12-25T10:30:46.123Z'));
      const filename2 = generateFilename('png');

      expect(filename1).not.toBe(filename2);
    });

    it('should handle different formats consistently', () => {
      const pngName = generateFilename('png');
      const jpegName = generateFilename('jpeg');

      // Both should have same timestamp but different extension
      const pngTime = pngName.split('.')[0];
      const jpegTime = jpegName.split('.')[0];
      expect(pngTime).toBe(jpegTime);
      expect(pngName).toMatch(/\.png$/);
      expect(jpegName).toMatch(/\.jpeg$/);
    });
  });

  describe('stageToDataURL', () => {
    let mockStage: Konva.Stage;

    beforeEach(() => {
      mockStage = createMockStage();
    });

    it('should export stage as PNG data URL', () => {
      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 1,
      };

      const dataURL = stageToDataURL(mockStage, options);

      expect(dataURL).toMatch(/^data:image\/png;base64,/);
      expect(mockStage.toDataURL).toHaveBeenCalled();
    });

    it('should export stage as JPEG data URL', () => {
      const options: ExportOptions = {
        format: 'jpeg',
        quality: 0.85,
        pixelRatio: 1,
      };

      const dataURL = stageToDataURL(mockStage, options);

      expect(dataURL).toMatch(/^data:image\/png;base64,/);
      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toDataURL');
      expect(callConfig.mimeType).toBe('image/jpeg');
      expect(callConfig.quality).toBe(0.85);
    });

    it('should respect pixelRatio option', () => {
      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 2,
      };

      stageToDataURL(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toDataURL');
      expect(callConfig.pixelRatio).toBe(2);
    });

    it('should export with crop rect if provided', () => {
      const cropRect = { x: 10, y: 20, width: 300, height: 250 };
      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 1,
        cropRect,
      };

      stageToDataURL(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toDataURL');
      expect(callConfig.x).toBe(10);
      expect(callConfig.y).toBe(20);
      expect(callConfig.width).toBe(300);
      expect(callConfig.height).toBe(250);
    });

    it('should not include quality for PNG format', () => {
      const options: ExportOptions = {
        format: 'png',
        quality: 0.8,
        pixelRatio: 1,
      };

      stageToDataURL(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toDataURL');
      expect(callConfig.quality).toBeUndefined();
      expect(callConfig.mimeType).toBe('image/png');
    });

    it('should include quality for JPEG format', () => {
      const options: ExportOptions = {
        format: 'jpeg',
        quality: 0.75,
        pixelRatio: 1,
      };

      stageToDataURL(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toDataURL');
      expect(callConfig.quality).toBe(0.75);
      expect(callConfig.mimeType).toBe('image/jpeg');
    });
  });

  describe('stageToBlob', () => {
    let mockStage: Konva.Stage;

    beforeEach(() => {
      mockStage = createMockStage();
    });

    it('should export stage to blob', async () => {
      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 1,
      };

      const blob = await stageToBlob(mockStage, options);

      expect(blob).toBeInstanceOf(Blob);
      expect(blob.type).toBe('image/png');
    });

    it('should handle JPEG format', async () => {
      const options: ExportOptions = {
        format: 'jpeg',
        quality: 0.8,
        pixelRatio: 1,
      };

      const blob = await stageToBlob(mockStage, options);

      expect(blob).toBeInstanceOf(Blob);
      expect(mockStage.toBlob).toHaveBeenCalled();
    });

    it('should respect pixelRatio', async () => {
      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 3,
      };

      await stageToBlob(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toBlob');
      expect(callConfig.pixelRatio).toBe(3);
    });

    it('should export with crop rect if provided', async () => {
      const cropRect = { x: 5, y: 15, width: 400, height: 300 };
      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 1,
        cropRect,
      };

      await stageToBlob(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toBlob');
      expect(callConfig.x).toBe(5);
      expect(callConfig.y).toBe(15);
      expect(callConfig.width).toBe(400);
      expect(callConfig.height).toBe(300);
    });

    it('should reject on blob creation failure', async () => {
      const failStage = {
        x: vi.fn(() => 0),
        y: vi.fn(() => 0),
        scaleX: vi.fn(() => 1),
        scaleY: vi.fn(() => 1),
        position: vi.fn(),
        scale: vi.fn(),
        toDataURL: vi.fn(),
        toBlob: vi.fn((config: MockStageConfig) => {
          if (config.callback) {
            config.callback(null); // Simulate failure
          }
        }),
      };

      const options: ExportOptions = {
        format: 'png',
        quality: 0.9,
        pixelRatio: 1,
      };

      await expect(
        stageToBlob(failStage as unknown as Konva.Stage, options)
      ).rejects.toThrow('Failed to create blob from stage');
    });

    it('should include quality for JPEG in blob export', async () => {
      const options: ExportOptions = {
        format: 'jpeg',
        quality: 0.7,
        pixelRatio: 1,
      };

      await stageToBlob(mockStage, options);

      const callConfig = getMockCallConfig(mockStage as unknown as MockStage, 'toBlob');
      expect(callConfig.quality).toBe(0.7);
      expect(callConfig.mimeType).toBe('image/jpeg');
    });
  });

  describe('dataURLToBytes', () => {
    it('should convert PNG data URL to bytes', () => {
      const pngDataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFhAJ/wlseKgAAAABJRU5ErkJggg==';

      const bytes = dataURLToBytes(pngDataURL);

      expect(bytes).toBeInstanceOf(Uint8Array);
      expect(bytes.length).toBeGreaterThan(0);
    });

    it('should convert JPEG data URL to bytes', () => {
      // Simple minimal JPEG base64
      const jpegDataURL = 'data:image/jpeg;base64,/9j/4AAQSkZJRg==';

      const bytes = dataURLToBytes(jpegDataURL);

      expect(bytes).toBeInstanceOf(Uint8Array);
      expect(bytes.length).toBeGreaterThan(0);
    });

    it('should handle complex data URLs with charset', () => {
      // Valid base64 data for minimal PNG
      const dataURL = 'data:image/png;charset=utf-8;base64,iVBORw0KGgoAAAANSUhEUg==';
      const bytes = dataURLToBytes(dataURL);

      expect(bytes).toBeInstanceOf(Uint8Array);
    });

    it('should preserve binary data integrity', () => {
      // Create a simple test: "Hello World!" in base64 is "SGVsbG8gV29ybGQh"
      const testString = 'Hello World!';
      const testBase64 = 'SGVsbG8gV29ybGQh';
      const testDataURL = `data:text/plain;base64,${testBase64}`;

      const bytes = dataURLToBytes(testDataURL);
      const decoded = new TextDecoder().decode(bytes);

      expect(decoded).toBe(testString);
    });

    it('should extract correct portion after comma', () => {
      // Valid base64 data after comma: "test data" in base64 is "dGVzdCBkYXRh"
      const testBase64 = 'dGVzdCBkYXRh';
      const dataURL = `data:image/png;base64,${testBase64}`;
      const bytes = dataURLToBytes(dataURL);

      // Should only process the base64 part after comma
      expect(bytes).toBeInstanceOf(Uint8Array);
      expect(bytes.length).toBeGreaterThan(0);
    });

    it('should throw ExportError for empty input', () => {
      expect(() => dataURLToBytes('')).toThrow(ExportError);
      expect(() => dataURLToBytes('')).toThrow('Invalid data URL: empty or not a string');
    });

    it('should throw ExportError for invalid format (no comma)', () => {
      expect(() => dataURLToBytes('invalidbase64data')).toThrow(ExportError);
      expect(() => dataURLToBytes('invalidbase64data')).toThrow('missing comma separator');
    });

    it('should throw ExportError for empty base64 content', () => {
      expect(() => dataURLToBytes('data:image/png;base64,')).toThrow(ExportError);
      expect(() => dataURLToBytes('data:image/png;base64,')).toThrow('empty base64 content');
    });

    it('should throw ExportError for invalid base64', () => {
      // Invalid base64 characters
      expect(() => dataURLToBytes('data:image/png;base64,!!invalid!!')).toThrow(ExportError);
      expect(() => dataURLToBytes('data:image/png;base64,!!invalid!!')).toThrow('Failed to decode base64');
    });

    it('should have correct error code for each error type', () => {
      try {
        dataURLToBytes('');
      } catch (e) {
        expect(e).toBeInstanceOf(ExportError);
        expect((e as ExportError).code).toBe('INVALID_INPUT');
      }

      try {
        dataURLToBytes('nocolon');
      } catch (e) {
        expect(e).toBeInstanceOf(ExportError);
        expect((e as ExportError).code).toBe('INVALID_FORMAT');
      }

      try {
        dataURLToBytes('data:image/png;base64,');
      } catch (e) {
        expect(e).toBeInstanceOf(ExportError);
        expect((e as ExportError).code).toBe('EMPTY_CONTENT');
      }
    });
  });

  describe('Export Options Validation', () => {
    let mockStage: Konva.Stage;

    beforeEach(() => {
      mockStage = createMockStage();
    });

    it('should handle all valid combinations', () => {
      const formats: Array<'png' | 'jpeg'> = ['png', 'jpeg'];
      const ratios = [1, 2, 3];
      const qualities = [0.1, 0.5, 0.9];

      formats.forEach(format => {
        ratios.forEach(ratio => {
          qualities.forEach(quality => {
            const options: ExportOptions = {
              format,
              quality,
              pixelRatio: ratio,
            };

            const dataURL = stageToDataURL(mockStage, options);
            expect(dataURL).toBeTruthy();
          });
        });
      });
    });
  });

  describe('calculateAspectRatioExtend', () => {
    it('should return null for auto aspect ratio', () => {
      const result = calculateAspectRatioExtend(1920, 1080, 'auto');
      expect(result).toBeNull();
    });

    it('should return null for empty aspect ratio', () => {
      const result = calculateAspectRatioExtend(1920, 1080, '');
      expect(result).toBeNull();
    });

    it('should return null for unknown aspect ratio id', () => {
      const result = calculateAspectRatioExtend(1920, 1080, 'unknown');
      expect(result).toBeNull();
    });

    it('should return null when already at target ratio', () => {
      // 1920x1080 is already 16:9
      const result = calculateAspectRatioExtend(1920, 1080, '16:9');
      expect(result).toBeNull();
    });

    it('should extend height for 1:1 from landscape', () => {
      // 1920x1080 -> 1:1 should extend to 1920x1920
      const result = calculateAspectRatioExtend(1920, 1080, '1:1');
      expect(result).not.toBeNull();
      expect(result!.width).toBe(1920);
      expect(result!.height).toBe(1920);
      expect(result!.offsetX).toBe(0);
      expect(result!.offsetY).toBe(420); // (1920 - 1080) / 2 = 420
    });

    it('should extend width for 1:1 from portrait', () => {
      // 1080x1920 -> 1:1 should extend to 1920x1920
      const result = calculateAspectRatioExtend(1080, 1920, '1:1');
      expect(result).not.toBeNull();
      expect(result!.width).toBe(1920);
      expect(result!.height).toBe(1920);
      expect(result!.offsetX).toBe(420); // (1920 - 1080) / 2 = 420
      expect(result!.offsetY).toBe(0);
    });

    it('should extend width for 16:9 from square', () => {
      // 1000x1000 -> 16:9 should extend to 1778x1000
      // target ratio = 16/9 = 1.777...
      // newWidth = 1000 * 1.777... = 1777.77... ~= 1778
      const result = calculateAspectRatioExtend(1000, 1000, '16:9');
      expect(result).not.toBeNull();
      expect(result!.width).toBe(1778);
      expect(result!.height).toBe(1000);
      expect(result!.offsetX).toBe(389); // (1778 - 1000) / 2 = 389
      expect(result!.offsetY).toBe(0);
    });

    it('should extend height for 9:16 portrait from landscape', () => {
      // 1920x1080 -> 9:16 should extend height significantly
      // target ratio = 9/16 = 0.5625
      // newHeight = 1920 / 0.5625 = 3413.33... ~= 3413
      const result = calculateAspectRatioExtend(1920, 1080, '9:16');
      expect(result).not.toBeNull();
      expect(result!.width).toBe(1920);
      expect(result!.height).toBe(3413);
      expect(result!.offsetX).toBe(0);
      expect(result!.offsetY).toBe(1167); // (3413 - 1080) / 2 = 1166.5 ~= 1167
    });

    it('should extend height for 4:5 Instagram from landscape', () => {
      // 1000x800 -> 4:5 (0.8) should extend height
      // current ratio = 1.25, target = 0.8
      // newHeight = 1000 / 0.8 = 1250
      const result = calculateAspectRatioExtend(1000, 800, '4:5');
      expect(result).not.toBeNull();
      expect(result!.width).toBe(1000);
      expect(result!.height).toBe(1250);
      expect(result!.offsetY).toBe(225); // (1250 - 800) / 2 = 225
    });

    it('should center content horizontally when extending width', () => {
      const result = calculateAspectRatioExtend(1000, 2000, '1:1');
      expect(result).not.toBeNull();
      // newWidth = 2000, offsetX = (2000 - 1000) / 2 = 500
      expect(result!.offsetX).toBe(500);
    });

    it('should center content vertically when extending height', () => {
      const result = calculateAspectRatioExtend(2000, 1000, '1:1');
      expect(result).not.toBeNull();
      // newHeight = 2000, offsetY = (2000 - 1000) / 2 = 500
      expect(result!.offsetY).toBe(500);
    });

    it('should return rounded values', () => {
      // Dimensions that would result in floating point values
      const result = calculateAspectRatioExtend(1001, 1001, '16:9');
      expect(result).not.toBeNull();
      expect(Number.isInteger(result!.offsetX)).toBe(true);
      expect(Number.isInteger(result!.offsetY)).toBe(true);
      expect(Number.isInteger(result!.width)).toBe(true);
      expect(Number.isInteger(result!.height)).toBe(true);
    });
  });
});
</file>

<file path="src/utils/export-utils.ts">
// Export utilities - Konva stage export functions

import type Konva from 'konva';
import type { ExportFormat } from '../stores/export-store';
import { OUTPUT_ASPECT_RATIOS } from '../data/aspect-ratios';

export interface ExportOptions {
  format: ExportFormat;
  quality: number;
  pixelRatio: number;
  cropRect?: { x: number; y: number; width: number; height: number } | null;
  outputAspectRatio?: string; // 'auto' or ratio id like '1:1', '16:9'
  canvasWidth?: number; // Total canvas width (image + padding)
  canvasHeight?: number; // Total canvas height (image + padding)
}

/**
 * Calculate extended canvas dimensions based on output aspect ratio.
 * EXTENDS the canvas (adds more background) to fit the ratio while keeping
 * the entire original content visible. Returns null for 'auto'.
 */
export function calculateAspectRatioExtend(
  canvasWidth: number,
  canvasHeight: number,
  aspectRatioId: string
): { width: number; height: number; offsetX: number; offsetY: number } | null {
  // Auto = no extension, use original canvas size
  if (aspectRatioId === 'auto' || !aspectRatioId) {
    return null;
  }

  const ratioConfig = OUTPUT_ASPECT_RATIOS.find((r) => r.id === aspectRatioId);
  if (!ratioConfig || ratioConfig.ratio === null) {
    return null;
  }

  const targetRatio = ratioConfig.ratio;
  const currentRatio = canvasWidth / canvasHeight;

  let newWidth: number;
  let newHeight: number;

  if (currentRatio > targetRatio) {
    // Canvas is wider than target - extend height (make taller)
    newWidth = canvasWidth;
    newHeight = canvasWidth / targetRatio;
  } else if (currentRatio < targetRatio) {
    // Canvas is taller than target - extend width (make wider)
    newHeight = canvasHeight;
    newWidth = canvasHeight * targetRatio;
  } else {
    // Already at target ratio
    return null;
  }

  // Calculate offset to center original content within extended canvas
  const offsetX = (newWidth - canvasWidth) / 2;
  const offsetY = (newHeight - canvasHeight) / 2;

  return {
    width: Math.round(newWidth),
    height: Math.round(newHeight),
    offsetX: Math.round(offsetX),
    offsetY: Math.round(offsetY),
  };
}

/**
 * Generate timestamped filename for exports
 */
export function generateFilename(format: ExportFormat): string {
  const now = new Date();
  const timestamp = now
    .toISOString()
    .replace(/[-:]/g, '')
    .replace('T', '_')
    .slice(0, 15);
  return `beautyshot_${timestamp}.${format}`;
}

/**
 * Export Konva stage to data URL
 * When aspect ratio is set, the stage is already extended - export full stage
 * Temporarily resets stage transform to export content at original position/scale
 */
export function stageToDataURL(
  stage: Konva.Stage,
  options: ExportOptions
): string {
  const { format, quality, pixelRatio, cropRect, canvasWidth, canvasHeight } = options;

  // Save current transform state
  const savedPosition = { x: stage.x(), y: stage.y() };
  const savedScale = { x: stage.scaleX(), y: stage.scaleY() };

  // Reset transform for accurate export (content at origin, no scaling)
  stage.position({ x: 0, y: 0 });
  stage.scale({ x: 1, y: 1 });

  const exportConfig: Parameters<typeof stage.toDataURL>[0] = {
    mimeType: format === 'jpeg' ? 'image/jpeg' : 'image/png',
    quality: format === 'jpeg' ? quality : undefined,
    pixelRatio,
  };

  // If cropping (crop tool), export specific region
  if (cropRect) {
    exportConfig.x = cropRect.x;
    exportConfig.y = cropRect.y;
    exportConfig.width = cropRect.width;
    exportConfig.height = cropRect.height;
  } else if (canvasWidth && canvasHeight) {
    // Export the actual canvas area, not the viewport
    exportConfig.x = 0;
    exportConfig.y = 0;
    exportConfig.width = canvasWidth;
    exportConfig.height = canvasHeight;
  }

  const dataURL = stage.toDataURL(exportConfig);

  // Restore transform state
  stage.position(savedPosition);
  stage.scale(savedScale);

  return dataURL;
}

/**
 * Export Konva stage to Blob (async)
 * Temporarily resets stage transform to export content at original position/scale
 */
export function stageToBlob(
  stage: Konva.Stage,
  options: ExportOptions
): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const { format, quality, pixelRatio, cropRect, canvasWidth, canvasHeight } = options;

    // Save current transform state
    const savedPosition = { x: stage.x(), y: stage.y() };
    const savedScale = { x: stage.scaleX(), y: stage.scaleY() };

    // Reset transform for accurate export (content at origin, no scaling)
    stage.position({ x: 0, y: 0 });
    stage.scale({ x: 1, y: 1 });

    const exportConfig: Parameters<typeof stage.toBlob>[0] = {
      mimeType: format === 'jpeg' ? 'image/jpeg' : 'image/png',
      quality: format === 'jpeg' ? quality : undefined,
      pixelRatio,
      callback: (blob) => {
        // Restore transform state
        stage.position(savedPosition);
        stage.scale(savedScale);

        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('Failed to create blob from stage'));
        }
      },
    };

    if (cropRect) {
      exportConfig.x = cropRect.x;
      exportConfig.y = cropRect.y;
      exportConfig.width = cropRect.width;
      exportConfig.height = cropRect.height;
    } else if (canvasWidth && canvasHeight) {
      exportConfig.x = 0;
      exportConfig.y = 0;
      exportConfig.width = canvasWidth;
      exportConfig.height = canvasHeight;
    }

    stage.toBlob(exportConfig);
  });
}

/**
 * Custom error for export operations
 */
export class ExportError extends Error {
  constructor(
    message: string,
    public readonly code: string
  ) {
    super(message);
    this.name = 'ExportError';
  }
}

/**
 * Convert data URL to Uint8Array bytes for file saving
 * @throws ExportError if data URL is invalid or decoding fails
 */
export function dataURLToBytes(dataURL: string): Uint8Array {
  if (!dataURL || typeof dataURL !== 'string') {
    throw new ExportError('Invalid data URL: empty or not a string', 'INVALID_INPUT');
  }

  const parts = dataURL.split(',');
  if (parts.length !== 2) {
    throw new ExportError('Invalid data URL format: missing comma separator', 'INVALID_FORMAT');
  }

  const base64 = parts[1];
  if (!base64) {
    throw new ExportError('Invalid data URL: empty base64 content', 'EMPTY_CONTENT');
  }

  try {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  } catch (e) {
    throw new ExportError(
      `Failed to decode base64: ${e instanceof Error ? e.message : 'Unknown error'}`,
      'DECODE_ERROR'
    );
  }
}
</file>

<file path="src-tauri/src/permissions.rs">
// Platform-specific permission handling
// macOS requires Screen Recording permission for screenshot capture
// and Accessibility permission for global shortcuts

/// Check if screen capture permission is granted
/// macOS: Uses CGPreflightScreenCaptureAccess (no prompts triggered)
/// Other platforms: Always returns true
#[tauri::command]
pub fn check_screen_permission() -> bool {
    #[cfg(target_os = "macos")]
    {
        // Use native API only - DO NOT attempt capture here
        // Capture attempts can trigger system prompts which is bad UX
        #[link(name = "CoreGraphics", kind = "framework")]
        extern "C" {
            fn CGPreflightScreenCaptureAccess() -> bool;
        }
        let granted = unsafe { CGPreflightScreenCaptureAccess() };
        println!("CGPreflightScreenCaptureAccess returned: {}", granted);
        granted
    }
    #[cfg(not(target_os = "macos"))]
    {
        true
    }
}

/// Check if accessibility permission is granted (for global shortcuts)
/// macOS: Uses macos-accessibility-client to check trust status
/// Other platforms: Always returns true
#[tauri::command]
pub fn check_accessibility_permission() -> bool {
    #[cfg(target_os = "macos")]
    {
        let trusted = macos_accessibility_client::accessibility::application_is_trusted();
        println!("Accessibility trusted: {}", trusted);
        trusted
    }
    #[cfg(not(target_os = "macos"))]
    {
        true
    }
}

/// Request accessibility permission (opens system prompt)
/// macOS: Uses macos-accessibility-client to prompt user
/// Other platforms: No-op
#[tauri::command]
pub fn request_accessibility_permission() -> bool {
    #[cfg(target_os = "macos")]
    {
        macos_accessibility_client::accessibility::application_is_trusted_with_prompt()
    }
    #[cfg(not(target_os = "macos"))]
    {
        true
    }
}

/// Request screen recording permission - opens system settings if needed
/// Note: CGRequestScreenCaptureAccess can trigger unwanted dialogs
#[tauri::command]
pub fn request_screen_permission() -> bool {
    #[cfg(target_os = "macos")]
    {
        println!("Requesting screen capture access...");
        #[link(name = "CoreGraphics", kind = "framework")]
        extern "C" {
            fn CGRequestScreenCaptureAccess() -> bool;
        }
        let granted = unsafe { CGRequestScreenCaptureAccess() };
        println!("CGRequestScreenCaptureAccess returned: {}", granted);

        if granted {
            return true;
        }

        // If not granted, open settings
        open_screen_recording_settings();
        false
    }
    #[cfg(not(target_os = "macos"))]
    {
        true
    }
}

/// Open system settings for screen recording permission
/// macOS: Opens Privacy & Security > Screen Recording
/// Other platforms: No-op
#[tauri::command]
pub fn open_screen_recording_settings() {
    #[cfg(target_os = "macos")]
    {
        let _ = std::process::Command::new("open")
            .arg("x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture")
            .spawn();
    }
}

/// Open system settings for accessibility permission
/// macOS: Opens Privacy & Security > Accessibility
/// Other platforms: No-op
#[tauri::command]
pub fn open_accessibility_settings() {
    #[cfg(target_os = "macos")]
    {
        let _ = std::process::Command::new("open")
            .arg("x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")
            .spawn();
    }
}

/// Detect if running on Wayland (Linux)
/// Returns warning message if Wayland detected with setup instructions
#[tauri::command]
pub fn check_wayland() -> Option<String> {
    #[cfg(target_os = "linux")]
    {
        if std::env::var("WAYLAND_DISPLAY").is_ok() {
            // Check if grim is available as fallback
            let grim_available = std::process::Command::new("which")
                .arg("grim")
                .output()
                .map(|o| o.status.success())
                .unwrap_or(false);

            if grim_available {
                return Some(
                    "Wayland detected. Using grim for screenshot capture."
                        .to_string(),
                );
            } else {
                return Some(
                    "Wayland detected. Install 'grim' for screenshot support: \
                     sudo apt install grim (Debian/Ubuntu) or \
                     sudo pacman -S grim (Arch)"
                        .to_string(),
                );
            }
        }
    }
    None
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
reports
.claude
</file>

<file path="docs/codebase-summary.md">
# BeautyShot Codebase Summary

## Project Overview
BeautyShot is a cross-platform screenshot beautification application built with Tauri 2, React 19, and TypeScript. It enables users to capture screenshots and apply editing/annotation tools for enhanced visual content creation.

**Version:** 1.0.0 (Production Release)
**Tech Stack:** Tauri 2 | React 19.1.0 | TypeScript | Tailwind CSS 4 | Konva 9.3.0 | Zustand 5.0.9

---

## Architecture Overview

### High-Level Structure
```
beautyshot/
├── src/                          # Frontend React application
│   ├── components/               # React components
│   │   ├── canvas/              # Canvas rendering & controls
│   │   ├── toolbar/             # Top toolbar UI
│   │   └── layout/              # Main layout structure
│   ├── hooks/                    # Custom React hooks
│   ├── stores/                   # Zustand state management
│   ├── types/                    # TypeScript type definitions
│   ├── utils/                    # Utility functions
│   ├── App.tsx                   # Root app component
│   └── main.tsx                  # Entry point
├── src-tauri/                    # Tauri native backend
│   ├── src/                      # Rust backend code
│   ├── capabilities/             # Tauri permissions
│   ├── tauri.conf.json          # Tauri configuration
│   └── icons/                    # App icons
├── plans/                        # Development plans & research
├── docs/                         # Documentation (this directory)
└── package.json                  # Node dependencies
```

---

## Core Components & Systems

### 1. State Management (Zustand)
**File:** `src/stores/canvas-store.ts`

Central state store for canvas editor, managing:
- **Image Data:** `imageUrl` (blob URL), `imageBytes` (raw PNG data), dimensions
- **Canvas Viewport:** `stageWidth`, `stageHeight`, `scale`, `position`
- **Actions:** Image loading, stage sizing, zoom/pan, view reset, canvas clearing

Memory management included: automatic URL revocation on image change/clear to prevent leaks.

```typescript
// Key interface
interface CanvasState {
  imageUrl: string | null;
  imageBytes: Uint8Array | null;
  originalWidth: number;
  originalHeight: number;
  stageWidth: number;
  stageHeight: number;
  scale: number;
  position: { x: number; y: number };
  // ... action methods
}
```

### 2. Canvas Editor Component
**File:** `src/components/canvas/canvas-editor.tsx` (~379 LOC)

Main Konva-based canvas rendering component:
- **Responsive:** Auto-resize to container dimensions
- **Zoom:** Mouse wheel zoom with clamping (0.1x - 5x)
- **Pan:** Click-drag to pan around canvas
- **Multi-layer:** Background layer + Image layer + Crop overlay + Annotation layer

Dependencies: react-konva, Konva.js

### 3. Hooks

#### useImage
**File:** `src/hooks/use-image.ts`
React hook that loads image from URL and tracks loading status.
- Returns: `[HTMLImageElement | null, 'loading' | 'loaded' | 'error']`
- Used by CanvasEditor to convert URL to DOM image element for Konva

#### useScreenshot
**File:** `src/hooks/use-screenshot.ts`
Wrapper around Tauri screenshot APIs, returns raw PNG bytes.
- Methods: `captureFullscreen()`, `captureWindow(windowId)`, `getWindows()`
- Returns: `Uint8Array` for PNG image data
- Includes error/warning handling (Wayland detection)

### 4. Toolbar Component
**File:** `src/components/toolbar/toolbar.tsx`

Top toolbar UI providing:
- **Capture Screen:** Full-screen screenshot button
- **Capture Window:** Dropdown to select & capture specific windows
- **Clear:** Remove current image from canvas
- **Status Feedback:** Loading indicator, error messages, Wayland warnings
- **App Name:** "BeautyShot" branding

Integrates `useScreenshot()` and `useCanvasStore()` to flow captured bytes → store → canvas.

### 5. Layout & Control Components
- **EditorLayout** (`src/components/layout/editor-layout.tsx`): Main container layout with toolbar + canvas + sidebar
- **ZoomControls** (`src/components/canvas/zoom-controls.tsx`): Float controls for zoom in/out, fit to screen

### 6. Phase 05: Beautification Features (NEW)

#### Background Layer Component
**File:** `src/components/canvas/background-layer.tsx`

Renders beautified backgrounds behind the image with support for:
- **Gradient Backgrounds:** 24 presets with linear/radial directions
- **Solid Colors:** 6 pre-defined colors (white, black, gray, red, blue, green)
- **Transparent Mode:** Checkerboard pattern (10px squares) to show transparency
- **Padding:** 0-200px margin around the image for spacing

Uses Konva Shape or Rect components for canvas rendering. Gradient angles calculated from degrees.

#### Crop Overlay Component
**File:** `src/components/canvas/crop-overlay.tsx`

Non-destructive crop tool providing:
- **Draggable Crop Box:** White dashed rectangle
- **Aspect Ratio Support:** 1:1, 4:3, 3:2, 16:9, 21:9, 9:16, 3:4, or freeform
- **Transformer Handle:** Resize from corners/edges with visual feedback
- **Dimmed Overlay:** Shows area outside crop region
- **Minimum Size:** 50px to prevent invalid crops

Crop rect stored in `useCropStore`; applied during export (Phase 06).

#### Sidebar Panel Components
**File:** `src/components/sidebar/background-panel.tsx` & `crop-panel.tsx`

Right sidebar UI panels for:
- **Background Panel:** Grid of gradient presets, solid color buttons, transparent toggle, padding slider
- **Crop Panel:** Aspect ratio selector, crop mode toggle, apply/cancel buttons

### 7. State Management (Phase 05)

#### Background Store
**File:** `src/stores/background-store.ts`

Manages background beautification state:
- `type`: 'gradient' | 'solid' | 'transparent'
- `gradient`: Selected GradientPreset object
- `solidColor`: Hex color string
- `padding`: 0-200px (clamped)

Actions: `setGradient()`, `setSolidColor()`, `setTransparent()`, `setPadding()`, `reset()`

#### Crop Store
**File:** `src/stores/crop-store.ts`

Manages crop tool state:
- `isCropping`: Toggle crop mode on/off
- `cropRect`: Position & dimensions of crop selection
- `aspectRatio`: Ratio constraint (null = freeform)

Actions: `startCrop()`, `setCropRect()`, `applyCrop()`, `cancelCrop()`, `setAspectRatio()`

### 8. Data Constants (Phase 05)

**File:** `src/data/gradients.ts`
- `GRADIENT_PRESETS`: 24 presets (Blues, Purples, Warm, Greens, Neutrals, Vibrant, Soft, Dark)
- `SOLID_COLORS`: 6 colors

**File:** `src/data/aspect-ratios.ts`
- `ASPECT_RATIOS`: 8 presets including Free, Square, Widescreen, Portrait variants

---

## Development Workflow

### Build & Run
```bash
npm install              # Install dependencies
npm run dev             # Dev server with Tauri
npm run build           # Production build
```

### Key Dependencies
| Package | Version | Purpose |
|---------|---------|---------|
| react | 19.1.0 | UI framework |
| zustand | 5.0.9 | State management |
| konva | 9.3.0 | Canvas rendering |
| react-konva | 18.2.10 | React bindings for Konva |
| @tauri-apps/api | 2.x | Tauri API access |
| tailwindcss | 4 | Utility-first CSS |

---

## Phase-Wise Implementation

### Phase 01: Project Setup ✓
- Tauri v2 + React 19 + TypeScript initialization
- Tailwind CSS v4 configuration
- Basic project structure

### Phase 02: Screenshot Capture ✓
- Native screenshot capabilities via Tauri + xcap
- Window enumeration
- Raw PNG byte generation

### Phase 03: Canvas Editor Foundation ✓
- Zustand state management implementation
- Konva canvas rendering with zoom/pan
- Image loading pipeline (bytes → store → canvas)
- Responsive toolbar with capture controls
- Zoom controls UI

### Phase 04: Annotation Tools ✓
- Brush tool with adjustable size/color/opacity
- Shape tools: rectangle, circle, arrow, text
- Color picker integration
- Layer management (drawing order control)
- Undo/redo functionality

### Phase 05: Beautification Features ✓
- Gradient backgrounds (24 presets)
- Solid color backgrounds (6 colors)
- Transparent mode with checkerboard pattern
- Padding control (0-200px around image)
- Non-destructive crop tool with aspect ratios
- Right sidebar panel for quick access

### Phase 06: Export System ✓
- PNG/JPEG/WebP export with quality settings
- 1x/2x/3x resolution scaling
- Crop application during export
- Clipboard copy functionality
- File dialog integration

### Phase 07: Native Integration ✓
- Global hotkey registration (Cmd/Ctrl+Shift+C)
- System tray/menu bar icon
- System notifications
- Auto-save quick export

### Phase 08: Polish & Distribution ✓
- macOS entitlements & permissions (screen recording)
- Linux desktop entry & AppImage packaging
- Windows NSIS installer configuration
- CI/CD workflows (GitHub Actions)
- Release automation with multi-platform builds
- v1.0.0 stable release

---

## Data Flow

```
Capture Action (Toolbar)
    ↓
useScreenshot() hook → raw Uint8Array bytes
    ↓
getImageDimensions() helper → extract width/height
    ↓
useCanvasStore.setImageFromBytes() → store bytes + dimensions
    ↓
Zustand creates blob URL from bytes
    ↓
useImage() hook loads URL → HTMLImageElement
    ↓
CanvasEditor renders via react-konva Stage
```

---

## Type Definitions
**File:** `src/types/screenshot.ts`

```typescript
interface WindowInfo {
  id: number;
  app_name: string;
  title: string;
}
```

---

## Code Standards

### File Organization
- Components in `src/components/`, organized by feature
- Custom hooks in `src/hooks/`
- State stores in `src/stores/`
- Type definitions in `src/types/`
- Utilities in `src/utils/`

### Naming Conventions
- **Components:** PascalCase (e.g., `CanvasEditor`)
- **Hooks:** camelCase with `use` prefix (e.g., `useCanvasStore`)
- **Functions:** camelCase (e.g., `captureFullscreen()`)
- **Constants:** UPPER_SNAKE_CASE (e.g., `MAX_SCALE`)

### React Patterns
- Functional components with hooks
- Custom hooks for logic extraction
- Zustand for global state (no prop drilling)
- useCallback for event handlers to prevent re-renders

---

## Memory & Performance Notes

1. **Blob URL Management:** Canvas store automatically revokes old URLs to prevent memory leaks
2. **Responsive Canvas:** Stage auto-resizes with window; event listeners cleaned up on unmount
3. **Image Loading:** Hook prevents multiple simultaneous loads; cleans up event listeners
4. **Zoom Clamping:** Scale constrained to 0.1x - 5x to prevent UI freezing

---

## Annotation Tools (Phase 04) ✓

All 7 annotation types fully implemented:
- **Shapes:** Rectangle, Ellipse with fill/stroke control
- **Lines:** Direct line + Arrow with customizable pointers
- **Freehand:** Brush with variable stroke width
- **Text:** Click-to-place with font family/size selection
- **Spotlight:** Highlight effect with transparent overlay
- **Selection:** Move/resize via transformer handles
- **Undo/Redo:** Full history with 50 snapshot limit

## Export System (Phase 06) ✓

Comprehensive export capabilities:
- **Formats:** PNG (lossless) + JPEG (quality slider 0.1-1.0)
- **Resolution:** 1x/2x/3x pixel ratios for scaling
- **Destinations:** Quick save + Save As dialog with path persistence
- **Clipboard:** Direct copy to system clipboard
- **Crop Integration:** Applied during export (non-destructive)
- **Notifications:** Toast feedback via settings

## Native Integration (Phase 07) ✓

OS-level integration features:
- **Hotkeys:** Globally registered shortcuts synced with Tauri backend
- **System Tray:** Minimize/restore via tray icon with menu
- **Notifications:** System notifications for export status
- **Themes:** Light/dark/system auto-detection
- **Settings:** Hotkey customization, auto-save location, minimize to tray

## Known Limitations

- **Wayland:** Limited screenshot support (X11 recommended on Linux)
- **Touch:** No touch event handling for mobile/tablet devices
- **Multi-Monitor:** Region capture works on primary monitor only
- **Clipboard:** PNG-only format (no text or metadata)

---

## External Resources

- [Tauri Documentation](https://tauri.app/)
- [Konva.js Canvas Library](https://konvajs.org/)
- [Zustand State Management](https://github.com/pmndrs/zustand)
- [React 19 Documentation](https://react.dev/)

---

## Phase 08: Distribution & Packaging

### Platform-Specific Build Configuration
**File:** `src-tauri/tauri.conf.json`

Multi-platform distribution targets:
- **macOS:** Universal binary (Intel + Apple Silicon), DMG installer, Code signing ready
- **Windows:** x86_64 NSIS installer with language selector
- **Linux:** AppImage + DEB packages for Debian/Ubuntu distributions
- **Common:** Icon bundling (32x32, 128x128, ICNS, ICO), metadata (name, version, copyright)

### macOS Permissions & Security
**Files:** `src-tauri/Info.plist`, `src-tauri/entitlements.plist`

- **Screen Recording:** NSScreenCaptureDescription explains permission request to users
- **Sandbox:** Disabled for screen capture access
- **File Access:** User-selected file read/write permitted for exports
- **Minimum OS:** 11.0 (Big Sur)

### Linux Distribution
**File:** `src-tauri/beautyfullshot.desktop`

Linux desktop entry for:
- Application menu integration
- System launcher registration
- Icon and category classification
- AppImage & DEB package support

### CI/CD Pipeline
**Files:** `.github/workflows/ci.yml`, `.github/workflows/release.yml`

**CI Workflow:**
- Runs on: push to master/main, pull requests
- Steps: Dependency install, TypeScript check, tests with coverage, Rust cargo check
- Node 20, Rust latest, Ubuntu Linux build environment

**Release Workflow:**
- Triggers on version tags (v*)
- Matrix builds: macOS aarch64 + x86_64, Windows x86_64, Linux x86_64
- Cross-platform build matrix with platform-specific dependencies
- Auto-creates GitHub release with signed/unsigned binaries
- Tests included in release job (npm test, tsc check)

### Release Configuration
- **Signing:** TAURI_SIGNING_PRIVATE_KEY secrets for release signing
- **Drafts:** Releases created as drafts (manual review before publish)
- **Assets:** Binaries automatically uploaded to GitHub releases

---

**Last Updated:** 2026-01-13
**Phase:** 08 - Polish & Distribution ✓ (Complete)
**Release:** v1.0.0 - Production Ready
**Frontend:** ~9,960 LOC across 64 files
**Backend:** ~688 LOC across 9 Rust files
</file>

<file path="docs/system-architecture.md">
# BeautyShot - System Architecture

## Executive Summary

BeautyShot is a cross-platform screenshot beautification desktop application built with Tauri 2 (Rust backend) and React 19 (TypeScript frontend). The architecture emphasizes performance, memory efficiency, and clean separation between native and web components.

**Current Phase:** 08 - Polish & Distribution (v1.0.0 Release)
**Tech Stack:** Tauri 2 | React 19 | TypeScript | Zustand | Konva.js | Tailwind CSS 4
**Release Status:** Production Ready - v1.0.0

---

## High-Level Architecture

```
┌─────────────────────────────────────────────────────────┐
│                   Desktop Application                    │
├─────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────┐   │
│  │      React 19 Frontend (TypeScript)              │   │
│  ├──────────────────────────────────────────────────┤   │
│  │ Components:                                      │   │
│  │  • CanvasEditor (Konva Stage + Layers)          │   │
│  │  • Toolbar (Capture + Export controls)          │   │
│  │  • ZoomControls (Zoom in/out/fit)              │   │
│  │  • EditorLayout (Main layout)                   │   │
│  ├──────────────────────────────────────────────────┤   │
│  │ State Management (Zustand):                      │   │
│  │  • canvas-store (Image + viewport state)        │   │
│  ├──────────────────────────────────────────────────┤   │
│  │ Custom Hooks:                                    │   │
│  │  • useImage (Image loading)                      │   │
│  │  • useScreenshot (Screenshot API wrapper)       │   │
│  └──────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────┤
│  IPC Bridge (Tauri Command Protocol)                    │
├─────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────┐   │
│  │      Rust Backend (Tauri 2)                      │   │
│  ├──────────────────────────────────────────────────┤   │
│  │ Capabilities:                                    │   │
│  │  • captureFullscreen() → PNG bytes              │   │
│  │  • captureWindow(id) → PNG bytes                │   │
│  │  • getWindows() → [WindowInfo]                  │   │
│  │  • saveFile() → file path                       │   │
│  └──────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────┤
│  Operating System APIs (macOS, Linux, Windows)          │
└─────────────────────────────────────────────────────────┘
```

---

## Component Architecture

### Frontend Component Hierarchy

```
App (root)
└── EditorLayout
    ├── Toolbar (top)
    │   ├── Capture Screen button (useScreenshot)
    │   ├── Capture Window dropdown
    │   └── Clear button
    │
    ├── Canvas Area (center)
    │   ├── CanvasEditor
    │   │   ├── Stage (Konva)
    │   │   │   ├── Layer (Background - Phase 05)
    │   │   │   │   └── BackgroundLayer (gradient/solid/transparent)
    │   │   │   ├── Layer (Image)
    │   │   │   │   └── Image (react-konva)
    │   │   │   ├── Layer (Crop Overlay - Phase 05)
    │   │   │   │   └── CropOverlay (draggable crop box)
    │   │   │   └── Layer (Annotations - Phase 04)
    │   │   │       └── AnnotationLayer (shapes, text)
    │   │   └── Zoom/Pan handlers
    │   └── ZoomControls (floating)
    │       ├── Zoom Out button
    │       ├── Zoom % display
    │       ├── Zoom In button
    │       └── Fit to Screen button
    │
    └── Sidebar (right - Phase 05+)
        ├── BackgroundPanel
        │   ├── Gradient presets grid (24 items)
        │   ├── Solid color buttons (6 items)
        │   ├── Transparent toggle
        │   └── Padding slider (0-200px)
        └── CropPanel (Phase 05)
            ├── Aspect ratio selector
            ├── Crop mode toggle
            └── Apply/Cancel buttons
```

---

## Data Flow Architecture

### Capture to Canvas Flow

```
User Action: Click "Capture Screen"
    ↓
Toolbar.handleCaptureFullscreen()
    ↓
useScreenshot.captureFullscreen()
    ↓
Tauri IPC → Backend
    ↓
xcap crate captures fullscreen → PNG bytes (Uint8Array)
    ↓
Tauri IPC → Frontend (PNG bytes)
    ↓
Toolbar.getImageDimensions(bytes)
    ↓
Create temp blob URL, load with Image element → width/height
    ↓
useCanvasStore.setImageFromBytes(bytes, width, height)
    ↓
Zustand creates blob URL from bytes: bytesToUrl(bytes)
    ↓
useImage hook loads blob URL → HTMLImageElement
    ↓
CanvasEditor receives image via useImage hook
    ↓
react-konva Stage renders Image to canvas
    ↓
Result: Screenshot displayed in interactive canvas
```

### State Flow Diagram

```
┌─────────────────────────────────────────────┐
│  useCanvasStore (Zustand)                   │
├─────────────────────────────────────────────┤
│ State:                                      │
│  • imageUrl: string | null                 │
│  • imageBytes: Uint8Array | null           │
│  • originalWidth/Height: number            │
│  • stageWidth/Height: number               │
│  • scale: number (zoom level)              │
│  • position: { x, y } (pan offset)         │
├─────────────────────────────────────────────┤
│ Actions:                                    │
│  • setImageFromBytes(bytes, w, h)          │
│  • setStageSize(w, h) - responsive         │
│  • setScale(scale) - clamps 0.1-5x        │
│  • setPosition(x, y) - pan movement       │
│  • resetView() - reset zoom/pan           │
│  • clearCanvas() - cleanup                │
└─────────────────────────────────────────────┘
         ↕ (subscribed by)
┌─────────────────────────────────────────────┐
│  Components (subscribe to relevant slices)  │
├─────────────────────────────────────────────┤
│  CanvasEditor:                              │
│   • imageUrl → useImage hook                │
│   • stageWidth/Height → responsive sizing  │
│   • scale, position → Stage transform      │
│                                             │
│  ZoomControls:                              │
│   • scale → display zoom %                  │
│   • setScale → zoom in/out                  │
│                                             │
│  Toolbar:                                   │
│   • imageUrl → enable/disable Clear button  │
│   • setImageFromBytes → after capture      │
└─────────────────────────────────────────────┘
```

---

## Module Dependency Graph

```
App.tsx
  ├── EditorLayout
  │   ├── Toolbar
  │   │   ├── useScreenshot (hook)
  │   │   │   └── screenshot-api.ts (utils)
  │   │   ├── useCanvasStore (Zustand)
  │   │   └── WindowInfo (type)
  │   │
  │   └── CanvasEditor
  │       ├── useCanvasStore (Zustand)
  │       ├── useImage (hook)
  │       └── react-konva library
  │
  └── ZoomControls
      └── useCanvasStore (Zustand)

Types:
  └── types/screenshot.ts
      └── WindowInfo interface

Stores:
  └── stores/canvas-store.ts
      └── CanvasState interface

Hooks:
  ├── hooks/use-screenshot.ts
  └── hooks/use-image.ts

Utils:
  └── utils/screenshot-api.ts
```

---

## Zustand Store Architecture

### Canvas Store Pattern

```typescript
// Single source of truth for canvas state
interface CanvasState {
  // Data layer
  imageUrl: string | null;           // Display URL (blob)
  imageBytes: Uint8Array | null;     // Raw data (memory)
  originalWidth: number;              // Image metadata
  originalHeight: number;

  // Viewport layer
  stageWidth: number;                 // Canvas size
  stageHeight: number;
  scale: number;                      // Zoom level (0.1-5)
  position: { x: number; y: number }; // Pan offset

  // Action creators
  setImageFromBytes: (bytes, w, h) => void;
  setStageSize: (w, h) => void;
  setScale: (scale) => void;
  setPosition: (x, y) => void;
  resetView: () => void;
  clearCanvas: () => void;
}

// Memory optimization: automatic blob URL cleanup
export const useCanvasStore = create<CanvasState>((set, get) => ({
  // Initial state
  imageUrl: null,
  // ...

  // Actions with memory management
  setImageFromBytes: (bytes, width, height) => {
    const oldUrl = get().imageUrl;  // Get old URL
    if (oldUrl) URL.revokeObjectURL(oldUrl);  // Clean up

    const url = bytesToUrl(bytes);  // Create new URL
    set({ imageUrl: url, imageBytes: bytes, originalWidth: width, originalHeight: height });
  },

  clearCanvas: () => {
    const oldUrl = get().imageUrl;
    if (oldUrl) URL.revokeObjectURL(oldUrl);
    set({ imageUrl: null, imageBytes: null });
  },
}));
```

### Why Zustand?
- Minimal boilerplate vs Redux
- No context wrapping needed
- Excellent TypeScript support
- Hooks API (familiar to React devs)
- Efficient subscriptions (only updated components re-render)
- Perfect for canvas-centric app with centralized state

---

## Hook Architecture

### Custom Hook Pattern: useScreenshot

```typescript
// Wrapper around Tauri IPC APIs
export function useScreenshot() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [waylandWarning, setWaylandWarning] = useState<string | null>(null);

  const captureFullscreen = useCallback(async (): Promise<Uint8Array | null> => {
    try {
      setLoading(true);
      setError(null);
      const bytes = await invoke<Uint8Array>('capture_fullscreen');
      return bytes;
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Unknown error';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  // Similar for captureWindow, getWindows, etc.

  return { captureFullscreen, captureWindow, getWindows, loading, error, waylandWarning };
}
```

### Custom Hook Pattern: useImage

```typescript
// Load image from blob URL and track status
export function useImage(url: string): [HTMLImageElement | null, ImageStatus] {
  const [image, setImage] = useState<HTMLImageElement | null>(null);
  const [status, setStatus] = useState<ImageStatus>('loading');

  useEffect(() => {
    if (!url) {
      setImage(null);
      return;
    }

    setStatus('loading');
    const img = new Image();

    img.onload = () => {
      setImage(img);
      setStatus('loaded');
    };

    img.onerror = () => {
      setImage(null);
      setStatus('error');
    };

    img.src = url;

    return () => {
      img.onload = null;
      img.onerror = null;
    };
  }, [url]);

  return [image, status];
}
```

---

## Canvas Rendering Architecture (Konva)

### Konva Stage Structure

```
Stage (Konva.Stage)
├── Layer 1: Image Layer
│   └── Image (KonvaImage)
│       ├── Image source: HTMLImageElement (from useImage)
│       ├── Position: (0, 0)
│       └── Size: original image dimensions
│
└── Layer 2: Annotations (Phase 04+)
    ├── Shape (rect, circle, arrow)
    ├── Text
    └── Path (brush strokes)

Stage Properties:
  • width: responsive to container
  • height: responsive to container
  • scaleX/scaleY: zoom level from store
  • x/y: pan position from store
  • draggable: true (enables pan)
  • onWheel: zoom handler
  • onDragEnd: pan handler
```

### Zoom/Pan Implementation

```typescript
// Mouse wheel zoom (point-to-zoom)
const handleWheel = (e: Konva.KonvaEventObject<WheelEvent>) => {
  e.evt.preventDefault();

  const stage = stageRef.current;
  const oldScale = scale;
  const pointer = stage.getPointerPosition();

  // Calculate where mouse points to in canvas space
  const mousePointTo = {
    x: (pointer.x - position.x) / oldScale,
    y: (pointer.y - position.y) / oldScale,
  };

  // Apply zoom
  const direction = e.evt.deltaY > 0 ? -1 : 1;
  const newScale = direction > 0 ? oldScale * ZOOM_FACTOR : oldScale / ZOOM_FACTOR;
  const clampedScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

  // Keep mouse point fixed while zooming
  setScale(clampedScale);
  setPosition(
    pointer.x - mousePointTo.x * clampedScale,
    pointer.y - mousePointTo.y * clampedScale
  );
};

// Click-drag pan
const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
  setPosition(e.target.x(), e.target.y());
};
```

---

## Memory Management Strategy

### Image Data Lifecycle

```
Capture
  ↓
PNG bytes: Uint8Array (stored in Zustand)
  ↓
Blob created: new Blob([bytes], { type: 'image/png' })
  ↓
Blob URL created: URL.createObjectURL(blob)
  ↓
Image loaded: useImage hook loads from URL
  ↓
Display: Konva Stage renders image
  ↓
User clears or loads new image
  ↓
Cleanup: URL.revokeObjectURL(oldUrl) [automatic in store]
  ↓
Blob GC: Browser garbage collects blob
  ↓
Memory freed: Uint8Array dereferenced and GC'd
```

### Memory Optimization Techniques
1. **Blob URL Cleanup:** Automatic revocation in store when clearing/replacing
2. **Event Listener Cleanup:** useEffect cleanup functions remove listeners
3. **No Caching:** Screenshots not persisted to disk (user controls)
4. **Reference Management:** Immediate cleanup of old objects

---

## Error Handling Architecture

### Error Flow

```
User Action
  ↓
Try Block
  ├─ invoke Tauri command
  ├─ parse response
  └─ update store
  ↓
Catch Block
  ├─ Log to console with context
  ├─ Set error state (hook)
  └─ Display to user (UI)
  ↓
Finally Block
  └─ Set loading = false
```

### Error Types

| Error | Handler | User Feedback |
|-------|---------|---------------|
| Capture failure | console.error | "Screenshot failed" |
| Permission denied | check Tauri capabilities | "No permission to capture" |
| Invalid window ID | validate before calling | "Window no longer available" |
| Image load error | useImage status | "Failed to load image" |
| Wayland limitation | warning display | Yellow warning banner |

---

## Performance Characteristics

### Bottlenecks & Optimizations

| Operation | Bottleneck | Optimization | Target |
|-----------|-----------|-------------|--------|
| **Screenshot** | OS API call | Native Rust (xcap) | < 500ms |
| **Image load** | Blob URL creation + Image decode | Async in useImage hook | < 200ms |
| **Canvas render** | Konva stage paint | GPU-accelerated canvas | 60 FPS |
| **Zoom** | Stage transform recalc | useCallback for handler | < 16ms |
| **Pan** | Layer position update | useCallback for handler | < 16ms |
| **Memory** | Blob URL storage | Auto-cleanup in store | < 200MB |

---

## Phase-by-Phase Architecture Evolution

### Phase 03: Canvas Foundation ✓
- ✓ Screenshot capture via Tauri
- ✓ Zustand state management
- ✓ Konva canvas with zoom/pan
- ✓ Responsive toolbar
- ✓ Memory management

### Phase 04: Annotation Tools ✓
- ✓ Shapes layer (rect, circle, arrow)
- ✓ Brush/pencil tool with colors
- ✓ Text tool with font selection
- ✓ Color picker
- ✓ Layer management UI (reorder, delete)
- ✓ Undo/redo with keyboard shortcuts

### Phase 05 (Current): Beautification & Cropping ✓
- ✓ Background layer with 3 modes:
  - Gradient backgrounds (24 presets)
  - Solid colors (6 base + custom)
  - Transparent (checkerboard pattern)
- ✓ Padding control (0-200px slider)
- ✓ Non-destructive crop tool:
  - 8 aspect ratio presets
  - Draggable crop box with transformer handles
  - Dimmed overlay for area preview
  - Aspect ratio constraint enforcement
- ✓ Right sidebar panels
  - Background preset selection
  - Crop mode toggle
- ✓ Real-time preview on canvas

### Phase 06 (Planned): Export System
- PNG/JPG/WebP export
- Compression quality settings
- File dialog integration
- Apply crop during export
- Clipboard copy option

### Phase 07 (Planned): Native Integration
- Global hotkey registration
- Tray/menu bar icon
- Auto-open after capture
- System notifications

### Phase 08 (Current): Polish & Distribution ✓
- macOS entitlements: screen recording permission, file access
- macOS minimum: OS 11.0 (Big Sur)
- Linux: AppImage + DEB packages, desktop entry integration
- Windows: NSIS installer with language selector
- CI/CD: GitHub Actions with multi-platform matrix builds
- Release automation: Tag-triggered builds with binary signing
- v1.0.0: Production release

---

## Security Considerations

### Data Security
- **No persistence:** Screenshots only in memory
- **No telemetry:** Offline-first, no network calls
- **User control:** Only save with explicit user action
- **Cleanup:** Auto-revoke URLs, prevent memory leaks

### Permission Model
- **Tauri capabilities:** Defined in capabilities/default.json
- **OS permissions:** Respect system privacy prompts
- **Window capture:** Check window ID before capturing

---

## Deployment Architecture

### Binary Distribution
```
BeautyShot.app (macOS)
  ├── Contents/
  │   ├── MacOS/beautyshot (executable)
  │   ├── Resources/ (icons, assets)
  │   └── Info.plist

beautyshot (Linux AppImage or Deb)
  └── App binary + dependencies

BeautyShot.exe (Windows)
  ├── beautyshot.exe (executable)
  ├── Dependencies/ (DLLs)
  └── Resources/
```

### Build System
- **Frontend:** Vite bundler
- **Backend:** Cargo (Rust)
- **Tauri CLI:** Orchestrates build process

---

## Integration Points

### Tauri IPC Commands (14 Total)

**Screenshot Module:**
```rust
#[tauri::command]
fn capture_fullscreen() -> Result<Vec<u8>, String>        // Base64 PNG
fn capture_region(x, y, w, h) -> Result<Vec<u8>, String> // Cropped region
fn capture_window(window_id: u32) -> Result<Vec<u8>, String>
fn get_monitors() -> Result<Vec<MonitorInfo>, String>
fn get_windows() -> Result<Vec<WindowInfo>, String>
```

**Overlay Module:**
```rust
fn create_overlay_window() -> Result<(), String>
fn close_overlay_window() -> Result<(), String>
fn get_screenshot_data() -> Result<String, String>       // Base64
fn clear_screenshot_data() -> Result<(), String>
```

**File Operations:**
```rust
fn save_file(path: String, data: Vec<u8>) -> Result<(), String>  // 50MB limit
fn get_pictures_dir() -> Result<String, String>
fn get_desktop_dir() -> Result<String, String>
```

**Shortcuts & Permissions:**
```rust
fn update_shortcuts(capture: String, region: String, window: String) -> Result<(), String>
fn check_screen_permission() -> Result<bool, String>     // macOS
fn check_wayland() -> Result<Option<String>, String>     // Linux
```

### Backend Events Emitted:
- `overlay-activate` - Overlay window shown
- `hotkey-capture` - Global Ctrl+Shift+C triggered
- `hotkey-capture-region` - Global region hotkey triggered
- `hotkey-capture-window` - Global window hotkey triggered
- `tray-capture` - System tray capture menu clicked

### Type Synchronization
- Frontend types in `src/types/`
- Backend types in `src-tauri/src/`
- Shared types via Tauri command signatures

---

## Testing Architecture

### Test Pyramid
```
        ╱╲
       ╱  ╲ E2E Tests
      ╱────╲ (workflow, cross-platform)
     ╱╲    ╱
    ╱  ╲  ╱ Integration Tests
   ╱────╲╱ (hooks, store, components)
  ╱╲    ╱
 ╱  ╲  ╱ Unit Tests
╱────╲╱ (functions, stores, utils)
```

### Test Coverage Goals
- **Unit:** > 80% (store, hooks, utils)
- **Integration:** Key workflows (capture → render)
- **E2E:** Screenshot workflow on all platforms

---

## Scalability Considerations

### Current Constraints
- Single image at a time in memory
- No collaborative editing
- No server backend

### Future Extensions
- **Multiple images:** History panel (phase future)
- **Batch processing:** Resize, convert multiple files
- **Cloud storage:** Optional server integration
- **Collaboration:** Real-time annotation sharing

---

## References

- [Tauri Architecture](https://tauri.app/v2/learn/)
- [Konva.js Documentation](https://konvajs.org/)
- [Zustand Pattern](https://github.com/pmndrs/zustand/wiki/Guide)
- [React Hooks Best Practices](https://react.dev/reference/react/hooks)

---

## Continuous Integration & Deployment

### CI Workflow (`.github/workflows/ci.yml`)

Runs on every push to master/main and pull requests:

```yaml
Jobs:
  1. test (Ubuntu latest)
     - Install Node 20
     - Install npm dependencies
     - Run: npm test -- --run --coverage
     - Run: npx tsc --noEmit (TypeScript check)
     - Verify: tests pass, type safety maintained

  2. build-check (Ubuntu 22.04)
     - Install Node 20 + Rust latest
     - Linux deps: libwebkit2gtk-4.1-dev, libgtk-3-dev, libayatana-appindicator3-dev
     - Run: npm run build (frontend)
     - Run: cargo check (Rust compilation)
     - Verify: build succeeds on all platforms
```

### Release Workflow (`.github/workflows/release.yml`)

Triggered by version tags (v*), builds and publishes production binaries:

```yaml
Build Matrix:
  - macOS (Intel): aarch64-apple-darwin
  - macOS (Apple Silicon): x86_64-apple-darwin
  - Windows: x86_64-pc-windows-msvc
  - Linux: x86_64-unknown-linux-gnu

Per-Platform Steps:
  1. Checkout code
  2. Setup Node 20
  3. Setup Rust with target
  4. Install platform-specific dependencies
  5. npm ci (frozen dependencies)
  6. Build via tauri-apps/tauri-action@v0
  7. Auto-signs binaries with TAURI_SIGNING_PRIVATE_KEY
  8. Creates GitHub release draft with assets

Post-Build:
  - Test job runs: npm test --run, tsc --noEmit
  - Release created as draft (manual review before publish)
  - Assets: DMG (macOS), EXE (Windows), AppImage + DEB (Linux)
```

### Platform-Specific Configuration

**macOS (src-tauri/tauri.conf.json):**
- Universal binary support (Intel + ARM)
- Code signing ready (signingIdentity, entitlements.plist)
- DMG installer
- Minimum OS: 11.0 (Big Sur)

**Windows:**
- NSIS installer with displayLanguageSelector
- webviewInstallMode: downloadBootstrapper

**Linux:**
- AppImage with media framework bundling
- DEB packages with dependencies: libwebkit2gtk-4.1-0, libgtk-3-0
- RPM epoch support

---

---

## Backend Architecture (Rust)

### Module Organization
```
src-tauri/src/
├── main.rs (6 LOC) - Entry point, Windows subsystem config
├── lib.rs (48 LOC) - Tauri initialization, plugin setup
├── screenshot.rs (148 LOC) - xcap integration, monitor/window enumeration
├── overlay.rs (126 LOC) - Fullscreen overlay creation/management
├── shortcuts.rs (155 LOC) - Global hotkey parsing and registration
├── file_ops.rs (71 LOC) - Secure file save with path validation
├── clipboard.rs (39 LOC) - PNG → system clipboard
├── tray.rs (69 LOC) - System tray icon and menu
└── permissions.rs (32 LOC) - macOS/Linux permission checks
```
**Total:** ~694 LOC

### Security Implementation
- **File Operations:** Path canonicalization, traversal prevention, 50MB limit
- **Screenshot:** xcap handles platform-specific capture APIs
- **Clipboard:** Base64 validation, image dimension checks
- **Hotkeys:** Input validation on hotkey format strings
- **Permissions:** macOS Screen Recording check, Wayland detection warning

### Dependencies
- **xcap** 0.8 - Cross-platform screenshot
- **image** 0.25 - PNG encoding
- **base64** 0.22 - Encoding/decoding
- **arboard** - Clipboard operations
- **tauri** 2.x - Framework
- **serde/serde_json** - Serialization

---

**Document Version:** 3.1
**Last Updated:** 2026-01-13
**Current Phase:** 08 - Polish & Distribution (Complete ✓)
**Release Status:** v1.0.0 - Production Ready
</file>

<file path="src/components/canvas/annotations/number-shape.tsx">
// NumberShape - Numbered annotation component (circled number)

import { Circle, Text, Group } from 'react-konva';
import type { NumberAnnotation } from '../../../types/annotations';
import { useAnnotationStore } from '../../../stores/annotation-store';

interface Props {
  annotation: NumberAnnotation;
}

export function NumberShape({ annotation }: Props) {
  const { updateAnnotation, setSelected } = useAnnotationStore();

  return (
    <Group
      id={annotation.id}
      x={annotation.x}
      y={annotation.y}
      draggable={annotation.draggable}
      onClick={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onTap={(e) => {
        e.cancelBubble = true;
        setSelected(annotation.id);
      }}
      onDragEnd={(e) => {
        updateAnnotation(annotation.id, {
          x: e.target.x(),
          y: e.target.y(),
        });
      }}
    >
      <Circle radius={annotation.radius} fill={annotation.fill} />
      <Text
        text={String(annotation.number)}
        fontSize={annotation.fontSize}
        fill={annotation.textColor}
        x={-annotation.radius}
        y={-annotation.fontSize / 2}
        width={annotation.radius * 2}
        align="center"
        listening={false}
      />
    </Group>
  );
}
</file>

<file path="src/components/canvas/annotation-layer.tsx">
// AnnotationLayer - Renders all annotations with Transformer support

import { useRef, useEffect } from 'react';
import { Layer, Transformer, Group } from 'react-konva';
import Konva from 'konva';
import { useAnnotationStore } from '../../stores/annotation-store';
import { useBackgroundStore } from '../../stores/background-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { ANNOTATION_DEFAULTS } from '../../constants/annotations';
import { logger } from '../../utils/logger';
import type { Annotation } from '../../types/annotations';
import { RectShape } from './annotations/rect-shape';
import { EllipseShape } from './annotations/ellipse-shape';
import { ArrowShape } from './annotations/arrow-shape';
import { FreehandShape } from './annotations/freehand-shape';
import { TextShape } from './annotations/text-shape';
import { NumberShape } from './annotations/number-shape';
import { SpotlightShape } from './annotations/spotlight-shape';

interface AnnotationLayerProps {
  offsetX?: number;
  offsetY?: number;
}

export function AnnotationLayer({ offsetX = 0, offsetY = 0 }: AnnotationLayerProps) {
  const transformerRef = useRef<Konva.Transformer>(null);
  const layerRef = useRef<Konva.Layer>(null);

  const { annotations, selectedId } = useAnnotationStore();
  const { originalWidth, originalHeight } = useCanvasStore();
  const { getPaddingPx } = useBackgroundStore();
  const padding = getPaddingPx(originalWidth, originalHeight);

  // Total offset includes aspect ratio extension offset + padding
  const totalOffsetX = offsetX + padding;
  const totalOffsetY = offsetY + padding;

  // Attach transformer to selected shape with cleanup
  useEffect(() => {
    const transformer = transformerRef.current;
    const layer = layerRef.current;

    if (!transformer || !layer) return;

    if (selectedId) {
      const node = layer.findOne(`#${selectedId}`);
      if (node) {
        transformer.nodes([node]);
        transformer.getLayer()?.batchDraw();
      }
    } else {
      transformer.nodes([]);
    }

    // Cleanup: detach nodes on unmount or selection change
    return () => {
      if (transformer) {
        transformer.nodes([]);
      }
    };
  }, [selectedId]);

  const renderAnnotation = (annotation: Annotation): React.ReactNode => {
    switch (annotation.type) {
      case 'rectangle':
        return <RectShape key={annotation.id} annotation={annotation} />;
      case 'ellipse':
        return <EllipseShape key={annotation.id} annotation={annotation} />;
      case 'line':
      case 'arrow':
        return <ArrowShape key={annotation.id} annotation={annotation} />;
      case 'freehand':
        return <FreehandShape key={annotation.id} annotation={annotation} />;
      case 'text':
        return <TextShape key={annotation.id} annotation={annotation} />;
      case 'number':
        return <NumberShape key={annotation.id} annotation={annotation} />;
      case 'spotlight':
        return <SpotlightShape key={annotation.id} annotation={annotation} />;
      default: {
        // Exhaustiveness check - TypeScript will error if a case is missed
        const _exhaustive: never = annotation;
        logger.warn('Unknown annotation type encountered', {
          context: 'AnnotationLayer',
          data: _exhaustive,
        });
        return null;
      }
    }
  };

  return (
    <Layer ref={layerRef}>
      {/* Offset annotations by aspect ratio extension + padding to align with image */}
      <Group x={totalOffsetX} y={totalOffsetY}>
        {annotations.map(renderAnnotation)}
        <Transformer
          ref={transformerRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Minimum size constraint
            const minSize = ANNOTATION_DEFAULTS.TRANSFORMER.MIN_SIZE;
            if (newBox.width < minSize || newBox.height < minSize) {
              return oldBox;
            }
            return newBox;
          }}
          rotateEnabled={true}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
            'middle-left',
            'middle-right',
            'top-center',
            'bottom-center',
          ]}
        />
      </Group>
    </Layer>
  );
}
</file>

<file path="src/components/canvas/background-layer.tsx">
// BackgroundLayer - Renders gradient/solid/transparent/wallpaper/image background

import { useEffect, useRef, useState } from 'react';
import { Rect, Shape, Image as KonvaImage, Group } from 'react-konva';
import Konva from 'konva';
import { useBackgroundStore } from '../../stores/background-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { parseWallpaperUrl } from '../../data/wallpapers';

// Debounce hook for performance
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Checkerboard pattern size for transparency
const CHECKER_SIZE = 10;

interface BackgroundLayerProps {
  canvasWidth?: number;
  canvasHeight?: number;
}

export function BackgroundLayer({ canvasWidth, canvasHeight }: BackgroundLayerProps) {
  const {
    type,
    gradient,
    solidColor,
    wallpaper,
    customImageUrl,
    autoColor,
    blurAmount,
    getPaddingPx,
  } = useBackgroundStore();
  const { originalWidth, originalHeight } = useCanvasStore();

  const groupRef = useRef<Konva.Group>(null);
  const imageRef = useRef<Konva.Image>(null);
  const [loadedImage, setLoadedImage] = useState<HTMLImageElement | null>(null);

  // Debounce blur amount for performance (cache operation is expensive)
  const debouncedBlurAmount = useDebounce(blurAmount, 50);

  const padding = getPaddingPx(originalWidth, originalHeight);

  // Use provided dimensions (for aspect ratio extension) or calculate from image
  const totalWidth = canvasWidth || originalWidth + padding * 2;
  const totalHeight = canvasHeight || originalHeight + padding * 2;

  // Load custom image or wallpaper image
  useEffect(() => {
    let imageUrl: string | null = null;

    if (type === 'image' && customImageUrl) {
      imageUrl = customImageUrl;
    } else if (type === 'wallpaper' && wallpaper) {
      const parsed = parseWallpaperUrl(wallpaper.url);
      if (parsed.type === 'image') {
        imageUrl = parsed.value;
      }
    }

    if (imageUrl && !imageUrl.startsWith('gradient:')) {
      const img = new window.Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => setLoadedImage(img);
      img.onerror = () => setLoadedImage(null);
      img.src = imageUrl;
    } else {
      setLoadedImage(null);
    }
  }, [type, customImageUrl, wallpaper]);

  // Apply blur filter for image backgrounds (debounced for performance)
  useEffect(() => {
    if (imageRef.current && loadedImage && debouncedBlurAmount > 0) {
      imageRef.current.clearCache();
      // Limit blur to 100px max for performance (higher values cause canvas memory issues)
      const effectiveBlur = Math.min(debouncedBlurAmount, 100);
      imageRef.current.cache();
      imageRef.current.filters([Konva.Filters.Blur]);
      imageRef.current.blurRadius(effectiveBlur);
      imageRef.current.getLayer()?.batchDraw();
    } else if (imageRef.current) {
      imageRef.current.clearCache();
      imageRef.current.filters([]);
      imageRef.current.getLayer()?.batchDraw();
    }
  }, [loadedImage, debouncedBlurAmount, totalWidth, totalHeight]);

  // Apply blur filter for non-image backgrounds (gradient, solid, wallpaper gradient) - debounced
  useEffect(() => {
    const isImageBackground = (type === 'image' && loadedImage) ||
      (type === 'wallpaper' && wallpaper && parseWallpaperUrl(wallpaper.url).type === 'image' && loadedImage);

    // Only apply group blur for non-image backgrounds
    if (groupRef.current && !isImageBackground && type !== 'transparent') {
      if (debouncedBlurAmount > 0) {
        groupRef.current.clearCache();
        // Limit blur to 100px max for performance (higher values cause canvas memory issues)
        const effectiveBlur = Math.min(debouncedBlurAmount, 100);
        groupRef.current.cache();
        groupRef.current.filters([Konva.Filters.Blur]);
        groupRef.current.blurRadius(effectiveBlur);
        groupRef.current.getLayer()?.batchDraw();
      } else {
        groupRef.current.clearCache();
        groupRef.current.filters([]);
        groupRef.current.getLayer()?.batchDraw();
      }
    }
  }, [type, wallpaper, loadedImage, debouncedBlurAmount, totalWidth, totalHeight, gradient, solidColor, autoColor]);

  // Don't render if no image loaded
  if (originalWidth === 0 || originalHeight === 0) {
    return null;
  }

  // Transparent: checkerboard pattern
  if (type === 'transparent') {
    return (
      <Shape
        sceneFunc={(ctx) => {
          for (let x = 0; x < totalWidth; x += CHECKER_SIZE) {
            for (let y = 0; y < totalHeight; y += CHECKER_SIZE) {
              const isEven =
                (Math.floor(x / CHECKER_SIZE) + Math.floor(y / CHECKER_SIZE)) %
                  2 ===
                0;
              ctx.fillStyle = isEven ? '#cccccc' : '#ffffff';
              ctx.fillRect(x, y, CHECKER_SIZE, CHECKER_SIZE);
            }
          }
        }}
        listening={false}
      />
    );
  }

  // Solid color background
  if (type === 'solid') {
    return (
      <Group ref={groupRef}>
        <Rect
          x={0}
          y={0}
          width={totalWidth}
          height={totalHeight}
          fill={solidColor}
          listening={false}
        />
      </Group>
    );
  }

  // Auto color background (calculated from screenshot)
  if (type === 'auto') {
    return (
      <Group ref={groupRef}>
        <Rect
          x={0}
          y={0}
          width={totalWidth}
          height={totalHeight}
          fill={autoColor || '#808080'}
          listening={false}
        />
      </Group>
    );
  }

  // Custom image background
  if (type === 'image') {
    if (loadedImage) {
      // Calculate scale to cover entire background while preserving aspect ratio
      const scaleX = totalWidth / loadedImage.width;
      const scaleY = totalHeight / loadedImage.height;
      const scale = Math.max(scaleX, scaleY);

      const scaledWidth = loadedImage.width * scale;
      const scaledHeight = loadedImage.height * scale;
      const offsetX = (totalWidth - scaledWidth) / 2;
      const offsetY = (totalHeight - scaledHeight) / 2;

      return (
        <Group
          clipX={0}
          clipY={0}
          clipWidth={totalWidth}
          clipHeight={totalHeight}
        >
          <KonvaImage
            ref={imageRef}
            image={loadedImage}
            x={offsetX}
            y={offsetY}
            width={scaledWidth}
            height={scaledHeight}
            listening={false}
          />
        </Group>
      );
    }
    // Loading fallback - solid dark background
    return (
      <Rect
        x={0}
        y={0}
        width={totalWidth}
        height={totalHeight}
        fill="#1a1a2e"
        listening={false}
      />
    );
  }

  // Wallpaper background
  if (type === 'wallpaper' && wallpaper) {
    const parsed = parseWallpaperUrl(wallpaper.url);

    // If wallpaper is an image
    if (parsed.type === 'image' && loadedImage) {
      // Calculate scale to cover entire background while preserving aspect ratio
      const scaleX = totalWidth / loadedImage.width;
      const scaleY = totalHeight / loadedImage.height;
      const scale = Math.max(scaleX, scaleY);

      const scaledWidth = loadedImage.width * scale;
      const scaledHeight = loadedImage.height * scale;
      const offsetX = (totalWidth - scaledWidth) / 2;
      const offsetY = (totalHeight - scaledHeight) / 2;

      return (
        <Group
          clipX={0}
          clipY={0}
          clipWidth={totalWidth}
          clipHeight={totalHeight}
        >
          <KonvaImage
            ref={imageRef}
            image={loadedImage}
            x={offsetX}
            y={offsetY}
            width={scaledWidth}
            height={scaledHeight}
            listening={false}
          />
        </Group>
      );
    }

    // If wallpaper is a gradient
    if (parsed.type === 'gradient') {
      return (
        <Group ref={groupRef}>
          <Shape
            sceneFunc={(ctx) => {
              // Parse the gradient CSS
              const gradientCss = parsed.value;

              // Simple parsing for linear and radial gradients
              if (gradientCss.startsWith('linear-gradient')) {
                const match = gradientCss.match(/linear-gradient\(([^,]+),\s*(.+)\)/);
                if (match) {
                  const direction = match[1].trim();
                  const colorsStr = match[2];

                  // Parse angle
                  let angle = 180;
                  if (direction.includes('deg')) {
                    angle = parseInt(direction.replace('deg', ''));
                  }

                  // Parse color stops
                  const colorStops = colorsStr.split(/,(?![^(]*\))/).map((s) => s.trim());
                  const colors: { color: string; position: number }[] = [];

                  colorStops.forEach((stop) => {
                    const parts = stop.split(/\s+/);
                    const color = parts[0];
                    const position = parts[1]
                      ? parseFloat(parts[1].replace('%', '')) / 100
                      : null;
                    if (color) {
                      colors.push({
                        color,
                        position: position ?? colors.length / (colorStops.length - 1),
                      });
                    }
                  });

                  // Create gradient
                  const angleRad = (angle * Math.PI) / 180;
                  const x1 = totalWidth / 2 - Math.cos(angleRad) * (totalWidth / 2);
                  const y1 = totalHeight / 2 - Math.sin(angleRad) * (totalHeight / 2);
                  const x2 = totalWidth / 2 + Math.cos(angleRad) * (totalWidth / 2);
                  const y2 = totalHeight / 2 + Math.sin(angleRad) * (totalHeight / 2);

                  const grd = ctx.createLinearGradient(x1, y1, x2, y2);
                  colors.forEach(({ color, position }) => {
                    grd.addColorStop(position, color);
                  });

                  ctx.fillStyle = grd;
                  ctx.fillRect(0, 0, totalWidth, totalHeight);
                }
              } else if (gradientCss.startsWith('radial-gradient')) {
                const match = gradientCss.match(/radial-gradient\([^,]+,\s*(.+)\)/);
                if (match) {
                  const colorsStr = match[1];
                  const colorStops = colorsStr.split(/,(?![^(]*\))/).map((s) => s.trim());
                  const colors: { color: string; position: number }[] = [];

                  colorStops.forEach((stop) => {
                    const parts = stop.split(/\s+/);
                    const color = parts[0];
                    const position = parts[1]
                      ? parseFloat(parts[1].replace('%', '')) / 100
                      : null;
                    if (color) {
                      colors.push({
                        color,
                        position: position ?? colors.length / (colorStops.length - 1),
                      });
                    }
                  });

                  const grd = ctx.createRadialGradient(
                    totalWidth / 2,
                    totalHeight / 2,
                    0,
                    totalWidth / 2,
                    totalHeight / 2,
                    Math.max(totalWidth, totalHeight) / 2
                  );
                  colors.forEach(({ color, position }) => {
                    grd.addColorStop(position, color);
                  });

                  ctx.fillStyle = grd;
                  ctx.fillRect(0, 0, totalWidth, totalHeight);
                }
              }
            }}
            listening={false}
          />
        </Group>
      );
    }
  }

  // Gradient background (default)
  if (!gradient) {
    return (
      <Group ref={groupRef}>
        <Rect
          x={0}
          y={0}
          width={totalWidth}
          height={totalHeight}
          fill="#ffffff"
          listening={false}
        />
      </Group>
    );
  }

  return (
    <Group ref={groupRef}>
      <Shape
        sceneFunc={(ctx) => {
          let grd: CanvasGradient;

          if (gradient.direction === 'radial') {
            grd = ctx.createRadialGradient(
              totalWidth / 2,
              totalHeight / 2,
              0,
              totalWidth / 2,
              totalHeight / 2,
              Math.max(totalWidth, totalHeight) / 2
            );
          } else {
            // Linear gradient based on angle
            const angleRad = ((gradient.angle || 0) * Math.PI) / 180;
            const x1 = totalWidth / 2 - Math.cos(angleRad) * (totalWidth / 2);
            const y1 = totalHeight / 2 - Math.sin(angleRad) * (totalHeight / 2);
            const x2 = totalWidth / 2 + Math.cos(angleRad) * (totalWidth / 2);
            const y2 = totalHeight / 2 + Math.sin(angleRad) * (totalHeight / 2);
            grd = ctx.createLinearGradient(x1, y1, x2, y2);
          }

          gradient.colors.forEach((color, i) => {
            grd.addColorStop(i / (gradient.colors.length - 1), color);
          });

          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, totalWidth, totalHeight);
        }}
        listening={false}
      />
    </Group>
  );
}
</file>

<file path="src/components/canvas/crop-overlay.tsx">
// CropOverlay - Non-destructive crop selection with aspect ratio support

import { useRef, useEffect, useCallback } from 'react';
import { Rect, Transformer, Group, Layer, Shape } from 'react-konva';
import type Konva from 'konva';
import { useCropStore } from '../../stores/crop-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { useBackgroundStore } from '../../stores/background-store';
import { useExportStore } from '../../stores/export-store';

// Minimum crop size
const MIN_CROP_SIZE = 50;

interface CropOverlayProps {
  offsetX?: number;
  offsetY?: number;
}

export function CropOverlay({ offsetX = 0, offsetY = 0 }: CropOverlayProps) {
  const rectRef = useRef<Konva.Rect>(null);
  const trRef = useRef<Konva.Transformer>(null);

  // Use selectors for proper Zustand 5.0 subscription
  const isCropping = useCropStore((state) => state.isCropping);
  const cropRect = useCropStore((state) => state.cropRect);
  const aspectRatio = useCropStore((state) => state.aspectRatio);
  const setCropRect = useCropStore((state) => state.setCropRect);
  const originalWidth = useCanvasStore((state) => state.originalWidth);
  const originalHeight = useCanvasStore((state) => state.originalHeight);
  const getPaddingPx = useBackgroundStore((state) => state.getPaddingPx);
  const isExporting = useExportStore((state) => state.isExporting);
  const padding = getPaddingPx(originalWidth, originalHeight);

  // Total offset includes aspect ratio extension offset + padding
  const totalOffsetX = offsetX + padding;
  const totalOffsetY = offsetY + padding;

  // Default crop rect: 80% of image centered
  const currentRect = cropRect || {
    x: originalWidth * 0.1,
    y: originalHeight * 0.1,
    width: originalWidth * 0.8,
    height: originalHeight * 0.8,
  };

  // Attach transformer to crop rect
  useEffect(() => {
    if (isCropping && trRef.current && rectRef.current) {
      trRef.current.nodes([rectRef.current]);
      trRef.current.getLayer()?.batchDraw();
    }

    return () => {
      if (trRef.current) {
        trRef.current.nodes([]);
      }
    };
  }, [isCropping]);

  // Sync rectRef position when cropRect changes externally
  useEffect(() => {
    if (rectRef.current && cropRect) {
      rectRef.current.position({ x: cropRect.x, y: cropRect.y });
      rectRef.current.size({ width: cropRect.width, height: cropRect.height });
      rectRef.current.getLayer()?.batchDraw();
    }
  }, [cropRect]);

  // Handle drag to move crop area
  const handleDragMove = useCallback(
    (e: Konva.KonvaEventObject<DragEvent>) => {
      const node = e.target;
      let x = node.x();
      let y = node.y();
      const width = node.width();
      const height = node.height();

      // Constrain to image bounds
      x = Math.max(0, Math.min(originalWidth - width, x));
      y = Math.max(0, Math.min(originalHeight - height, y));

      node.position({ x, y });
    },
    [originalWidth, originalHeight]
  );

  const handleDragEnd = useCallback(
    (e: Konva.KonvaEventObject<DragEvent>) => {
      const node = e.target;
      setCropRect({
        x: node.x(),
        y: node.y(),
        width: node.width(),
        height: node.height(),
      });
    },
    [setCropRect]
  );

  // Hide overlay when not cropping, no image, or during export
  if (!isCropping || originalWidth === 0 || isExporting) return null;

  return (
    <Layer>
      {/* Offset by aspect ratio extension + padding to align with image */}
      <Group x={totalOffsetX} y={totalOffsetY}>
        {/* Dimmed overlay with cutout for crop area */}
        <Shape
          sceneFunc={(ctx, shape) => {
            ctx.beginPath();
            // Outer rectangle (full image)
            ctx.rect(0, 0, originalWidth, originalHeight);
            // Inner rectangle (crop area) - counter-clockwise for cutout
            ctx.moveTo(currentRect.x, currentRect.y);
            ctx.lineTo(currentRect.x, currentRect.y + currentRect.height);
            ctx.lineTo(currentRect.x + currentRect.width, currentRect.y + currentRect.height);
            ctx.lineTo(currentRect.x + currentRect.width, currentRect.y);
            ctx.closePath();
            ctx.fillStrokeShape(shape);
          }}
          fill="rgba(0,0,0,0.5)"
          listening={false}
        />

        {/* Crop selection rectangle - draggable and resizable */}
        <Rect
          ref={rectRef}
          x={currentRect.x}
          y={currentRect.y}
          width={currentRect.width}
          height={currentRect.height}
          fill="transparent"
          stroke="white"
          strokeWidth={2}
          dash={[10, 5]}
          draggable={true}
          onDragMove={handleDragMove}
          onDragEnd={handleDragEnd}
          onTransformEnd={(e) => {
            const node = e.target;
            const scaleX = node.scaleX();
            const scaleY = node.scaleY();

            // Reset scale and apply to dimensions
            node.scaleX(1);
            node.scaleY(1);

            // Calculate new dimensions
            let x = node.x();
            let y = node.y();
            let width = Math.max(MIN_CROP_SIZE, node.width() * scaleX);
            let height = Math.max(MIN_CROP_SIZE, node.height() * scaleY);

            // Clamp to image bounds - only count the part inside the image
            if (x < 0) {
              width += x; // Reduce width by the overflow
              x = 0;
            }
            if (y < 0) {
              height += y; // Reduce height by the overflow
              y = 0;
            }
            if (x + width > originalWidth) {
              width = originalWidth - x;
            }
            if (y + height > originalHeight) {
              height = originalHeight - y;
            }

            // Ensure minimum size after clamping
            width = Math.max(MIN_CROP_SIZE, width);
            height = Math.max(MIN_CROP_SIZE, height);

            // Update node position to match clamped values
            node.position({ x, y });
            node.size({ width, height });

            setCropRect({ x, y, width, height });
          }}
        />

        <Transformer
          ref={trRef}
          keepRatio={aspectRatio !== null}
          rotateEnabled={false}
          borderStroke="white"
          borderStrokeWidth={0}
          anchorStroke="#0ea5e9"
          anchorFill="white"
          anchorSize={10}
          anchorCornerRadius={2}
          boundBoxFunc={(oldBox, newBox) => {
            // boundBoxFunc receives coordinates relative to parent (the Group)
            // So bounds are simply [0, originalWidth] and [0, originalHeight]
            let { x, y, width, height } = newBox;

            // Clamp left edge (min x = 0)
            if (x < 0) {
              width += x; // x is negative, so this reduces width
              x = 0;
            }

            // Clamp top edge (min y = 0)
            if (y < 0) {
              height += y; // y is negative, so this reduces height
              y = 0;
            }

            // Clamp right edge
            if (x + width > originalWidth) {
              width = originalWidth - x;
            }

            // Clamp bottom edge
            if (y + height > originalHeight) {
              height = originalHeight - y;
            }

            // Enforce aspect ratio if set
            if (aspectRatio !== null) {
              const targetRatio = aspectRatio;
              if (width / height > targetRatio) {
                height = width / targetRatio;
                // Re-check bottom bound after aspect ratio adjustment
                if (y + height > originalHeight) {
                  height = originalHeight - y;
                  width = height * targetRatio;
                }
              } else {
                width = height * targetRatio;
                // Re-check right bound after aspect ratio adjustment
                if (x + width > originalWidth) {
                  width = originalWidth - x;
                  height = width / targetRatio;
                }
              }
            }

            // Enforce minimum size - reject if too small
            if (width < MIN_CROP_SIZE || height < MIN_CROP_SIZE) {
              return oldBox;
            }

            return { x, y, width, height, rotation: newBox.rotation };
          }}
        />
      </Group>
    </Layer>
  );
}
</file>

<file path="src/components/permission-required.tsx">
// PermissionRequired - Startup permission check screen
// Blocks app until both Screen Recording AND Accessibility permissions are granted
// macOS caches permission state at app launch - restart required after granting

import { useCallback, useEffect, useState } from 'react';
import { invoke } from '@tauri-apps/api/core';
import { relaunch } from '@tauri-apps/plugin-process';

interface PermissionStatus {
  screenRecording: boolean;
  accessibility: boolean;
}

interface PermissionRequiredProps {
  onAllGranted: () => void;
}

// Check icon component
function CheckIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
    </svg>
  );
}

// X icon component
function XIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
  );
}

// Permission item component
function PermissionItem({
  title,
  description,
  granted,
  onOpenSettings,
}: {
  title: string;
  description: string;
  granted: boolean;
  onOpenSettings: () => void;
}) {
  return (
    <div className={`flex items-center gap-4 p-4 rounded-xl transition-all ${granted
      ? 'glass-flat border border-green-400/30'
      : 'glass-flat'
      }`}>
      {/* Status icon */}
      <div className={`w-10 h-10 rounded-full flex items-center justify-center shrink-0 ${granted
        ? 'bg-green-500'
        : 'glass-btn'
        }`}>
        {granted ? (
          <CheckIcon className="w-6 h-6 text-white" />
        ) : (
          <XIcon className="w-5 h-5 text-gray-500 dark:text-gray-400" />
        )}
      </div>

      {/* Info */}
      <div className="flex-1 min-w-0">
        <h3 className={`font-semibold ${granted ? 'text-green-600 dark:text-green-400' : 'text-gray-800 dark:text-gray-200'}`}>
          {title}
        </h3>
        <p className="text-sm text-gray-600 dark:text-gray-400">{description}</p>
      </div>

      {/* Action button */}
      {!granted && (
        <button
          onClick={onOpenSettings}
          className="px-4 py-2 glass-btn glass-btn-active text-orange-500 text-sm font-medium rounded-xl transition-all shrink-0"
        >
          Grant
        </button>
      )}
    </div>
  );
}

export function PermissionRequired({ onAllGranted }: PermissionRequiredProps) {
  const [permissions, setPermissions] = useState<PermissionStatus>({
    screenRecording: false,
    accessibility: false,
  });
  const [checking, setChecking] = useState(true);

  // Check permissions on mount
  const checkPermissions = useCallback(async () => {
    setChecking(true);
    try {
      const [screen, accessibility] = await Promise.all([
        invoke<boolean>('check_screen_permission'),
        invoke<boolean>('check_accessibility_permission'),
      ]);

      const status = { screenRecording: screen, accessibility };
      setPermissions(status);

      // If all granted, call callback
      if (screen && accessibility) {
        onAllGranted();
      }
    } catch (error) {
      console.error('Failed to check permissions:', error);
    } finally {
      setChecking(false);
    }
  }, [onAllGranted]);

  useEffect(() => {
    checkPermissions();
  }, [checkPermissions]);

  // Directly open settings without triggering system dialogs
  const openScreenSettings = useCallback(async () => {
    try {
      await invoke('open_screen_recording_settings');
    } catch (error) {
      console.error('Failed to open screen recording settings:', error);
    }
  }, []);

  // Directly open settings without triggering system dialogs
  const openAccessibilitySettings = useCallback(async () => {
    try {
      await invoke('open_accessibility_settings');
    } catch (error) {
      console.error('Failed to open accessibility settings:', error);
    }
  }, []);

  const restartApp = useCallback(async () => {
    try {
      await relaunch();
    } catch (error) {
      console.error('Failed to restart:', error);
      // Fallback: just recheck
      checkPermissions();
    }
  }, [checkPermissions]);

  const allGranted = permissions.screenRecording && permissions.accessibility;
  const anyGranted = permissions.screenRecording || permissions.accessibility;

  return (
    <div className="fixed inset-0 canvas-area flex items-center justify-center p-6">
      <div className="max-w-lg w-full glass-heavy floating-panel overflow-hidden">
        {/* Header */}
        <div className="bg-gradient-to-r from-orange-500 to-amber-600 px-8 py-6 text-white">
          <h1 className="text-2xl font-bold mb-1">Permissions Required</h1>
          <p className="text-orange-100 text-sm">
            beautiFULLshot needs these permissions to work properly
          </p>
        </div>

        {/* Content */}
        <div className="p-6 space-y-4">
          {/* Permission items */}
          <PermissionItem
            title="Accessibility"
            description="Required for global keyboard shortcuts"
            granted={permissions.accessibility}
            onOpenSettings={openAccessibilitySettings}
          />

          <PermissionItem
            title="Screen Recording"
            description="Required to capture screenshots"
            granted={permissions.screenRecording}
            onOpenSettings={openScreenSettings}
          />

          {/* Instructions */}
          {!allGranted && (
            <div className="glass-flat rounded-xl p-4 mt-4 border border-amber-400/20">
              <p className="text-sm text-amber-700 dark:text-amber-300 font-medium mb-2">
                After enabling permissions:
              </p>
              <p className="text-sm text-amber-600 dark:text-amber-400">
                macOS requires an app restart for permission changes to take effect. Click <strong>"Restart App"</strong> below after enabling.
              </p>
            </div>
          )}

          {/* Actions */}
          <div className="flex gap-3 pt-2">
            {anyGranted && !allGranted ? (
              <>
                <button
                  onClick={restartApp}
                  disabled={checking}
                  className="flex-1 px-4 py-3 glass-btn glass-btn-active text-orange-500 disabled:opacity-50 font-medium rounded-xl transition-all"
                >
                  Restart App
                </button>
                <button
                  onClick={checkPermissions}
                  disabled={checking}
                  className="px-4 py-3 glass-btn text-gray-600 dark:text-gray-300 font-medium rounded-xl transition-all"
                >
                  {checking ? 'Checking...' : 'Recheck'}
                </button>
              </>
            ) : !allGranted ? (
              <button
                onClick={checkPermissions}
                disabled={checking}
                className="w-full px-4 py-3 glass-btn text-gray-600 dark:text-gray-300 font-medium rounded-xl transition-all"
              >
                {checking ? 'Checking permissions...' : 'Check Again'}
              </button>
            ) : null}
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 pb-6">
          <p className="text-xs text-center text-gray-500 dark:text-gray-400">
            These permissions are only used for screenshot capture and keyboard shortcuts.
            <br />
            Your privacy is respected - no data is collected.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/hooks/use-keyboard-shortcuts.ts">
// useKeyboardShortcuts - Keyboard shortcuts for canvas operations and export

import { useEffect, useCallback } from 'react';
import { useAnnotationStore } from '../stores/annotation-store';
import { useSettingsStore } from '../stores/settings-store';
import { useExport } from './use-export';

/**
 * Parse hotkey string to check if it matches a keyboard event
 * Format: "Modifier+Modifier+Key" (e.g., "CommandOrControl+Shift+C")
 */
function matchesHotkey(e: KeyboardEvent, hotkey: string): boolean {
  if (!hotkey) return false;

  const parts = hotkey.split('+').map((p) => p.trim().toLowerCase());
  const key = parts[parts.length - 1];
  const modifiers = parts.slice(0, -1);

  // Check key
  const pressedKey = e.key.toLowerCase();
  const keyCode = e.code.toLowerCase();

  // Match key (support both key name and code)
  const keyMatches =
    pressedKey === key ||
    keyCode === `key${key}` ||
    keyCode === `digit${key}` ||
    keyCode === key;

  if (!keyMatches) return false;

  // Check modifiers
  const needsCtrl = modifiers.some((m) =>
    ['commandorcontrol', 'control', 'ctrl'].includes(m)
  );
  const needsCmd = modifiers.some((m) =>
    ['commandorcontrol', 'command', 'cmd', 'meta', 'super'].includes(m)
  );
  const needsShift = modifiers.some((m) => m === 'shift');
  const needsAlt = modifiers.some((m) => m === 'alt');

  // CommandOrControl matches either Ctrl or Cmd
  const ctrlOrCmdMatches = needsCtrl || needsCmd ? e.ctrlKey || e.metaKey : true;
  const ctrlOrCmdRequired = needsCtrl || needsCmd;

  if (ctrlOrCmdRequired && !ctrlOrCmdMatches) return false;
  if (!ctrlOrCmdRequired && (e.ctrlKey || e.metaKey)) return false;

  if (needsShift !== e.shiftKey) return false;
  if (needsAlt !== e.altKey) return false;

  return true;
}

export function useKeyboardShortcuts() {
  const { selectedId, deleteSelected, setSelected, setTool, undo, redo } = useAnnotationStore();
  const { hotkeys } = useSettingsStore();
  const { quickSave, copyToClipboard } = useExport();

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      // Ignore if user is typing in an input
      if (
        e.target instanceof HTMLInputElement ||
        e.target instanceof HTMLTextAreaElement
      ) {
        return;
      }

      const isMod = e.metaKey || e.ctrlKey;

      // Check custom hotkeys from settings
      if (matchesHotkey(e, hotkeys.save)) {
        e.preventDefault();
        quickSave();
        return;
      }

      if (matchesHotkey(e, hotkeys.copy)) {
        e.preventDefault();
        copyToClipboard();
        return;
      }

      // Cmd/Ctrl shortcuts (hardcoded ones like undo/redo)
      if (isMod) {
        switch (e.key.toLowerCase()) {
          case 'z':
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
            return;
          case 'y':
            e.preventDefault();
            redo();
            return;
        }
      }

      switch (e.key) {
        case 'Delete':
        case 'Backspace':
          if (selectedId) {
            e.preventDefault();
            deleteSelected();
          }
          break;

        case 'Escape':
          setSelected(null);
          setTool('select');
          break;

        // Tool shortcuts (only when no modifier)
        case 'v':
        case 'V':
          if (!isMod) setTool('select');
          break;
        case 'r':
        case 'R':
          if (!isMod) setTool('rectangle');
          break;
        case 'e':
        case 'E':
          if (!isMod) setTool('ellipse');
          break;
        case 'l':
        case 'L':
          if (!isMod) setTool('line');
          break;
        case 'a':
        case 'A':
          if (!isMod) setTool('arrow');
          break;
        case 't':
        case 'T':
          if (!isMod) setTool('text');
          break;
        case 'f':
        case 'F':
          if (!isMod) setTool('freehand');
          break;
        case 's':
        case 'S':
          if (!isMod) setTool('spotlight');
          break;
      }
    },
    [selectedId, deleteSelected, setSelected, setTool, quickSave, copyToClipboard, undo, redo, hotkeys]
  );

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
}
</file>

<file path="src-tauri/src/shortcuts.rs">
// Global shortcuts - register system-wide keyboard shortcuts

use tauri::{Emitter, Manager};
use tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut, ShortcutState};

/// Parse hotkey string to Shortcut
/// Format: "Modifier+Modifier+Key" (e.g., "CommandOrControl+Shift+C")
fn parse_hotkey(hotkey: &str) -> Option<Shortcut> {
    let parts: Vec<&str> = hotkey.split('+').map(|s| s.trim()).collect();
    if parts.len() < 2 {
        return None;
    }

    let key_str = parts.last()?;
    let modifier_strs = &parts[..parts.len() - 1];

    // Parse modifiers
    let mut modifiers = Modifiers::empty();
    for m in modifier_strs {
        match m.to_lowercase().as_str() {
            "control" | "ctrl" => modifiers |= Modifiers::CONTROL,
            "command" | "cmd" | "super" | "meta" => modifiers |= Modifiers::SUPER,
            "shift" => modifiers |= Modifiers::SHIFT,
            "alt" | "option" => modifiers |= Modifiers::ALT,
            "commandorcontrol" => {
                #[cfg(target_os = "macos")]
                {
                    modifiers |= Modifiers::SUPER;
                }
                #[cfg(not(target_os = "macos"))]
                {
                    modifiers |= Modifiers::CONTROL;
                }
            }
            _ => return None,
        }
    }

    // Parse key code
    let code = match key_str.to_uppercase().as_str() {
        "A" => Code::KeyA,
        "B" => Code::KeyB,
        "C" => Code::KeyC,
        "D" => Code::KeyD,
        "E" => Code::KeyE,
        "F" => Code::KeyF,
        "G" => Code::KeyG,
        "H" => Code::KeyH,
        "I" => Code::KeyI,
        "J" => Code::KeyJ,
        "K" => Code::KeyK,
        "L" => Code::KeyL,
        "M" => Code::KeyM,
        "N" => Code::KeyN,
        "O" => Code::KeyO,
        "P" => Code::KeyP,
        "Q" => Code::KeyQ,
        "R" => Code::KeyR,
        "S" => Code::KeyS,
        "T" => Code::KeyT,
        "U" => Code::KeyU,
        "V" => Code::KeyV,
        "W" => Code::KeyW,
        "X" => Code::KeyX,
        "Y" => Code::KeyY,
        "Z" => Code::KeyZ,
        "0" => Code::Digit0,
        "1" => Code::Digit1,
        "2" => Code::Digit2,
        "3" => Code::Digit3,
        "4" => Code::Digit4,
        "5" => Code::Digit5,
        "6" => Code::Digit6,
        "7" => Code::Digit7,
        "8" => Code::Digit8,
        "9" => Code::Digit9,
        "F1" => Code::F1,
        "F2" => Code::F2,
        "F3" => Code::F3,
        "F4" => Code::F4,
        "F5" => Code::F5,
        "F6" => Code::F6,
        "F7" => Code::F7,
        "F8" => Code::F8,
        "F9" => Code::F9,
        "F10" => Code::F10,
        "F11" => Code::F11,
        "F12" => Code::F12,
        "SPACE" => Code::Space,
        "ENTER" => Code::Enter,
        "ESCAPE" => Code::Escape,
        "TAB" => Code::Tab,
        "BACKSPACE" => Code::Backspace,
        "DELETE" => Code::Delete,
        "INSERT" => Code::Insert,
        "HOME" => Code::Home,
        "END" => Code::End,
        "PAGEUP" => Code::PageUp,
        "PAGEDOWN" => Code::PageDown,
        "ARROWUP" => Code::ArrowUp,
        "ARROWDOWN" => Code::ArrowDown,
        "ARROWLEFT" => Code::ArrowLeft,
        "ARROWRIGHT" => Code::ArrowRight,
        "PRINTSCREEN" => Code::PrintScreen,
        _ => return None,
    };

    Some(Shortcut::new(Some(modifiers), code))
}

/// Register a single global shortcut with an event name
fn register_shortcut(
    app: &tauri::AppHandle,
    hotkey: &str,
    event_name: &'static str,
) -> Result<(), Box<dyn std::error::Error>> {
    let shortcut =
        parse_hotkey(hotkey).ok_or_else(|| format!("Invalid hotkey format: {}", hotkey))?;

    app.global_shortcut()
        .on_shortcut(shortcut, move |app, _shortcut, event| {
            if event.state == ShortcutState::Pressed {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.emit(event_name, ());
                }
            }
        })?;

    println!("Registered shortcut: {} -> {}", hotkey, event_name);
    Ok(())
}

/// Tauri command to update shortcuts from frontend settings
/// Returns list of shortcuts that failed to register (empty if all succeeded)
#[tauri::command]
pub fn update_shortcuts(
    app: tauri::AppHandle,
    capture: String,
    capture_region: String,
    capture_window: String,
) -> Result<Vec<String>, String> {
    // Unregister all existing shortcuts
    let _ = app.global_shortcut().unregister_all();

    let mut errors: Vec<String> = Vec::new();

    // Register new shortcuts - continue even if one fails
    if !capture.is_empty() {
        if let Err(e) = register_shortcut(&app, &capture, "hotkey-capture") {
            errors.push(format!("Capture ({}): {}", capture, e));
        }
    }
    if !capture_region.is_empty() {
        if let Err(e) = register_shortcut(&app, &capture_region, "hotkey-capture-region") {
            errors.push(format!("Capture Region ({}): {}", capture_region, e));
        }
    }
    if !capture_window.is_empty() {
        if let Err(e) = register_shortcut(&app, &capture_window, "hotkey-capture-window") {
            errors.push(format!("Capture Window ({}): {}", capture_window, e));
        }
    }

    Ok(errors)
}
</file>

<file path="src-tauri/src/tray.rs">
// System tray - tray icon and menu for BeautyShot

use std::sync::atomic::Ordering;
use tauri::{
    menu::{Menu, MenuItem, PredefinedMenuItem},
    tray::{MouseButton, MouseButtonState, TrayIcon, TrayIconBuilder, TrayIconEvent},
    AppHandle, Emitter, Manager, Runtime,
};

use crate::SHOULD_QUIT;

/// Creates and configures the system tray icon with menu
pub fn create_tray<R: Runtime>(app: &tauri::AppHandle<R>) -> tauri::Result<()> {
    // Capture menu items
    let capture_screen = MenuItem::with_id(app, "capture_screen", "Capture Screen", true, None::<&str>)?;
    let capture_region = MenuItem::with_id(app, "capture_region", "Capture Region", true, None::<&str>)?;
    let capture_window = MenuItem::with_id(app, "capture_window", "Capture Window", true, None::<&str>)?;
    let separator1 = PredefinedMenuItem::separator(app)?;
    let show_item = MenuItem::with_id(app, "show", "Show Window", true, None::<&str>)?;
    let separator2 = PredefinedMenuItem::separator(app)?;
    let quit_item = MenuItem::with_id(app, "quit", "Quit beautiFULLshot", true, None::<&str>)?;

    // Build menu
    let menu = Menu::with_items(app, &[
        &capture_screen,
        &capture_region,
        &capture_window,
        &separator1,
        &show_item,
        &separator2,
        &quit_item,
    ])?;

    // Get app icon for tray
    let icon = app
        .default_window_icon()
        .cloned()
        .ok_or_else(|| tauri::Error::AssetNotFound("default window icon".to_string()))?;

    // Build tray icon
    let _tray = TrayIconBuilder::<R>::new()
        .icon(icon.clone())
        .menu(&menu)
        .show_menu_on_left_click(false)
        .tooltip("beautiFULLshot")
        // macOS: don't use template mode so colorful icons display correctly
        .icon_as_template(false)
        .on_menu_event(|app: &AppHandle<R>, event| match event.id.as_ref() {
            "quit" => {
                // Set flag so ExitRequested handler allows quit
                SHOULD_QUIT.store(true, Ordering::SeqCst);
                app.exit(0);
            }
            "show" => {
                // On macOS, restore dock icon before showing window
                #[cfg(target_os = "macos")]
                let _ = app.set_activation_policy(tauri::ActivationPolicy::Regular);

                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.show();
                    let _ = window.unminimize();
                    let _ = window.set_focus();
                }
            }
            "capture_screen" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.emit("tray-capture-screen", ());
                }
            }
            "capture_region" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.emit("tray-capture-region", ());
                }
            }
            "capture_window" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.emit("tray-capture-window", ());
                }
            }
            _ => {}
        })
        .on_tray_icon_event(|tray: &TrayIcon<R>, event| {
            // Left click on tray icon shows window
            if let TrayIconEvent::Click {
                button: MouseButton::Left,
                button_state: MouseButtonState::Up,
                ..
            } = event
            {
                let app = tray.app_handle();

                // On macOS, restore dock icon before showing window
                #[cfg(target_os = "macos")]
                let _ = app.set_activation_policy(tauri::ActivationPolicy::Regular);

                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.show();
                    let _ = window.unminimize();
                    let _ = window.set_focus();
                }
            }
        })
        .build(app)?;

    Ok(())
}
</file>

<file path="README.md">
# BeautyFullShot

Cross-platform screenshot beautification app built with Tauri v2 + React + TypeScript.

## Features

- **Screenshot Capture**: Fullscreen, region, and window capture
- **Annotation Tools**: Shapes (rectangle, ellipse), arrows, lines, text, numbered annotations, spotlight effect
- **Beautification**: 24+ gradient backgrounds, aspect ratio cropping
- **Export Options**: PNG/JPEG with quality control, 1x/2x/3x resolution, clipboard copy
- **Native Integration**: System tray, global hotkeys, notifications
- **Cross-Platform**: Windows, macOS, Linux (X11)

## Installation

### Windows
Download `BeautyFullShot_x.x.x_x64-setup.exe` from [Releases](../../releases).

### macOS
Download `BeautyFullShot_x.x.x_x64.dmg` from [Releases](../../releases).
Drag to Applications folder.

> **Note**: First launch may require allowing the app in Security & Privacy settings.
> Screen recording permission is required for screenshot capture.

### Linux
Download `BeautyFullShot_x.x.x_amd64.AppImage` from [Releases](../../releases).

```bash
chmod +x BeautyFullShot_*.AppImage
./BeautyFullShot_*.AppImage
```

> **Note**: X11 is required. Wayland has limited support.

## Keyboard Shortcuts

| Action | Shortcut |
|--------|----------|
| Capture Screen | Cmd/Ctrl+Shift+C |
| Delete Selected | Delete/Backspace |
| Quick Save | Cmd/Ctrl+S |
| Copy to Clipboard | Cmd/Ctrl+Shift+V |
| Undo | Cmd/Ctrl+Z |
| Redo | Cmd/Ctrl+Shift+Z or Cmd/Ctrl+Y |

## Development

### Prerequisites

- Rust 1.70+
- Node.js 18+
- Platform-specific build tools:
  - **Windows**: Microsoft Visual Studio Build Tools
  - **macOS**: Xcode Command Line Tools
  - **Linux**: `libwebkit2gtk-4.1-dev`, `libgtk-3-dev`

### Setup

```bash
# Clone repository
git clone https://github.com/your-username/beautyfullshot.git
cd beautyfullshot

# Install dependencies
npm install

# Run development server
npm run tauri dev

# Run tests
npm test

# Build for production
npm run tauri build
```

### Project Structure

```
beautyfullshot/
├── src/                    # React frontend
│   ├── components/         # UI components
│   ├── stores/            # Zustand state management
│   ├── hooks/             # Custom React hooks
│   ├── types/             # TypeScript types
│   └── utils/             # Utility functions
├── src-tauri/             # Rust backend
│   ├── src/               # Tauri commands
│   └── icons/             # App icons
├── docs/                  # Documentation
└── plans/                 # Implementation plans
```

## Tech Stack

| Layer | Technology |
|-------|------------|
| Framework | Tauri v2 |
| Backend | Rust + xcap |
| Frontend | React 19 + TypeScript + Vite |
| Canvas | react-konva + Konva |
| Styling | Tailwind CSS v4 |
| State | Zustand |
| Testing | Vitest |

## Performance Targets

| Metric | Target |
|--------|--------|
| Bundle Size | < 15MB |
| Cold Start | < 1s |
| RAM (idle) | < 100MB |

## License

MIT License - see [LICENSE](LICENSE) for details.

## Contributing

Contributions are welcome! Please read the [docs/code-standards.md](docs/code-standards.md) before submitting PRs.
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
  plugins: [react(), tailwindcss()],

  // Enable multi-page support for dev server
  appType: 'mpa' as const,

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent Vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell Vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },

  // Code splitting to reduce bundle size + multi-page build
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        overlay: resolve(__dirname, 'overlay.html'),
      },
      output: {
        manualChunks: {
          // Vendor chunks - split large dependencies
          'react-vendor': ['react', 'react-dom'],
          'konva': ['konva', 'react-konva'],
          'tauri-api': [
            '@tauri-apps/api',
            '@tauri-apps/plugin-dialog',
            '@tauri-apps/plugin-notification',
          ],
          'zustand': ['zustand'],
        },
      },
    },
  },
}));
</file>

<file path="src/components/region-overlay.tsx">
// Region overlay component - Fullscreen overlay for interactive region selection
// Persistent window that shows/hides, displays captured screenshot as background

import { useState, useEffect, useCallback, useRef } from 'react';
import { getCurrentWindow, Window } from '@tauri-apps/api/window';
import { listen } from '@tauri-apps/api/event';
import { invoke } from '@tauri-apps/api/core';

interface SelectionRect {
  startX: number;
  startY: number;
  endX: number;
  endY: number;
}

export function RegionOverlay() {
  const [isSelecting, setIsSelecting] = useState(false);
  const [selection, setSelection] = useState<SelectionRect | null>(null);
  const [scaleFactor, setScaleFactor] = useState(1);
  const [backgroundImage, setBackgroundImage] = useState<string | null>(null);
  const [isClosing, setIsClosing] = useState(false);
  const [isActive, setIsActive] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // Hide overlay and reset state
  // IMPORTANT: Hide window BEFORE emitting event to prevent capturing overlay UI
  // NOTE: Don't clear screenshot data here - main window needs it to crop the region
  const hideOverlay = useCallback(async (emitSelection: boolean, region?: { x: number, y: number, width: number, height: number }) => {
    if (isClosing) return;
    setIsClosing(true);

    // Reset visual state immediately to prevent UI from being captured
    setIsActive(false);
    setIsSelecting(false);
    setSelection(null);

    // Hide window FIRST (before capture triggers)
    try {
      const win = getCurrentWindow();
      await win.hide();
    } catch (e) {
      console.error('Hide window error:', e);
    }

    // Wait for window compositor to fully hide the overlay
    // macOS: 50-100ms, Windows: 100-200ms, Linux: 50-150ms
    await new Promise(resolve => setTimeout(resolve, 150));

    // Emit event to main window (after overlay is fully hidden)
    // NOTE: Screenshot data is NOT cleared here - main window will use it to crop region
    // and then clear it after extracting
    try {
      const mainWindow = new Window('main');
      if (emitSelection && region) {
        await mainWindow.emit('region-selected', region);
      } else {
        // Clear screenshot data only on cancel (not needed)
        await invoke('clear_screenshot_data');
        await mainWindow.emit('region-selection-cancelled', {});
      }
    } catch (e) {
      console.error('Emit error:', e);
    }

    // Final cleanup
    setBackgroundImage(null);
    setIsClosing(false);
  }, [isClosing]);

  // Activate overlay - load screenshot and show
  const activateOverlay = useCallback(async () => {
    // Reset state
    setIsSelecting(false);
    setSelection(null);
    setIsClosing(false);

    try {
      const win = getCurrentWindow();
      const factor = await win.scaleFactor();
      setScaleFactor(factor);

      // Load screenshot as background
      const screenshotData = await invoke<string | null>('get_screenshot_data');
      if (screenshotData) {
        // Preload image
        const img = new Image();
        img.onload = async () => {
          setBackgroundImage(`data:image/png;base64,${screenshotData}`);
          setIsActive(true);
          document.getElementById('root')?.classList.add('ready');
          await win.show();
          await win.setFocus();
        };
        img.onerror = async () => {
          console.error('Failed to load screenshot');
          setIsActive(true);
          document.getElementById('root')?.classList.add('ready');
          await win.show();
          await win.setFocus();
        };
        img.src = `data:image/png;base64,${screenshotData}`;
      } else {
        console.warn('No screenshot data available');
        setIsActive(true);
        document.getElementById('root')?.classList.add('ready');
        await win.show();
        await win.setFocus();
      }
    } catch (e) {
      console.error('Activate error:', e);
      setScaleFactor(1);
      setIsActive(true);
    }
  }, []);

  // Listen for activation event from Rust
  useEffect(() => {
    let unlisten: (() => void) | null = null;

    listen('overlay-activate', () => {
      activateOverlay();
    }).then((fn) => {
      unlisten = fn;
    });

    return () => {
      unlisten?.();
    };
  }, [activateOverlay]);

  // Handle ESC key to cancel selection
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isActive) return;
      if (e.key === 'Escape' || e.code === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        hideOverlay(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown, true);
    document.addEventListener('keydown', handleKeyDown, true);

    return () => {
      window.removeEventListener('keydown', handleKeyDown, true);
      document.removeEventListener('keydown', handleKeyDown, true);
    };
  }, [hideOverlay, isActive]);

  // Auto-activate on mount (handles window creation race condition)
  // When overlay is created on-demand, this ensures it activates even if
  // the overlay-activate event is emitted before the listener is set up
  useEffect(() => {
    activateOverlay();
  }, [activateOverlay]);

  // Focus container when active
  useEffect(() => {
    if (isActive && containerRef.current) {
      containerRef.current.focus();
    }
  }, [isActive]);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (isClosing || !isActive) return;
    e.preventDefault();
    e.stopPropagation();
    setIsSelecting(true);
    setSelection({
      startX: e.clientX,
      startY: e.clientY,
      endX: e.clientX,
      endY: e.clientY,
    });
  }, [isClosing, isActive]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isSelecting || isClosing) return;
    e.preventDefault();
    setSelection(prev => prev ? {
      ...prev,
      endX: e.clientX,
      endY: e.clientY,
    } : null);
  }, [isSelecting, isClosing]);

  const handleMouseUp = useCallback((e: React.MouseEvent) => {
    if (isClosing || !isSelecting || !selection) return;
    e.preventDefault();

    setIsSelecting(false);

    const x = Math.min(selection.startX, selection.endX);
    const y = Math.min(selection.startY, selection.endY);
    const width = Math.abs(selection.endX - selection.startX);
    const height = Math.abs(selection.endY - selection.startY);

    // Minimum selection size
    if (width < 10 || height < 10) {
      hideOverlay(false);
      return;
    }

    // Convert to physical pixels for capture
    const region = {
      x: Math.round(x * scaleFactor),
      y: Math.round(y * scaleFactor),
      width: Math.round(width * scaleFactor),
      height: Math.round(height * scaleFactor),
    };

    hideOverlay(true, region);
  }, [isSelecting, selection, scaleFactor, hideOverlay, isClosing]);

  // Calculate selection box style
  const getSelectionStyle = (): React.CSSProperties => {
    if (!selection) return { display: 'none' };

    const x = Math.min(selection.startX, selection.endX);
    const y = Math.min(selection.startY, selection.endY);
    const width = Math.abs(selection.endX - selection.startX);
    const height = Math.abs(selection.endY - selection.startY);

    return {
      position: 'absolute',
      left: x,
      top: y,
      width,
      height,
      border: '2px solid #0078d4',
      backgroundColor: 'transparent',
      boxShadow: '0 0 0 9999px rgba(0, 0, 0, 0.4)',
      pointerEvents: 'none',
      zIndex: 10,
    };
  };

  // Don't render interactive content until active
  if (!isActive) {
    return null;
  }

  return (
    <div
      ref={containerRef}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      tabIndex={0}
      autoFocus
      style={{
        position: 'fixed',
        inset: 0,
        cursor: 'crosshair',
        userSelect: 'none',
        overflow: 'hidden',
        outline: 'none',
        backgroundColor: '#000',
      }}
    >
      {/* Background image - fill entire viewport exactly (no scaling) */}
      {backgroundImage && (
        <img
          src={backgroundImage}
          alt=""
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100vw',
            height: '100vh',
            objectFit: 'fill',
            pointerEvents: 'none',
          }}
          draggable={false}
        />
      )}

      {/* Selection rectangle with cutout effect */}
      <div style={getSelectionStyle()} />

      {/* Instructions overlay */}
      {!isSelecting && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: '#fff',
            fontSize: 16,
            backgroundColor: 'rgba(0, 0, 0, 0.7)',
            padding: '12px 24px',
            borderRadius: 8,
            pointerEvents: 'none',
            zIndex: 20,
            textAlign: 'center',
          }}
        >
          <div>Kéo để chọn vùng</div>
          <div style={{ fontSize: 12, marginTop: 4, opacity: 0.8 }}>ESC để hủy</div>
        </div>
      )}

      {/* Selection dimensions tooltip */}
      {isSelecting && selection && (
        <div
          style={{
            position: 'absolute',
            left: Math.min(selection.startX, selection.endX),
            top: Math.max(0, Math.min(selection.startY, selection.endY) - 28),
            color: '#fff',
            fontSize: 12,
            backgroundColor: 'rgba(0, 120, 212, 0.9)',
            padding: '4px 8px',
            borderRadius: 4,
            pointerEvents: 'none',
            zIndex: 20,
          }}
        >
          {Math.abs(selection.endX - selection.startX)} × {Math.abs(selection.endY - selection.startY)}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/stores/annotation-store.ts">
// Annotation store - Zustand state management for annotations

import { create } from 'zustand';
import { nanoid } from 'nanoid';
import type { Annotation, ToolType } from '../types/annotations';
import {
  useHistoryStore,
  pushToFuture,
  pushToPast,
  type ImageSnapshot,
} from './history-store';

// Type for creating annotations without id (will be auto-generated)
type CreateAnnotation = Omit<Annotation, 'id'>;

interface AnnotationState {
  annotations: Annotation[];
  selectedId: string | null;
  editingTextId: string | null;
  currentTool: ToolType;

  // Tool settings
  strokeColor: string;
  fillColor: string;
  strokeWidth: number;
  fontSize: number;
  fontFamily: string;

  // Number tool counter
  numberCounter: number;

  // Actions
  addAnnotation: (annotation: CreateAnnotation) => string;
  getNextNumber: () => number;
  resetNumberCounter: () => void;
  updateAnnotation: (id: string, updates: Partial<Annotation>) => void;
  deleteAnnotation: (id: string) => void;
  deleteSelected: () => void;
  setSelected: (id: string | null) => void;
  setEditingTextId: (id: string | null) => void;
  updateTextContent: (id: string, text: string) => void;
  setTool: (tool: ToolType) => void;

  // Settings
  setStrokeColor: (color: string) => void;
  setFillColor: (color: string) => void;
  setStrokeWidth: (width: number) => void;
  setFontSize: (size: number) => void;
  setFontFamily: (family: string) => void;

  // Undo/Redo
  undo: () => void;
  redo: () => void;
  canUndo: () => boolean;
  canRedo: () => boolean;

  // History helpers for canvas integration
  saveToHistory: (imageSnapshot?: ImageSnapshot) => void;
  restoreImageFromHistory: ((snapshot: ImageSnapshot) => void) | null;
  setRestoreImageCallback: (callback: (snapshot: ImageSnapshot) => void) => void;
  getCurrentImageSnapshot: (() => ImageSnapshot) | null;
  setGetImageSnapshotCallback: (callback: () => ImageSnapshot) => void;

  clearAnnotations: () => void;
}

export const useAnnotationStore = create<AnnotationState>((set, get) => ({
  annotations: [],
  selectedId: null,
  editingTextId: null,
  currentTool: 'select',

  strokeColor: '#ff0000',
  fillColor: 'transparent',
  strokeWidth: 2,
  fontSize: 16,
  fontFamily: 'Arial',

  // Number tool counter
  numberCounter: 1,

  // Callbacks for canvas integration (set by canvas-store)
  restoreImageFromHistory: null,
  getCurrentImageSnapshot: null,

  setRestoreImageCallback: (callback) => set({ restoreImageFromHistory: callback }),
  setGetImageSnapshotCallback: (callback) => set({ getCurrentImageSnapshot: callback }),

  saveToHistory: (imageSnapshot?: ImageSnapshot) => {
    const state = get();
    useHistoryStore.getState().pushState({
      annotations: [...state.annotations],
      image: imageSnapshot,
    });
  },

  addAnnotation: (annotation: CreateAnnotation) => {
    const id = nanoid();
    const newAnnotation = { ...annotation, id } as Annotation;
    // Save current state before modification
    get().saveToHistory();
    set((state) => ({
      annotations: [...state.annotations, newAnnotation],
    }));
    return id;
  },

  getNextNumber: () => {
    const current = get().numberCounter;
    set({ numberCounter: current + 1 });
    return current;
  },

  resetNumberCounter: () => {
    set({ numberCounter: 1 });
  },

  updateAnnotation: (id, updates) => {
    // Save current state before modification
    get().saveToHistory();
    set((state) => ({
      annotations: state.annotations.map((a) =>
        a.id === id ? ({ ...a, ...updates } as Annotation) : a
      ),
    }));
  },

  deleteAnnotation: (id) => {
    // Save current state before modification
    get().saveToHistory();
    set((state) => ({
      annotations: state.annotations.filter((a) => a.id !== id),
      selectedId: state.selectedId === id ? null : state.selectedId,
    }));
  },

  deleteSelected: () => {
    const { selectedId } = get();
    if (selectedId) {
      get().deleteAnnotation(selectedId);
    }
  },

  setSelected: (id) => set({ selectedId: id, editingTextId: null }),

  setEditingTextId: (id) => set({ editingTextId: id }),

  updateTextContent: (id, text) => {
    const trimmed = text.trim();
    if (!trimmed) {
      // Delete annotation if text is empty
      get().deleteAnnotation(id);
    } else {
      get().updateAnnotation(id, { text: trimmed });
    }
    set({ editingTextId: null });
  },

  setTool: (tool) => set({ currentTool: tool, selectedId: null, editingTextId: null }),

  setStrokeColor: (color) => {
    const { selectedId, annotations } = get();
    // Update selected annotation if exists
    if (selectedId) {
      const selected = annotations.find((a) => a.id === selectedId);
      if (selected) {
        get().saveToHistory();
        set((state) => ({
          strokeColor: color,
          annotations: state.annotations.map((a) => {
            if (a.id !== selectedId) return a;
            // Update appropriate color property based on annotation type
            if (a.type === 'text') return { ...a, fill: color } as Annotation;
            if (a.type === 'number') return { ...a, fill: color } as Annotation;
            return { ...a, stroke: color } as Annotation;
          }),
        }));
        return;
      }
    }
    set({ strokeColor: color });
  },
  setFillColor: (color) => {
    const { selectedId, annotations } = get();
    if (selectedId) {
      const selected = annotations.find((a) => a.id === selectedId);
      if (selected && (selected.type === 'rectangle' || selected.type === 'ellipse')) {
        get().saveToHistory();
        set((state) => ({
          fillColor: color,
          annotations: state.annotations.map((a) =>
            a.id === selectedId ? { ...a, fill: color } as Annotation : a
          ),
        }));
        return;
      }
    }
    set({ fillColor: color });
  },
  setStrokeWidth: (width) => {
    const { selectedId, annotations } = get();
    if (selectedId) {
      const selected = annotations.find((a) => a.id === selectedId);
      if (selected && 'strokeWidth' in selected) {
        get().saveToHistory();
        set((state) => ({
          strokeWidth: width,
          annotations: state.annotations.map((a) =>
            a.id === selectedId ? { ...a, strokeWidth: width } as Annotation : a
          ),
        }));
        return;
      }
    }
    set({ strokeWidth: width });
  },
  setFontSize: (size) => {
    const { selectedId, annotations } = get();
    if (selectedId) {
      const selected = annotations.find((a) => a.id === selectedId);
      if (selected && selected.type === 'text') {
        get().saveToHistory();
        set((state) => ({
          fontSize: size,
          annotations: state.annotations.map((a) =>
            a.id === selectedId ? { ...a, fontSize: size } as Annotation : a
          ),
        }));
        return;
      }
    }
    set({ fontSize: size });
  },
  setFontFamily: (family) => {
    const { selectedId, annotations } = get();
    if (selectedId) {
      const selected = annotations.find((a) => a.id === selectedId);
      if (selected && selected.type === 'text') {
        get().saveToHistory();
        set((state) => ({
          fontFamily: family,
          annotations: state.annotations.map((a) =>
            a.id === selectedId ? { ...a, fontFamily: family } as Annotation : a
          ),
        }));
        return;
      }
    }
    set({ fontFamily: family });
  },

  undo: () => {
    const historyStore = useHistoryStore.getState();
    if (!historyStore.canUndo()) return;

    const current = get();
    // Build current snapshot including image if callback available
    const currentSnapshot: Parameters<typeof pushToFuture>[0] = {
      annotations: [...current.annotations],
    };
    if (current.getCurrentImageSnapshot) {
      currentSnapshot.image = current.getCurrentImageSnapshot();
    }

    // Save current state to future before undoing
    pushToFuture(currentSnapshot);

    // Get previous state
    const previous = historyStore.undo();
    if (previous) {
      set({
        annotations: previous.annotations,
        selectedId: null,
      });
      // Restore image if snapshot contains image data
      if (previous.image && current.restoreImageFromHistory) {
        current.restoreImageFromHistory(previous.image);
      }
    }
  },

  redo: () => {
    const historyStore = useHistoryStore.getState();
    if (!historyStore.canRedo()) return;

    const current = get();
    // Build current snapshot including image if callback available
    const currentSnapshot: Parameters<typeof pushToPast>[0] = {
      annotations: [...current.annotations],
    };
    if (current.getCurrentImageSnapshot) {
      currentSnapshot.image = current.getCurrentImageSnapshot();
    }

    // Save current state to past before redoing
    pushToPast(currentSnapshot);

    // Get next state
    const next = historyStore.redo();
    if (next) {
      set({
        annotations: next.annotations,
        selectedId: null,
      });
      // Restore image if snapshot contains image data
      if (next.image && current.restoreImageFromHistory) {
        current.restoreImageFromHistory(next.image);
      }
    }
  },

  canUndo: () => useHistoryStore.getState().canUndo(),
  canRedo: () => useHistoryStore.getState().canRedo(),

  clearAnnotations: () => {
    // Save current state before clearing
    get().saveToHistory();
    useHistoryStore.getState().clear();
    set({ annotations: [], selectedId: null, numberCounter: 1 });
  },
}));
</file>

<file path="src/stores/background-store.ts">
// Background store - Zustand state for background beautification

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { GRADIENT_PRESETS, type GradientPreset } from '../data/gradients';
import { WALLPAPER_PRESETS, type WallpaperPreset } from '../data/wallpapers';
import {
  addImageToDB,
  getAllImagesFromDB,
  getImageFromDB,
  removeImageFromDB,
  clearAllImagesFromDB,
  trimOldestImages,
  type StoredImage,
} from '../utils/image-db';

// Constants - padding stored as percentage (0-50% of smaller image dimension)
const MIN_PADDING_PERCENT = 0;
const MAX_PADDING_PERCENT = 50;
const DEFAULT_PADDING_PERCENT = 5; // 5% default

// Image library constants
const MAX_LIBRARY_IMAGES = 12; 

// Blur constants for background
const MIN_BLUR = 0;
const MAX_BLUR = 500;
const DEFAULT_BLUR = 0;

// Shadow constants for screenshot
const MIN_SHADOW = 0;
const MAX_SHADOW = 500;
const DEFAULT_SHADOW = 50; // Increased from 20 for more visible effect

// Corner radius constants for screenshot
const MIN_CORNER_RADIUS = 0;
const MAX_CORNER_RADIUS = 100;
const DEFAULT_CORNER_RADIUS = 12; // Default rounded corners

// Border constants for screenshot
const MIN_BORDER_WIDTH = 0;
const MAX_BORDER_WIDTH = 50;
const DEFAULT_BORDER_WIDTH = 0;
const DEFAULT_BORDER_COLOR = '#000000';
const DEFAULT_BORDER_OPACITY = 100;

// Recent colors constants
const MAX_RECENT_COLORS = 8;

// Preset colors (same as toolbar)
export const BORDER_PRESET_COLORS = [
  '#ff0000', // Red
  '#ff6600', // Orange
  '#ffcc00', // Yellow
  '#00cc00', // Green
  '#0066ff', // Blue
  '#9933ff', // Purple
  '#000000', // Black
  '#ffffff', // White
];

export type BackgroundType = 'gradient' | 'solid' | 'transparent' | 'wallpaper' | 'image' | 'auto';

export interface LibraryImage {
  id: string;
  thumbnail: string;
  timestamp: number;
}

interface BackgroundState {
  type: BackgroundType;
  gradient: GradientPreset | null;
  solidColor: string;
  wallpaper: WallpaperPreset | null;
  customImageUrl: string | null; // User-uploaded image URL
  customImageBytes: Uint8Array | null; // Store bytes for persistence
  selectedImageId: string | null; // ID of selected image from library (for persistence)
  autoColor: string | null; // Auto-calculated dominant color from screenshot
  blurAmount: number; // 0-500px blur for background
  shadowBlur: number; // 0-500 shadow blur for screenshot image
  cornerRadius: number; // 0-100px corner radius for screenshot
  paddingPercent: number; // percentage of smaller image dimension
  borderWidth: number; // 0-50px border width for screenshot
  borderColor: string; // Border color (hex)
  borderOpacity: number; // 0-100 border opacity
  recentBorderColors: string[]; // Recent border colors

  // Image library (persisted)
  imageLibrary: LibraryImage[];

  // Actions
  setGradient: (gradient: GradientPreset) => void;
  setSolidColor: (color: string) => void;
  setTransparent: () => void;
  setAuto: () => void;
  setAutoColor: (color: string) => void;
  setWallpaper: (wallpaper: WallpaperPreset) => void;
  setCustomImage: (url: string, bytes?: Uint8Array) => void;
  clearCustomImage: () => void;
  setBlurAmount: (amount: number) => void;
  setShadowBlur: (blur: number) => void;
  setCornerRadius: (radius: number) => void;
  setPaddingPercent: (percent: number) => void;
  setBorderWidth: (width: number) => void;
  setBorderColor: (color: string, addToRecent?: boolean) => void;
  setBorderOpacity: (opacity: number) => void;
  // Helper to get pixel padding based on image dimensions
  getPaddingPx: (imageWidth: number, imageHeight: number) => number;
  // Image library actions (using IndexedDB)
  loadLibrary: () => Promise<void>;
  addToLibrary: (fullDataUrl: string, thumbnail: string) => Promise<void>;
  removeFromLibrary: (id: string) => Promise<void>;
  selectFromLibrary: (id: string) => Promise<void>;
  clearLibrary: () => Promise<void>;
  reset: () => void;
}

// Helper to generate unique ID
const generateId = () => `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

// Helper to resize image for library storage (thumbnail)
const resizeImageForLibrary = (dataUrl: string, maxSize: number = 200): Promise<string> => {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let { width, height } = img;

      // Scale down if larger than maxSize
      if (width > maxSize || height > maxSize) {
        if (width > height) {
          height = (height / width) * maxSize;
          width = maxSize;
        } else {
          width = (width / height) * maxSize;
          height = maxSize;
        }
      }

      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas.toDataURL('image/jpeg', 0.7));
      } else {
        resolve(dataUrl);
      }
    };
    img.onerror = () => resolve(dataUrl);
    img.src = dataUrl;
  });
};

export const useBackgroundStore = create<BackgroundState>()(
  persist(
    (set, get) => ({
      type: 'gradient',
      gradient: GRADIENT_PRESETS[0], // Default to first gradient
      solidColor: '#ffffff',
      wallpaper: null,
      customImageUrl: null,
      customImageBytes: null,
      selectedImageId: null,
      autoColor: null,
      blurAmount: DEFAULT_BLUR,
      shadowBlur: DEFAULT_SHADOW,
      cornerRadius: DEFAULT_CORNER_RADIUS,
      paddingPercent: DEFAULT_PADDING_PERCENT,
      borderWidth: DEFAULT_BORDER_WIDTH,
      borderColor: DEFAULT_BORDER_COLOR,
      borderOpacity: DEFAULT_BORDER_OPACITY,
      recentBorderColors: [],
      imageLibrary: [],

  setGradient: (gradient) => set({ type: 'gradient', gradient }),

  setSolidColor: (color) => set({ type: 'solid', solidColor: color }),

  setTransparent: () => set({ type: 'transparent' }),

  setAuto: () => set({ type: 'auto' }),

  setAutoColor: (color) => set({ autoColor: color }),

  setWallpaper: (wallpaper) => set({ type: 'wallpaper', wallpaper }),

  setCustomImage: (url, bytes) => {
    // Revoke previous custom image URL to prevent memory leak
    const oldUrl = get().customImageUrl;
    if (oldUrl && oldUrl.startsWith('blob:')) {
      URL.revokeObjectURL(oldUrl);
    }
    set({
      type: 'image',
      customImageUrl: url,
      customImageBytes: bytes || null,
    });

    // Auto-save to library if we have bytes
    if (bytes) {
      // Convert bytes to base64 data URL
      const blob = new Blob([bytes], { type: 'image/png' });
      const reader = new FileReader();
      reader.onloadend = async () => {
        const fullDataUrl = reader.result as string;
        // Create small thumbnail for UI preview
        const thumbnailDataUrl = await resizeImageForLibrary(fullDataUrl, 150);
        await get().addToLibrary(fullDataUrl, thumbnailDataUrl);
      };
      reader.readAsDataURL(blob);
    }
  },

      clearCustomImage: () => {
    const oldUrl = get().customImageUrl;
    if (oldUrl && oldUrl.startsWith('blob:')) {
      URL.revokeObjectURL(oldUrl);
    }
    set({
      customImageUrl: null,
      customImageBytes: null,
      // Switch back to gradient if currently on image
      type: get().type === 'image' ? 'gradient' : get().type,
    });
  },

  setBlurAmount: (amount) =>
    set({ blurAmount: Math.max(MIN_BLUR, Math.min(MAX_BLUR, amount)) }),

  setShadowBlur: (blur) =>
    set({ shadowBlur: Math.max(MIN_SHADOW, Math.min(MAX_SHADOW, blur)) }),

  setCornerRadius: (radius) =>
    set({ cornerRadius: Math.max(MIN_CORNER_RADIUS, Math.min(MAX_CORNER_RADIUS, radius)) }),

  setPaddingPercent: (percent) =>
    set({ paddingPercent: Math.max(MIN_PADDING_PERCENT, Math.min(MAX_PADDING_PERCENT, percent)) }),

  setBorderWidth: (width) =>
    set({ borderWidth: Math.max(MIN_BORDER_WIDTH, Math.min(MAX_BORDER_WIDTH, width)) }),

  setBorderColor: (color, addToRecent = false) => {
    if (addToRecent) {
      const recent = get().recentBorderColors;
      // Add to front, remove duplicates, limit to MAX_RECENT_COLORS
      const updated = [color, ...recent.filter((c) => c.toLowerCase() !== color.toLowerCase())].slice(0, MAX_RECENT_COLORS);
      set({ borderColor: color, recentBorderColors: updated });
    } else {
      set({ borderColor: color });
    }
  },

  setBorderOpacity: (opacity) =>
    set({ borderOpacity: Math.max(0, Math.min(100, opacity)) }),

  getPaddingPx: (imageWidth, imageHeight) => {
    const smallerDimension = Math.min(imageWidth, imageHeight);
    return Math.round((get().paddingPercent / 100) * smallerDimension);
  },

  // Load library from IndexedDB on app start
  loadLibrary: async () => {
    try {
      const images = await getAllImagesFromDB();
      const libraryImages: LibraryImage[] = images.map((img) => ({
        id: img.id,
        thumbnail: img.thumbnail,
        timestamp: img.timestamp,
      }));
      set({ imageLibrary: libraryImages });

      // If there was a selected image and type is 'image', restore it
      const { type, selectedImageId } = get();
      if (type === 'image' && selectedImageId) {
        // Check if the image still exists in library
        const exists = libraryImages.some((img) => img.id === selectedImageId);
        if (exists) {
          // Load the full image from IndexedDB
          const image = await getImageFromDB(selectedImageId);
          if (image) {
            const response = await fetch(image.dataUrl);
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            set({ customImageUrl: url });
          }
        } else {
          // Image was deleted, reset to gradient
          set({ type: 'gradient', selectedImageId: null });
        }
      }
    } catch (error) {
      console.error('Failed to load image library:', error);
    }
  },

  // Add image to IndexedDB library
  addToLibrary: async (fullDataUrl, thumbnail) => {
    try {
      const id = generateId();
      const timestamp = Date.now();

      // Store in IndexedDB (full quality image + thumbnail)
      const storedImage: StoredImage = {
        id,
        dataUrl: fullDataUrl,
        thumbnail,
        timestamp,
      };
      await addImageToDB(storedImage);

      // Trim to max count
      await trimOldestImages(MAX_LIBRARY_IMAGES);

      // Update state with just thumbnail for UI
      const newImage: LibraryImage = { id, thumbnail, timestamp };
      const library = get().imageLibrary;
      const updatedLibrary = [newImage, ...library].slice(0, MAX_LIBRARY_IMAGES);
      set({
        imageLibrary: updatedLibrary,
        selectedImageId: id, // Save ID for persistence
      });
    } catch (error) {
      console.error('Failed to add image to library:', error);
    }
  },

  // Remove image from IndexedDB
  removeFromLibrary: async (id) => {
    try {
      await removeImageFromDB(id);
      const library = get().imageLibrary;
      set({ imageLibrary: library.filter((img) => img.id !== id) });
    } catch (error) {
      console.error('Failed to remove image:', error);
    }
  },

  // Select image from library - loads full quality from IndexedDB
  selectFromLibrary: async (id) => {
    try {
      const image = await getImageFromDB(id);
      if (!image) return;

      // Revoke previous custom image URL
      const oldUrl = get().customImageUrl;
      if (oldUrl && oldUrl.startsWith('blob:')) {
        URL.revokeObjectURL(oldUrl);
      }

      // Convert full quality data URL to blob URL for display
      const response = await fetch(image.dataUrl);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);

      set({
        type: 'image',
        customImageUrl: url,
        customImageBytes: null,
        selectedImageId: id, // Save ID for persistence
      });
    } catch (error) {
      console.error('Failed to select image:', error);
    }
  },

  // Clear all images from IndexedDB
  clearLibrary: async () => {
    try {
      await clearAllImagesFromDB();
      set({ imageLibrary: [] });
    } catch (error) {
      console.error('Failed to clear library:', error);
    }
  },

      reset: () => {
        // Clean up custom image URL
        const oldUrl = get().customImageUrl;
        if (oldUrl && oldUrl.startsWith('blob:')) {
          URL.revokeObjectURL(oldUrl);
        }
        set({
          type: 'gradient',
          gradient: GRADIENT_PRESETS[0],
          solidColor: '#ffffff',
          wallpaper: WALLPAPER_PRESETS[0],
          customImageUrl: null,
          customImageBytes: null,
          selectedImageId: null,
          autoColor: null,
          blurAmount: DEFAULT_BLUR,
          shadowBlur: DEFAULT_SHADOW,
          cornerRadius: DEFAULT_CORNER_RADIUS,
          paddingPercent: DEFAULT_PADDING_PERCENT,
          borderWidth: DEFAULT_BORDER_WIDTH,
          borderColor: DEFAULT_BORDER_COLOR,
          borderOpacity: DEFAULT_BORDER_OPACITY,
          // Note: imageLibrary is NOT reset - it persists in IndexedDB
        });
      },
    }),
    {
      name: 'background-settings',
      // Only persist settings values, not runtime state like images/blobs
      partialize: (state) => ({
        type: state.type,
        gradient: state.gradient,
        solidColor: state.solidColor,
        wallpaper: state.wallpaper,
        selectedImageId: state.selectedImageId,
        blurAmount: state.blurAmount,
        shadowBlur: state.shadowBlur,
        cornerRadius: state.cornerRadius,
        paddingPercent: state.paddingPercent,
        borderWidth: state.borderWidth,
        borderColor: state.borderColor,
        borderOpacity: state.borderOpacity,
        recentBorderColors: state.recentBorderColors,
      }),
    }
  )
);
</file>

<file path="src/stores/settings-store.ts">
// Settings store - Zustand state for app settings with persistence

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { updateShortcuts } from '../utils/screenshot-api';

// Valid modifier keys
const VALID_MODIFIERS = ['CommandOrControl', 'Control', 'Ctrl', 'Command', 'Cmd', 'Alt', 'Option', 'Shift', 'Super', 'Meta'];

// Valid key codes (letters, numbers, and special keys) - all uppercase for comparison
const VALID_KEYS = [
  // Letters
  ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''),
  // Numbers
  ...'0123456789'.split(''),
  // Function keys
  'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
  // Special keys (uppercase for matching)
  'SPACE', 'TAB', 'ENTER', 'ESCAPE', 'BACKSPACE', 'DELETE', 'INSERT', 'HOME', 'END', 'PAGEUP', 'PAGEDOWN',
  'ARROWUP', 'ARROWDOWN', 'ARROWLEFT', 'ARROWRIGHT', 'PRINTSCREEN',
];

/**
 * Validates hotkey string format
 * Expected format: "Modifier+Modifier+Key" (e.g., "CommandOrControl+Shift+C")
 */
export function isValidHotkey(hotkey: string): boolean {
  if (!hotkey || typeof hotkey !== 'string') return false;

  const parts = hotkey.split('+').map(p => p.trim());
  if (parts.length < 2) return false; // Need at least one modifier and one key

  const key = parts[parts.length - 1].toUpperCase();
  const modifiers = parts.slice(0, -1);

  // Check key is valid
  if (!VALID_KEYS.includes(key)) return false;

  // Check all modifiers are valid
  return modifiers.every(mod => VALID_MODIFIERS.some(valid =>
    valid.toLowerCase() === mod.toLowerCase()
  ));
}

export interface HotkeyConfig {
  capture: string;
  captureRegion: string;
  captureWindow: string;
  save: string;
  copy: string;
}

export type SaveLocation = 'pictures' | 'desktop' | 'custom';
export type ThemeMode = 'light' | 'dark' | 'system';

interface SettingsState {
  // Hotkeys configuration
  hotkeys: HotkeyConfig;

  // Behavior settings
  startMinimized: boolean;
  closeToTray: boolean;
  showNotifications: boolean;

  // Default save location
  saveLocation: SaveLocation;
  customSavePath: string | null;

  // Theme
  theme: ThemeMode;

  // Actions
  setHotkey: (action: keyof HotkeyConfig, shortcut: string) => void;
  setStartMinimized: (value: boolean) => void;
  setCloseToTray: (value: boolean) => void;
  setShowNotifications: (value: boolean) => void;
  setSaveLocation: (location: SaveLocation) => void;
  setCustomSavePath: (path: string | null) => void;
  setTheme: (theme: ThemeMode) => void;
  resetToDefaults: () => void;
}

const DEFAULT_HOTKEYS: HotkeyConfig = {
  capture: 'CommandOrControl+Option+1',
  captureRegion: 'CommandOrControl+Option+2',
  captureWindow: 'CommandOrControl+Option+3',
  save: 'CommandOrControl+S',
  copy: 'CommandOrControl+C',
};

const DEFAULT_STATE = {
  hotkeys: DEFAULT_HOTKEYS,
  startMinimized: false,
  closeToTray: true,
  showNotifications: true,
  saveLocation: 'pictures' as SaveLocation,
  customSavePath: null,
  theme: 'dark' as ThemeMode,
};

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      ...DEFAULT_STATE,

      setHotkey: (action, shortcut) => {
        // Only set if valid or empty (allow clearing)
        if (shortcut === '' || isValidHotkey(shortcut)) {
          set((state) => {
            const newHotkeys = { ...state.hotkeys, [action]: shortcut };
            // Update global shortcuts in backend for capture-related hotkeys
            if (['capture', 'captureRegion', 'captureWindow'].includes(action)) {
              updateShortcuts(
                newHotkeys.capture,
                newHotkeys.captureRegion,
                newHotkeys.captureWindow
              ).catch(console.error);
            }
            return { hotkeys: newHotkeys };
          });
        }
      },

      setStartMinimized: (value) => set({ startMinimized: value }),
      setCloseToTray: (value) => set({ closeToTray: value }),
      setShowNotifications: (value) => set({ showNotifications: value }),
      setSaveLocation: (location) => set({ saveLocation: location }),
      setCustomSavePath: (path) => set({ customSavePath: path }),
      setTheme: (theme) => set({ theme }),

      resetToDefaults: () => set(DEFAULT_STATE),
    }),
    {
      name: 'beautyshot-settings',
    }
  )
);
</file>

<file path="src/styles.css">
@import "tailwindcss";

/* Enable class-based dark mode */
@custom-variant dark (&:where(.dark, .dark *));

/* ===========================================
   GLASSMORPHISM DESIGN TOKENS
   =========================================== */

/* Light mode glass */
:root {
  /* Glass backgrounds */
  --glass-bg: rgba(255, 255, 255, 0.75);
  --glass-bg-light: rgba(255, 255, 255, 0.5);
  --glass-bg-heavy: rgba(255, 255, 255, 0.9);

  /* Glass borders */
  --glass-border: rgba(255, 255, 255, 0.4);
  --glass-border-subtle: rgba(0, 0, 0, 0.06);

  /* Glass effects */
  --glass-blur: 16px;
  --glass-blur-heavy: 24px;

  /* Spatial design */
  --panel-radius: 16px;
  --panel-radius-sm: 12px;
  --panel-radius-lg: 20px;
  --panel-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  --panel-shadow-lg: 0 12px 48px rgba(0, 0, 0, 0.15);
  --gap-layout: 12px;

  /* Canvas background for spatial effect */
  --canvas-bg: #e5e5e5;
}

/* Dark mode glass */
.dark {
  --glass-bg: rgba(30, 30, 30, 0.85);
  --glass-bg-light: rgba(40, 40, 40, 0.7);
  --glass-bg-heavy: rgba(20, 20, 20, 0.95);

  --glass-border: rgba(255, 255, 255, 0.1);
  --glass-border-subtle: rgba(255, 255, 255, 0.05);

  --panel-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  --panel-shadow-lg: 0 12px 48px rgba(0, 0, 0, 0.5);

  --canvas-bg: #1a1a1a;
}

/* ===========================================
   GLASSMORPHISM UTILITY CLASSES
   =========================================== */

/* Standard glass panel */
.glass {
  background: var(--glass-bg);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--glass-border);
  box-shadow: var(--panel-shadow);
}

/* Light glass variant */
.glass-light {
  background: var(--glass-bg-light);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--glass-border);
}

/* Heavy glass (more opaque) */
.glass-heavy {
  background: var(--glass-bg-heavy);
  backdrop-filter: blur(var(--glass-blur-heavy));
  -webkit-backdrop-filter: blur(var(--glass-blur-heavy));
  border: 1px solid var(--glass-border);
  box-shadow: var(--panel-shadow-lg);
}

/* Glass with no shadow (for nested elements) */
.glass-flat {
  background: var(--glass-bg-light);
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
  border: 1px solid var(--glass-border-subtle);
}

/* ===========================================
   SPATIAL LAYOUT UTILITIES
   =========================================== */

/* Floating panel base */
.floating-panel {
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
}

/* Layout gaps */
.spatial-gap {
  gap: var(--gap-layout);
  padding: var(--gap-layout);
}

/* Canvas area background */
.canvas-area {
  background: var(--canvas-bg);
}

/* ===========================================
   ENHANCED BUTTON STATES
   =========================================== */

/* Glass button hover */
.glass-btn {
  background: var(--glass-bg-light);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid var(--glass-border-subtle);
  transition: all 0.2s ease;
}

.glass-btn:hover {
  background: var(--glass-bg);
  border-color: var(--glass-border);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.dark .glass-btn:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* Active/selected glass button */
.glass-btn-active {
  background: rgba(249, 115, 22, 0.15);
  border-color: rgba(249, 115, 22, 0.4);
}

.dark .glass-btn-active {
  background: rgba(249, 115, 22, 0.2);
  border-color: rgba(249, 115, 22, 0.3);
}

/* Range slider styles */
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  background: rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  height: 6px;
  accent-color: #f97316;
}

.dark input[type="range"] {
  background: rgba(255, 255, 255, 0.1);
  accent-color: #f97316;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  background: #f97316 !important;
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.dark input[type="range"]::-webkit-slider-thumb {
  background: #f97316 !important;
}

input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: #f97316 !important;
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Fixed viewport layout - no scrolling */
html, body, #root {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

:root {
  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;
  font-size: 16px;
  line-height: 24px;
  font-weight: 400;
  color: #0f0f0f;
  background-color: #f6f6f6;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Dark mode styles */
.dark {
  color: #e5e5e5;
  background-color: #0f0f0f;
}

/* Custom scrollbar for dark mode */
.dark ::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.dark ::-webkit-scrollbar-track {
  background: #1f1f1f;
}

.dark ::-webkit-scrollbar-thumb {
  background: #404040;
  border-radius: 4px;
}

.dark ::-webkit-scrollbar-thumb:hover {
  background: #525252;
}

/* Range input styling for dark mode */
.dark input[type="range"] {
  background: #374151;
}

.dark input[type="range"]::-webkit-slider-thumb {
  background: #60a5fa;
}

/* Screenshot capture flash animation */
@keyframes flash {
  0% {
    opacity: 0.8;
  }
  100% {
    opacity: 0;
  }
}

.animate-flash {
  animation: flash 150ms ease-out forwards;
}
</file>

<file path="src-tauri/src/screenshot.rs">
// Screenshot capture module using xcap crate
// Provides fullscreen, region, and window capture functionality
// Falls back to grim on Linux Wayland when xcap fails

use base64::{engine::general_purpose::STANDARD, Engine};
use image::codecs::png::{CompressionType, FilterType, PngEncoder};
use image::ImageEncoder;
use serde::{Deserialize, Serialize};
use xcap::{Monitor, Window as XcapWindow};

#[cfg(target_os = "linux")]
use std::process::Command;

#[derive(Debug, Serialize, Deserialize)]
pub struct MonitorInfo {
    pub id: u32,
    pub name: String,
    pub width: u32,
    pub height: u32,
    pub x: i32,
    pub y: i32,
    pub is_primary: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WindowInfo {
    pub id: u32,
    pub app_name: String,
    pub title: String,
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}

/// Check if running on Wayland (Linux only)
#[cfg(target_os = "linux")]
fn is_wayland() -> bool {
    std::env::var("WAYLAND_DISPLAY").is_ok()
}

/// Capture fullscreen using grim (Wayland-native tool)
/// Returns base64-encoded PNG on success
#[cfg(target_os = "linux")]
fn capture_with_grim() -> Result<String, String> {
    // grim outputs PNG to stdout with "-" argument
    let output = Command::new("grim")
        .arg("-")
        .output()
        .map_err(|e| format!("Failed to run grim: {}. Install grim for Wayland support.", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("grim failed: {}", stderr));
    }

    Ok(STANDARD.encode(&output.stdout))
}

/// Capture region using grim + slurp (Wayland-native tools)
/// slurp provides interactive region selection, grim captures it
#[cfg(target_os = "linux")]
fn capture_region_with_grim(x: i32, y: i32, width: u32, height: u32) -> Result<String, String> {
    // grim -g "x,y widthxheight" captures specific region
    let geometry = format!("{},{} {}x{}", x, y, width, height);
    let output = Command::new("grim")
        .arg("-g")
        .arg(&geometry)
        .arg("-")
        .output()
        .map_err(|e| format!("Failed to run grim: {}. Install grim for Wayland support.", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("grim region capture failed: {}", stderr));
    }

    Ok(STANDARD.encode(&output.stdout))
}

/// Convert RgbaImage to base64-encoded PNG string (maximum speed)
fn image_to_base64_png(img: &image::RgbaImage) -> Result<String, String> {
    // Pre-allocate buffer for speed (estimate: width * height * 4 bytes + overhead)
    let estimated_size = (img.width() * img.height() * 4) as usize + 1024;
    let mut bytes: Vec<u8> = Vec::with_capacity(estimated_size);
    // NoFilter = fastest encoding (no per-row analysis), Fast compression
    let encoder = PngEncoder::new_with_quality(&mut bytes, CompressionType::Fast, FilterType::NoFilter);
    encoder
        .write_image(
            img.as_raw(),
            img.width(),
            img.height(),
            image::ExtendedColorType::Rgba8,
        )
        .map_err(|e| e.to_string())?;
    Ok(STANDARD.encode(&bytes))
}

/// Capture primary monitor - returns base64-encoded PNG
/// On Linux Wayland: falls back to grim if xcap fails
#[tauri::command]
pub fn capture_fullscreen() -> Result<String, String> {
    // Try xcap first
    let xcap_result = (|| -> Result<String, String> {
        let monitors = Monitor::all().map_err(|e| e.to_string())?;
        let primary = monitors
            .into_iter()
            .find(|m| m.is_primary().unwrap_or(false))
            .ok_or("No primary monitor found")?;

        let image = primary.capture_image().map_err(|e| e.to_string())?;

        // Verify we got a valid image
        if image.width() == 0 || image.height() == 0 {
            return Err("Screen recording permission not granted".to_string());
        }

        image_to_base64_png(&image)
    })();

    // On Linux Wayland, try grim as fallback if xcap failed
    #[cfg(target_os = "linux")]
    if xcap_result.is_err() && is_wayland() {
        println!("xcap failed on Wayland, trying grim fallback...");
        return capture_with_grim();
    }

    xcap_result
}

/// Capture specific region from primary monitor - returns base64-encoded PNG
/// On Linux Wayland: falls back to grim if xcap fails
#[tauri::command]
pub fn capture_region(x: i32, y: i32, width: u32, height: u32) -> Result<String, String> {
    // Try xcap first
    let xcap_result = (|| -> Result<String, String> {
        let monitors = Monitor::all().map_err(|e| e.to_string())?;
        let monitor = monitors
            .into_iter()
            .find(|m| m.is_primary().unwrap_or(false))
            .ok_or("No primary monitor")?;

        let image = monitor.capture_image().map_err(|e| e.to_string())?;

        // Validate region bounds
        let img_width = image.width();
        let img_height = image.height();
        let start_x = x.max(0) as u32;
        let start_y = y.max(0) as u32;
        let crop_width = width.min(img_width.saturating_sub(start_x));
        let crop_height = height.min(img_height.saturating_sub(start_y));

        if crop_width == 0 || crop_height == 0 {
            return Err("Invalid region dimensions".to_string());
        }

        // Crop to region
        let cropped = image::imageops::crop_imm(&image, start_x, start_y, crop_width, crop_height).to_image();

        image_to_base64_png(&cropped)
    })();

    // On Linux Wayland, try grim as fallback if xcap failed
    #[cfg(target_os = "linux")]
    if xcap_result.is_err() && is_wayland() {
        println!("xcap region capture failed on Wayland, trying grim fallback...");
        return capture_region_with_grim(x, y, width, height);
    }

    xcap_result
}

/// Get list of capturable windows
#[tauri::command]
pub fn get_windows() -> Result<Vec<WindowInfo>, String> {
    let windows = XcapWindow::all().map_err(|e| e.to_string())?;

    let mut result = Vec::new();
    for w in windows {
        let title = w.title().unwrap_or_default();
        if title.is_empty() {
            continue;
        }
        result.push(WindowInfo {
            id: w.id().unwrap_or(0),
            app_name: w.app_name().unwrap_or_default(),
            title,
            x: w.x().unwrap_or(0),
            y: w.y().unwrap_or(0),
            width: w.width().unwrap_or(0),
            height: w.height().unwrap_or(0),
        });
    }
    Ok(result)
}

/// Capture window thumbnail (small preview) - returns base64-encoded PNG
#[tauri::command]
pub fn get_window_thumbnail(window_id: u32, max_size: u32) -> Result<String, String> {
    let windows = XcapWindow::all().map_err(|e| e.to_string())?;
    let window = windows
        .into_iter()
        .find(|w| w.id().unwrap_or(0) == window_id)
        .ok_or("Window not found")?;

    let image = window.capture_image().map_err(|e| e.to_string())?;

    // Resize to thumbnail
    let (width, height) = (image.width(), image.height());
    let (new_width, new_height) = if width > height {
        let ratio = max_size as f32 / width as f32;
        (max_size, (height as f32 * ratio) as u32)
    } else {
        let ratio = max_size as f32 / height as f32;
        ((width as f32 * ratio) as u32, max_size)
    };

    let thumbnail = image::imageops::resize(&image, new_width, new_height, image::imageops::FilterType::Lanczos3);
    image_to_base64_png(&thumbnail)
}

/// Capture specific window by ID - returns base64-encoded PNG
#[tauri::command]
pub fn capture_window(window_id: u32) -> Result<String, String> {
    let windows = XcapWindow::all().map_err(|e| e.to_string())?;
    let window = windows
        .into_iter()
        .find(|w| w.id().unwrap_or(0) == window_id)
        .ok_or("Window not found")?;

    let image = window.capture_image().map_err(|e| e.to_string())?;
    image_to_base64_png(&image)
}

/// Get monitor list
#[tauri::command]
pub fn get_monitors() -> Result<Vec<MonitorInfo>, String> {
    let monitors = Monitor::all().map_err(|e| e.to_string())?;

    let mut result = Vec::new();
    for m in monitors {
        result.push(MonitorInfo {
            id: m.id().unwrap_or(0),
            name: m.name().unwrap_or_default(),
            width: m.width().unwrap_or(0),
            height: m.height().unwrap_or(0),
            x: m.x().unwrap_or(0),
            y: m.y().unwrap_or(0),
            is_primary: m.is_primary().unwrap_or(false),
        });
    }
    Ok(result)
}
</file>

<file path="plans/251226-1356-tauri-screenshot-app/plan.md">
---
title: "BeautyFullShot - Cross-platform Screenshot Beautifier"
description: "Tauri v2 + React + Konva app for screenshot capture, annotation, and beautification"
status: completed
phase-03-completed: 2025-12-27
phase-05-completed: 2025-12-29
phase-08-completed: 2025-12-29
priority: P1
effort: 36h
branch: master
tags: [tauri, react, konva, screenshot, desktop-app]
created: 2025-12-26
---

# BeautyShot Implementation Plan

Cross-platform screenshot beautification app inspired by Winshot. Built with Tauri v2 (Rust) + React + TypeScript + react-konva.

## Tech Stack

| Layer | Technology |
|-------|------------|
| Framework | Tauri v2.x |
| Backend | Rust + xcap crate |
| Frontend | React 18 + TypeScript + Vite |
| Canvas | react-konva 18.x + konva |
| Styling | Tailwind CSS |
| Plugins | global-shortcut, notification |

## Phases Overview

| Phase | Title | Status | Effort | File |
|-------|-------|--------|--------|------|
| 01 | Project Setup & Scaffolding | ✅ DONE | 2h | [phase-01](./phase-01-project-setup.md) |
| 02 | Screenshot Capture | ✅ DONE | 4h | [phase-02](./phase-02-screenshot-capture.md) |
| 03 | Canvas Editor Foundation | ✅ DONE | 4h | [phase-03](./phase-03-canvas-editor.md) |
| 04 | Annotation Tools | ✅ DONE | 6h | [phase-04](./phase-04-annotation-tools.md) |
| 05 | Beautification Features | ✅ DONE | 4h | [phase-05](./phase-05-beautification.md) |
| 06 | Export System | ✅ DONE | 3h | [phase-06](./phase-06-export-system.md) |
| 07 | Native OS Integration | ✅ DONE | 5h | [phase-07](./phase-07-native-integration.md) |
| 08 | Polish & Distribution | ✅ DONE | 4h | [phase-08](./phase-08-polish-distribution.md) |

## Target Platforms

- Windows 10+ (x64)
- macOS 11+ (Intel & Apple Silicon)
- Ubuntu 22.04+ (X11, Wayland partial)

## Success Metrics

- Bundle size: < 15MB
- Cold start: < 1s
- RAM usage: < 100MB idle
- All Winshot annotation tools working
- Screenshot capture on all 3 platforms

## Dependencies

```toml
# Rust (Cargo.toml)
xcap = "0.8"
tauri = "2.0"
tauri-plugin-global-shortcut = "2.0"
tauri-plugin-notification = "2.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

```json
// package.json
"react": "^18.3.0",
"react-konva": "^18.2.10",
"konva": "^9.3.0",
"@tauri-apps/api": "^2.0.0"
```

## Validation Summary

**Validated:** 2025-12-26 (Re-validated)
**Questions asked:** 8 total (5 initial + 3 re-validate)

### Confirmed Decisions

**Round 1 (Initial):**
- **Undo/Redo**: Add in Phase 4 (+2h effort)
- **Linux Wayland**: X11 only, warn when Wayland detected
- **Settings persistence**: localStorage
- **Auto-update**: Add in Phase 8 (+2h effort, use tauri-plugin-updater)
- **Default hotkey**: Cmd/Ctrl+Shift+C

**Round 2 (Re-validate):**
- **Project name**: `BeautyFullShot` (play on "full platform support")
- **macOS notarization**: Defer to later (ship unsigned first)
- **State management**: Zustand (keep as planned)
- **UI components**: Pure Tailwind (no library)
- **i18n**: English + Vietnamese from start
- **Default export**: PNG
- **License**: MIT

### Action Items
- [x] Phase 01: Rename project to `BeautyFullShot` ✅
- [ ] Phase 04: Add undo/redo với Zustand temporal middleware
- [x] Phase 02: Add Wayland detection + warning ✅
- [ ] Phase 07: Add i18n support (English + Vietnamese)
- [ ] Phase 08: Add tauri-plugin-updater integration
- [x] Add LICENSE file (MIT) ✅

---

## Unresolved Questions

1. ~~Undo/redo mechanism?~~ → **RESOLVED: Phase 4**
2. ~~macOS notarization?~~ → **RESOLVED: Defer**
3. ~~Wayland support?~~ → **RESOLVED: X11 only**

**All questions resolved. Ready for implementation.**
</file>

<file path="src/components/layout/editor-layout.tsx">
// EditorLayout - Main application layout with toolbar, canvas, and sidebar

import { useCallback, useEffect, useState } from 'react';
import { CanvasEditor } from '../canvas/canvas-editor';
import { ZoomControls } from '../canvas/zoom-controls';
import { Toolbar } from '../toolbar/toolbar';
import { Sidebar } from '../sidebar/sidebar';
import { WindowPickerModal } from '../capture/window-picker-modal';
import { useUIStore } from '../../stores/ui-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { useCropStore } from '../../stores/crop-store';
import { logError } from '../../utils/logger';

// Helper: Load image and get dimensions
function loadImageFromBytes(bytes: Uint8Array): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const blob = new Blob([bytes], { type: 'image/png' });
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve({ width: img.width, height: img.height });
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };
    img.src = url;
  });
}

export function EditorLayout() {
  const { isWindowPickerOpen, closeWindowPicker } = useUIStore();
  const { setImageFromBytes, fitToView } = useCanvasStore();
  const { clearCrop } = useCropStore();
  const [isDragging, setIsDragging] = useState(false);

  // Handle window capture with auto-fit
  const handleWindowCapture = useCallback(
    (bytes: Uint8Array, width: number, height: number) => {
      setImageFromBytes(bytes, width, height);
      // Auto-fit to view after capture
      setTimeout(() => fitToView(), 50);
    },
    [setImageFromBytes, fitToView]
  );

  // Handle image load from File/Blob
  const handleImageFile = useCallback(async (file: File | Blob) => {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const bytes = new Uint8Array(arrayBuffer);
      const { width, height } = await loadImageFromBytes(bytes);
      clearCrop();
      setImageFromBytes(bytes, width, height);
      setTimeout(() => fitToView(), 50);
    } catch (e) {
      logError('EditorLayout:handleImageFile', e);
    }
  }, [clearCrop, setImageFromBytes, fitToView]);

  // Handle paste from clipboard
  useEffect(() => {
    const handlePaste = async (e: ClipboardEvent) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) {
            await handleImageFile(file);
          }
          return;
        }
      }
    };

    window.addEventListener('paste', handlePaste);
    return () => window.removeEventListener('paste', handlePaste);
  }, [handleImageFile]);

  // Handle drag-drop events (using native DOM events for Tauri compatibility)
  useEffect(() => {
    let dragCounter = 0;

    const handleDragEnter = (e: globalThis.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter++;
      if (e.dataTransfer?.types.includes('Files')) {
        setIsDragging(true);
      }
    };

    const handleDragOver = (e: globalThis.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
    };

    const handleDragLeave = (e: globalThis.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter--;
      if (dragCounter === 0) {
        setIsDragging(false);
      }
    };

    const handleDrop = async (e: globalThis.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter = 0;
      setIsDragging(false);

      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        const file = files[0];
        // Check MIME type or file extension (macOS Finder may not set MIME)
        const isImage = file.type.startsWith('image/') ||
          /\.(png|jpg|jpeg|gif|webp|bmp|svg|ico|tiff?)$/i.test(file.name);
        if (isImage) {
          await handleImageFile(file);
        }
      }
    };

    document.addEventListener('dragenter', handleDragEnter);
    document.addEventListener('dragover', handleDragOver);
    document.addEventListener('dragleave', handleDragLeave);
    document.addEventListener('drop', handleDrop);

    return () => {
      document.removeEventListener('dragenter', handleDragEnter);
      document.removeEventListener('dragover', handleDragOver);
      document.removeEventListener('dragleave', handleDragLeave);
      document.removeEventListener('drop', handleDrop);
    };
  }, [handleImageFile]);

  return (
    <div className="h-screen w-screen flex flex-col overflow-hidden canvas-area spatial-gap">
      {/* Top toolbar - floating glass panel */}
      <Toolbar />

      {/* Main content area with spatial gaps */}
      <div className="flex-1 flex min-h-0 overflow-hidden gap-3">
        {/* Canvas area - central focus with rounded corners */}
        <div className="flex-1 relative min-w-0 overflow-hidden rounded-2xl">
          <CanvasEditor />
          <ZoomControls />
        </div>

        {/* Right sidebar - floating glass panel */}
        <Sidebar />
      </div>

      {/* Drag overlay indicator */}
      {isDragging && (
        <div className="fixed inset-0 z-[9999] bg-orange-500/20 border-4 border-dashed border-orange-500 flex items-center justify-center pointer-events-none">
          <div className="glass-heavy rounded-2xl px-8 py-6 text-center">
            <svg className="w-16 h-16 mx-auto mb-3 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <p className="text-lg font-medium text-gray-700 dark:text-gray-200">Drop image here</p>
          </div>
        </div>
      )}

      {/* Window picker modal */}
      <WindowPickerModal
        isOpen={isWindowPickerOpen}
        onClose={closeWindowPicker}
        onCapture={handleWindowCapture}
      />
    </div>
  );
}
</file>

<file path="src/components/sidebar/export-panel.tsx">
// ExportPanel - UI for export settings and actions

import { useExportStore } from '../../stores/export-store';
import { useExport } from '../../hooks/use-export';

/** Loading spinner component */
function Spinner() {
  return (
    <svg
      className="animate-spin h-4 w-4 inline-block mr-1"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      />
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      />
    </svg>
  );
}

export function ExportPanel() {
  const {
    format,
    quality,
    pixelRatio,
    setFormat,
    setQuality,
    setPixelRatio,
  } = useExportStore();

  const { copyToClipboard, quickSave, saveAs, isExporting, exportOperation } =
    useExport();

  return (
    <div className="p-3 glass-flat rounded-xl mb-2">
      <h3 className="font-medium mb-3 text-gray-800 dark:text-gray-200">Export</h3>

      {/* Format selection */}
      <div className="mb-4">
        <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">Format</label>
        <div className="flex gap-2">
          <button
            onClick={() => setFormat('png')}
            disabled={isExporting}
            className={`flex-1 py-1.5 rounded-lg text-sm font-medium transition-all ${
              format === 'png'
                ? 'glass-btn glass-btn-active text-orange-500'
                : 'glass-btn text-gray-600 dark:text-gray-300'
            } ${isExporting ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            PNG
          </button>
          <button
            onClick={() => setFormat('jpeg')}
            disabled={isExporting}
            className={`flex-1 py-1.5 rounded-lg text-sm font-medium transition-all ${
              format === 'jpeg'
                ? 'glass-btn glass-btn-active text-orange-500'
                : 'glass-btn text-gray-600 dark:text-gray-300'
            } ${isExporting ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            JPEG
          </button>
        </div>
      </div>

      {/* JPEG quality slider */}
      {format === 'jpeg' && (
        <div className="mb-4">
          <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">
            Quality: {Math.round(quality * 100)}%
          </label>
          <input
            type="range"
            min="10"
            max="100"
            value={quality * 100}
            onChange={(e) => setQuality(Number(e.target.value) / 100)}
            disabled={isExporting}
            className={`w-full cursor-pointer ${
              isExporting ? 'opacity-50 cursor-not-allowed' : ''
            }`}
          />
        </div>
      )}

      {/* Resolution (pixelRatio) */}
      <div className="mb-4">
        <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">Resolution</label>
        <div className="flex gap-2">
          {[1, 2, 3].map((ratio) => (
            <button
              key={ratio}
              onClick={() => setPixelRatio(ratio)}
              disabled={isExporting}
              className={`flex-1 py-1.5 rounded-lg text-sm font-medium transition-all ${
                pixelRatio === ratio
                  ? 'glass-btn glass-btn-active text-orange-500'
                  : 'glass-btn text-gray-600 dark:text-gray-300'
              } ${isExporting ? 'opacity-50 cursor-not-allowed' : ''}`}
            >
              {ratio}x
            </button>
          ))}
        </div>
        <span className="text-xs text-gray-400 dark:text-gray-500 mt-1 block">
          Higher = sharper on Retina displays
        </span>
      </div>

      {/* Action buttons with loading states */}
      <div className="space-y-2">
        <button
          onClick={quickSave}
          disabled={isExporting}
          className={`w-full py-2.5 glass-btn glass-btn-active text-orange-500 rounded-xl text-sm font-medium transition-all ${
            isExporting ? 'opacity-70 cursor-not-allowed' : ''
          }`}
        >
          {exportOperation === 'quickSave' ? (
            <>
              <Spinner />
              Saving...
            </>
          ) : (
            'Quick Save (Pictures)'
          )}
        </button>
        <button
          onClick={saveAs}
          disabled={isExporting}
          className={`w-full py-2.5 glass-btn text-amber-600 dark:text-amber-400 rounded-xl text-sm font-medium transition-all ${
            isExporting ? 'opacity-70 cursor-not-allowed' : ''
          }`}
        >
          {exportOperation === 'saveAs' ? (
            <>
              <Spinner />
              Saving...
            </>
          ) : (
            'Save As...'
          )}
        </button>
        <button
          onClick={copyToClipboard}
          disabled={isExporting}
          className={`w-full py-2.5 glass-btn text-gray-600 dark:text-gray-300 rounded-xl text-sm font-medium transition-all ${
            isExporting ? 'opacity-70 cursor-not-allowed' : ''
          }`}
        >
          {exportOperation === 'clipboard' ? (
            <>
              <Spinner />
              Copying...
            </>
          ) : (
            'Copy to Clipboard'
          )}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/hooks/use-screenshot.ts">
// useScreenshot hook - React hook for screenshot capture functionality
// Returns raw bytes - URL lifecycle managed by canvas-store

import { useState, useCallback, useEffect } from "react";
import * as api from "../utils/screenshot-api";
import type { WindowInfo, MonitorInfo } from "../types/screenshot";

interface CaptureRegion {
  x: number;
  y: number;
  width: number;
  height: number;
}

interface UseScreenshotReturn {
  // State
  loading: boolean;
  error: string | null;

  // Capture actions - return raw bytes
  captureFullscreen: () => Promise<Uint8Array | null>;
  captureRegion: (region: CaptureRegion) => Promise<Uint8Array | null>;
  captureRegionInteractive: () => Promise<Uint8Array | null>;
  captureWindow: (windowId: number) => Promise<Uint8Array | null>;

  // Data fetching
  getWindows: () => Promise<WindowInfo[]>;
  getMonitors: () => Promise<MonitorInfo[]>;

  // Permission checks
  checkPermission: () => Promise<boolean>;
  waylandWarning: string | null;
}

export function useScreenshot(): UseScreenshotReturn {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [waylandWarning, setWaylandWarning] = useState<string | null>(null);

  // Check for Wayland on mount (Linux only)
  useEffect(() => {
    api.checkWayland().then((warning) => {
      if (warning) setWaylandWarning(warning);
    });
  }, []);

  // Auto-dismiss errors after 5 seconds
  useEffect(() => {
    if (error) {
      const timer = setTimeout(() => setError(null), 5000);
      return () => clearTimeout(timer);
    }
  }, [error]);

  const captureFullscreen = useCallback(async (): Promise<Uint8Array | null> => {
    setLoading(true);
    setError(null);
    try {
      // Use hidden capture to exclude app window from screenshot
      const bytes = await api.captureFullscreenHidden();
      return bytes;
    } catch (e) {
      setError(String(e));
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const captureRegion = useCallback(
    async (region: CaptureRegion): Promise<Uint8Array | null> => {
      setLoading(true);
      setError(null);
      try {
        // Use hidden capture to exclude app window from screenshot
        const bytes = await api.captureRegionHidden(region);
        return bytes;
      } catch (e) {
        setError(String(e));
        return null;
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const captureRegionInteractive = useCallback(async (): Promise<Uint8Array | null> => {
    setLoading(true);
    setError(null);
    try {
      // This opens the overlay window for interactive region selection
      // The actual capture is handled by the overlay via events
      await api.createOverlayWindow();
      // Note: This function returns null immediately because actual capture
      // happens asynchronously via region-selected event
      return null;
    } catch (e) {
      setError(String(e));
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const captureWindow = useCallback(
    async (windowId: number): Promise<Uint8Array | null> => {
      setLoading(true);
      setError(null);
      try {
        const bytes = await api.captureWindow(windowId);
        return bytes;
      } catch (e) {
        setError(String(e));
        return null;
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const getWindows = useCallback(async () => {
    return await api.getWindows();
  }, []);

  const getMonitors = useCallback(async () => {
    return await api.getMonitors();
  }, []);

  const checkPermission = useCallback(async () => {
    return await api.checkScreenPermission();
  }, []);

  return {
    loading,
    error,
    captureFullscreen,
    captureRegion,
    captureRegionInteractive,
    captureWindow,
    getWindows,
    getMonitors,
    checkPermission,
    waylandWarning,
  };
}
</file>

<file path="src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Default capabilities for BeautyFullShot",
  "windows": ["main", "region-overlay"],
  "permissions": [
    "core:default",
    "core:window:default",
    "core:window:allow-hide",
    "core:window:allow-show",
    "core:window:allow-set-focus",
    "core:window:allow-close",
    "core:window:allow-scale-factor",
    "core:window:allow-set-fullscreen",
    "core:event:default",
    "core:event:allow-emit",
    "core:event:allow-emit-to",
    "core:event:allow-listen",
    "opener:default",
    "global-shortcut:default",
    "notification:default",
    "dialog:default",
    "clipboard-manager:default",
    "clipboard-manager:allow-write-image",
    "process:default"
  ]
}
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: aarch64-apple-darwin
            args: --target aarch64-apple-darwin
          - platform: macos-latest
            target: x86_64-apple-darwin
            args: --target x86_64-apple-darwin
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            args: ''
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            args: ''

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          # Add PipeWire upstream PPA for version >= 0.3.65 (required by libspa 0.8.0)
          sudo add-apt-repository -y ppa:pipewire-debian/pipewire-upstream
          sudo apt-get update
          # Core Tauri deps + xcap deps for X11/Wayland support
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            libpipewire-0.3-dev \
            libdbus-1-dev \
            libwayland-dev \
            libegl-dev \
            libxcb1-dev \
            libxrandr-dev \
            pkg-config

      - name: Import Apple certificate
        if: matrix.platform == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      - name: Install frontend dependencies
        run: npm ci

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Tauri updater signing
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # Apple signing identity (macOS only)
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Apple notarization (macOS only)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'BeautyFullShot ${{ github.ref_name }}'
          releaseBody: 'See the assets to download this version.'
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.args }}

  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test -- --run

      - name: TypeScript check
        run: npx tsc --noEmit
</file>

<file path="src/components/canvas/zoom-controls.tsx">
// ZoomControls - Zoom in/out, fit controls, and quick copy button

import { useCanvasStore } from '../../stores/canvas-store';
import { useExport } from '../../hooks/use-export';
import { ZOOM } from '../../constants/canvas';

/** Copy icon SVG */
function CopyIcon() {
  return (
    <svg
      className="w-4 h-4"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
      />
    </svg>
  );
}

/** Loading spinner for copy button */
function CopySpinner() {
  return (
    <svg
      className="animate-spin w-4 h-4"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      />
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      />
    </svg>
  );
}

export function ZoomControls() {
  const { scale, setScale, fitToView } = useCanvasStore();
  const { copyToClipboard, isExporting, exportOperation } = useExport();

  const zoomIn = () => setScale(scale * ZOOM.FACTOR);
  const zoomOut = () => setScale(scale / ZOOM.FACTOR);
  const zoomFit = () => fitToView();

  const zoomPercent = Math.round(scale * 100);
  const isCopying = exportOperation === 'clipboard';

  return (
    <div
      role="group"
      aria-label="Zoom controls"
      className="absolute bottom-4 right-4 flex gap-1.5 glass floating-panel p-2"
    >
      {/* Quick copy button */}
      <button
        onClick={copyToClipboard}
        disabled={isExporting}
        aria-label="Copy to clipboard"
        title="Copy to Clipboard (⌘C / Ctrl+C)"
        className={`px-3 h-8 flex items-center justify-center gap-1.5 rounded-lg text-orange-500 text-sm font-medium transition-all ${
          isExporting
            ? 'opacity-50 cursor-not-allowed'
            : 'glass-btn hover:text-orange-600'
        }`}
      >
        {isCopying ? (
          <>
            <CopySpinner />
            Copying...
          </>
        ) : (
          <>
            <CopyIcon />
            Copy
          </>
        )}
      </button>

      {/* Separator */}
      <div className="w-px h-8 bg-gray-300/50 dark:bg-gray-500/30" />

      <button
        onClick={zoomOut}
        aria-label="Zoom out"
        className="w-8 h-8 flex items-center justify-center glass-btn rounded-lg text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white transition-all"
      >
        -
      </button>
      <span
        aria-live="polite"
        aria-label={`Zoom level ${zoomPercent} percent`}
        className="w-16 text-center text-sm leading-8 text-gray-700 dark:text-gray-200"
      >
        {zoomPercent}%
      </span>
      <button
        onClick={zoomIn}
        aria-label="Zoom in"
        className="w-8 h-8 flex items-center justify-center glass-btn rounded-lg text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white transition-all"
      >
        +
      </button>
      <button
        onClick={zoomFit}
        aria-label="Fit image to screen"
        className="px-3 h-8 text-sm glass-btn rounded-lg text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white transition-all"
      >
        Fit
      </button>
    </div>
  );
}
</file>

<file path="src/components/settings/settings-modal.tsx">
// SettingsModal - Modal dialog for app settings
// Uses React Portal to render at document body level for proper z-index stacking

import { useState, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { useSettingsStore, isValidHotkey, type HotkeyConfig, type ThemeMode } from '../../stores/settings-store';
import { updateShortcuts } from '../../utils/screenshot-api';
import { formatHotkey } from '../../utils/hotkey-formatter';

interface Props {
  isOpen: boolean;
  onClose: () => void;
}

// Hotkey display names
const HOTKEY_LABELS: Record<keyof HotkeyConfig, string> = {
  capture: 'Capture Screen',
  captureRegion: 'Capture Region',
  captureWindow: 'Capture Window',
  save: 'Quick Save',
  copy: 'Copy to Clipboard',
};

// Theme options
const THEME_OPTIONS: { value: ThemeMode; label: string }[] = [
  { value: 'light', label: 'Light' },
  { value: 'dark', label: 'Dark' },
  { value: 'system', label: 'System' },
];

const GLOBAL_HOTKEY_ACTIONS: (keyof HotkeyConfig)[] = ['capture', 'captureRegion', 'captureWindow'];

function findDuplicateHotkeys(hotkeys: HotkeyConfig): Record<string, string[]> {
  const duplicates: Record<string, string[]> = {};
  const entries = Object.entries(hotkeys) as [keyof HotkeyConfig, string][];

  for (let i = 0; i < entries.length; i++) {
    const [action1, shortcut1] = entries[i];
    if (!shortcut1) continue;

    const normalizedShortcut1 = shortcut1.toLowerCase();
    const conflicts: string[] = [];

    for (let j = 0; j < entries.length; j++) {
      if (i === j) continue;
      const [action2, shortcut2] = entries[j];
      if (!shortcut2) continue;

      if (normalizedShortcut1 === shortcut2.toLowerCase()) {
        conflicts.push(HOTKEY_LABELS[action2]);
      }
    }

    if (conflicts.length > 0) {
      duplicates[action1] = conflicts;
    }
  }

  return duplicates;
}

export function SettingsModal({ isOpen, onClose }: Props) {
  const settings = useSettingsStore();
  const modalRef = useRef<HTMLDivElement>(null);
  const closeButtonRef = useRef<HTMLButtonElement>(null);
  // Track editing state for validation feedback
  const [editingHotkey, setEditingHotkey] = useState<{ action: keyof HotkeyConfig; value: string } | null>(null);
  const [registrationErrors, setRegistrationErrors] = useState<Record<string, string>>({});

  const duplicateHotkeys = findDuplicateHotkeys(settings.hotkeys);

  useEffect(() => {
    if (!isOpen) return;

    const checkShortcuts = async () => {
      try {
        const errors = await updateShortcuts(
          settings.hotkeys.capture,
          settings.hotkeys.captureRegion,
          settings.hotkeys.captureWindow
        );

        const errorMap: Record<string, string> = {};
        for (const err of errors) {
          if (err.includes('Capture Region')) {
            errorMap.captureRegion = err;
          } else if (err.includes('Capture Window')) {
            errorMap.captureWindow = err;
          } else if (err.includes('Capture')) {
            errorMap.capture = err;
          }
        }
        setRegistrationErrors(errorMap);
      } catch (e) {
        console.error('Failed to check shortcuts:', e);
      }
    };

    checkShortcuts();
  }, [isOpen, settings.hotkeys.capture, settings.hotkeys.captureRegion, settings.hotkeys.captureWindow]);

  // Handle ESC key to close modal
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);

  // Focus management - focus close button on open
  useEffect(() => {
    if (isOpen && closeButtonRef.current) {
      closeButtonRef.current.focus();
    }
  }, [isOpen]);

  // Focus trap - keep focus within modal
  useEffect(() => {
    if (!isOpen || !modalRef.current) return;

    const modal = modalRef.current;
    const focusableElements = modal.querySelectorAll<HTMLElement>(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return;

      if (e.shiftKey) {
        // Shift + Tab: if on first element, go to last
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement?.focus();
        }
      } else {
        // Tab: if on last element, go to first
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement?.focus();
        }
      }
    };

    modal.addEventListener('keydown', handleTabKey);
    return () => modal.removeEventListener('keydown', handleTabKey);
  }, [isOpen]);

  if (!isOpen) return null;

  // Use portal to render modal at document body level for proper z-index stacking
  return createPortal(
    <div
      className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50"
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      <div
        ref={modalRef}
        className="glass-heavy floating-panel w-[500px] max-h-[80vh] overflow-hidden flex flex-col"
        role="dialog"
        aria-modal="true"
        aria-labelledby="settings-title"
      >
        {/* Header */}
        <div className="p-4 border-b border-white/10 dark:border-white/5 flex justify-between items-center flex-shrink-0">
          <h2 id="settings-title" className="text-lg font-medium text-gray-800 dark:text-gray-100">
            Settings
          </h2>
          <button
            ref={closeButtonRef}
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center glass-btn rounded-lg text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-xl leading-none transition-all"
            aria-label="Close settings (Escape)"
          >
            ×
          </button>
        </div>

        {/* Scrollable content */}
        <div className="p-4 space-y-6 overflow-y-auto flex-1">
          {/* Theme Section */}
          <section>
            <h3 className="font-medium mb-3 text-gray-700 dark:text-gray-200">Appearance</h3>
            <div className="flex gap-2">
              {THEME_OPTIONS.map((option) => (
                <button
                  key={option.value}
                  onClick={() => settings.setTheme(option.value)}
                  className={`flex-1 py-2 px-3 rounded-xl text-sm font-medium transition-all ${settings.theme === option.value
                      ? 'glass-btn glass-btn-active text-orange-500'
                      : 'glass-btn text-gray-600 dark:text-gray-300'
                    }`}
                >
                  {option.label}
                </button>
              ))}
            </div>
          </section>

          {/* Hotkeys Section */}
          <section>
            <h3 className="font-medium mb-3 text-gray-700 dark:text-gray-200">Keyboard Shortcuts</h3>
            <div className="space-y-2">
              {(Object.entries(settings.hotkeys) as [keyof HotkeyConfig, string][]).map(
                ([action, shortcut]) => {
                  const isEditing = editingHotkey?.action === action;
                  const currentValue = isEditing ? editingHotkey.value : shortcut;
                  const isValid = !currentValue || isValidHotkey(currentValue);
                  const isGlobalAction = GLOBAL_HOTKEY_ACTIONS.includes(action);
                  const hasRegistrationError = isGlobalAction && registrationErrors[action];
                  const hasDuplicate = duplicateHotkeys[action];

                  return (
                    <div
                      key={action}
                      className="flex flex-col gap-1"
                    >
                      <div className="flex justify-between items-center">
                        <label className="text-sm text-gray-600 dark:text-gray-300">
                          {HOTKEY_LABELS[action]}
                          {isGlobalAction && (
                            <span className="ml-1 text-xs text-gray-400">(global)</span>
                          )}
                        </label>
                        <div className="relative">
                          <input
                            type="text"
                            value={isEditing ? currentValue : formatHotkey(currentValue)}
                            onChange={(e) => setEditingHotkey({ action, value: e.target.value })}
                            onBlur={() => {
                              if (editingHotkey && isValidHotkey(editingHotkey.value)) {
                                settings.setHotkey(action, editingHotkey.value);
                              }
                              setEditingHotkey(null);
                            }}
                            onKeyDown={(e) => {
                              if (e.key === 'Escape') {
                                setEditingHotkey(null);
                              } else if (e.key === 'Enter' && editingHotkey && isValidHotkey(editingHotkey.value)) {
                                settings.setHotkey(action, editingHotkey.value);
                                setEditingHotkey(null);
                              }
                            }}
                            className={`w-48 px-3 py-1.5 rounded-lg text-sm focus:outline-none focus:ring-2 glass-flat text-gray-800 dark:text-gray-100 ${(isEditing && !isValid) || hasRegistrationError
                                ? 'border-red-300 focus:ring-red-500'
                                : hasDuplicate
                                  ? 'border-yellow-400 focus:ring-yellow-500'
                                  : 'focus:ring-orange-500'
                              }`}
                            placeholder="e.g., CommandOrControl+Shift+C"
                          />
                          {isEditing && !isValid && currentValue && (
                            <span className="absolute right-2 top-1/2 -translate-y-1/2 text-red-500 text-xs">
                              Invalid
                            </span>
                          )}
                        </div>
                      </div>
                      {hasRegistrationError && (
                        <p className="text-xs text-red-500 text-right">
                          Shortcut unavailable (may be in use by another app)
                        </p>
                      )}
                      {hasDuplicate && !hasRegistrationError && (
                        <p className="text-xs text-yellow-600 dark:text-yellow-400 text-right">
                          Conflicts with: {hasDuplicate.join(', ')}
                        </p>
                      )}
                    </div>
                  );
                }
              )}
            </div>
            <p className="text-xs text-gray-400 dark:text-gray-500 mt-2">
              Format: Modifier+Key (e.g., Cmd+Shift+C)
            </p>
          </section>

          {/* Behavior Section */}
          <section>
            <h3 className="font-medium mb-3 text-gray-700 dark:text-gray-200">Behavior</h3>
            <div className="space-y-3">
              <label className="flex items-center gap-3 cursor-pointer glass-flat rounded-xl p-3 transition-all hover:bg-white/20 dark:hover:bg-white/5">
                <input
                  type="checkbox"
                  checked={settings.startMinimized}
                  onChange={(e) => settings.setStartMinimized(e.target.checked)}
                  className="w-4 h-4 rounded border-gray-300 dark:border-gray-600 text-orange-500 focus:ring-orange-500"
                />
                <span className="text-sm text-gray-600 dark:text-gray-300">
                  Start minimized to tray
                </span>
              </label>

              <label className="flex items-center gap-3 cursor-pointer glass-flat rounded-xl p-3 transition-all hover:bg-white/20 dark:hover:bg-white/5">
                <input
                  type="checkbox"
                  checked={settings.closeToTray}
                  onChange={(e) => settings.setCloseToTray(e.target.checked)}
                  className="w-4 h-4 rounded border-gray-300 dark:border-gray-600 text-orange-500 focus:ring-orange-500"
                />
                <span className="text-sm text-gray-600 dark:text-gray-300">
                  Close to tray instead of quit
                </span>
              </label>

              <label className="flex items-center gap-3 cursor-pointer glass-flat rounded-xl p-3 transition-all hover:bg-white/20 dark:hover:bg-white/5">
                <input
                  type="checkbox"
                  checked={settings.showNotifications}
                  onChange={(e) => settings.setShowNotifications(e.target.checked)}
                  className="w-4 h-4 rounded border-gray-300 dark:border-gray-600 text-orange-500 focus:ring-orange-500"
                />
                <span className="text-sm text-gray-600 dark:text-gray-300">Show notifications</span>
              </label>
            </div>
          </section>

          {/* Save Location Section */}
          <section>
            <h3 className="font-medium mb-3 text-gray-700 dark:text-gray-200">Default Save Location</h3>
            <div className="space-y-2">
              {(['pictures', 'desktop', 'custom'] as const).map((loc) => (
                <label
                  key={loc}
                  className="flex items-center gap-3 cursor-pointer glass-flat rounded-xl p-3 transition-all hover:bg-white/20 dark:hover:bg-white/5"
                >
                  <input
                    type="radio"
                    name="saveLocation"
                    checked={settings.saveLocation === loc}
                    onChange={() => settings.setSaveLocation(loc)}
                    className="w-4 h-4 border-gray-300 dark:border-gray-600 text-orange-500 focus:ring-orange-500"
                  />
                  <span className="text-sm text-gray-600 dark:text-gray-300 capitalize">{loc}</span>
                </label>
              ))}

              {settings.saveLocation === 'custom' && (
                <div className="ml-6 mt-2">
                  <input
                    type="text"
                    value={settings.customSavePath || ''}
                    onChange={(e) => settings.setCustomSavePath(e.target.value)}
                    className="w-full px-3 py-2 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 glass-flat text-gray-800 dark:text-gray-100"
                    placeholder="Enter custom path..."
                  />
                </div>
              )}
            </div>
          </section>
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-white/10 dark:border-white/5 flex justify-between items-center flex-shrink-0">
          <button
            onClick={() => settings.resetToDefaults()}
            className="px-4 py-2 text-sm glass-btn rounded-xl text-gray-600 dark:text-gray-300 transition-all"
          >
            Reset to Defaults
          </button>
          <button
            onClick={onClose}
            className="px-5 py-2 glass-btn glass-btn-active text-orange-500 rounded-xl text-sm font-medium transition-all"
          >
            Done
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
}
</file>

<file path="src/components/sidebar/crop-panel.tsx">
// CropPanel - UI for crop mode with aspect ratio selection

import { ASPECT_RATIOS, OUTPUT_ASPECT_RATIOS } from '../../data/aspect-ratios';
import { useCropStore } from '../../stores/crop-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { useExportStore } from '../../stores/export-store';

export function CropPanel() {
  // Use selectors for proper Zustand 5.0 subscription
  const isCropping = useCropStore((state) => state.isCropping);
  const aspectRatio = useCropStore((state) => state.aspectRatio);
  const cropRect = useCropStore((state) => state.cropRect);
  const startCrop = useCropStore((state) => state.startCrop);
  const applyCrop = useCropStore((state) => state.applyCrop);
  const cancelCrop = useCropStore((state) => state.cancelCrop);
  const setAspectRatio = useCropStore((state) => state.setAspectRatio);
  const setCropRect = useCropStore((state) => state.setCropRect);
  const imageUrl = useCanvasStore((state) => state.imageUrl);
  const originalWidth = useCanvasStore((state) => state.originalWidth);
  const originalHeight = useCanvasStore((state) => state.originalHeight);
  const cropImage = useCanvasStore((state) => state.cropImage);
  const fitToView = useCanvasStore((state) => state.fitToView);
  const outputAspectRatio = useExportStore((state) => state.outputAspectRatio);
  const setOutputAspectRatio = useExportStore((state) => state.setOutputAspectRatio);

  // Disable crop if no image loaded
  const canCrop = imageUrl !== null && originalWidth > 0;

  // Handle aspect ratio change - recalculate crop rect to match new ratio
  const handleAspectRatioChange = (newRatio: number | null) => {
    setAspectRatio(newRatio);

    // Get current rect or default
    const currentRect = cropRect || {
      x: originalWidth * 0.1,
      y: originalHeight * 0.1,
      width: originalWidth * 0.8,
      height: originalHeight * 0.8,
    };

    // For freeform (null ratio), keep current rect as-is
    if (newRatio === null) {
      setCropRect(currentRect);
      return;
    }

    // Calculate new dimensions maintaining center point
    const centerX = currentRect.x + currentRect.width / 2;
    const centerY = currentRect.y + currentRect.height / 2;

    let newWidth: number;
    let newHeight: number;

    // Determine new size based on aspect ratio, fitting within current rect area
    const currentRatio = currentRect.width / currentRect.height;
    if (newRatio > currentRatio) {
      // New ratio is wider - use current width, calculate height
      newWidth = currentRect.width;
      newHeight = newWidth / newRatio;
    } else {
      // New ratio is taller - use current height, calculate width
      newHeight = currentRect.height;
      newWidth = newHeight * newRatio;
    }

    // Calculate new position (centered on same point)
    let newX = centerX - newWidth / 2;
    let newY = centerY - newHeight / 2;

    // Clamp to image bounds
    if (newX < 0) newX = 0;
    if (newY < 0) newY = 0;
    if (newX + newWidth > originalWidth) newX = originalWidth - newWidth;
    if (newY + newHeight > originalHeight) newY = originalHeight - newHeight;

    // If still out of bounds (rect too large), scale down
    if (newX < 0 || newY < 0) {
      const scaleX = originalWidth / newWidth;
      const scaleY = originalHeight / newHeight;
      const scale = Math.min(scaleX, scaleY) * 0.9; // 90% of max to leave margin
      newWidth *= scale;
      newHeight *= scale;
      newX = (originalWidth - newWidth) / 2;
      newY = (originalHeight - newHeight) / 2;
    }

    setCropRect({
      x: Math.max(0, newX),
      y: Math.max(0, newY),
      width: newWidth,
      height: newHeight,
    });
  };

  const handleStartCrop = () => {
    if (canCrop) {
      startCrop();
    }
  };

  const handleApplyCrop = async () => {
    // Use current cropRect or default to 80% centered if not set
    const rect = cropRect || {
      x: originalWidth * 0.1,
      y: originalHeight * 0.1,
      width: originalWidth * 0.8,
      height: originalHeight * 0.8,
    };

    // Crop the image
    await cropImage(rect);

    // Close crop mode
    applyCrop();
  };

  // Handle output aspect ratio change with auto-fit
  const handleOutputRatioChange = (ratioId: string) => {
    setOutputAspectRatio(ratioId);
    setTimeout(() => fitToView(), 0);
  };

  return (
    <div className="p-2 glass-flat rounded-xl mb-1.5">
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-sm font-medium text-gray-800 dark:text-gray-200">Crop</h3>
        {!isCropping && (
          <button
            onClick={handleStartCrop}
            disabled={!canCrop}
            className={`px-3 py-1 rounded-lg text-xs font-medium transition-all ${
              canCrop
                ? 'glass-btn text-orange-500 hover:text-orange-600'
                : 'text-gray-400 dark:text-gray-500 cursor-not-allowed'
            }`}
          >
            {canCrop ? 'Start' : 'No image'}
          </button>
        )}
      </div>

      {isCropping && (
        <>
          {/* Aspect ratio presets */}
          <div className="grid grid-cols-3 gap-1 mb-2">
            {ASPECT_RATIOS.map((ar) => (
              <button
                key={ar.id}
                onClick={() => handleAspectRatioChange(ar.ratio)}
                className={`px-1.5 py-1 text-xs font-medium rounded-lg transition-all ${
                  aspectRatio === ar.ratio
                    ? 'glass-btn glass-btn-active text-orange-500'
                    : 'glass-btn text-gray-600 dark:text-gray-300'
                }`}
              >
                {ar.name}
              </button>
            ))}
          </div>

          {/* Apply/Cancel buttons */}
          <div className="flex gap-1.5">
            <button
              onClick={handleApplyCrop}
              className="flex-1 py-1.5 glass-btn glass-btn-active text-orange-500 rounded-lg text-xs font-medium transition-all"
            >
              Apply
            </button>
            <button
              onClick={cancelCrop}
              className="flex-1 py-1.5 glass-btn text-gray-600 dark:text-gray-300 rounded-lg text-xs transition-all"
            >
              Cancel
            </button>
          </div>
        </>
      )}

      {/* Output aspect ratio selection */}
      <div className="mt-2 pt-2 border-t border-white/10 dark:border-white/5">
        <div className="flex items-center justify-between mb-1.5">
          <label className="text-xs text-gray-500 dark:text-gray-400">Output Ratio</label>
          <span className="text-xs text-gray-400 dark:text-gray-500">
            {OUTPUT_ASPECT_RATIOS.find((r) => r.id === outputAspectRatio)?.name || 'Auto'}
          </span>
        </div>
        <div className="grid grid-cols-4 gap-1">
          {OUTPUT_ASPECT_RATIOS.map((ratio) => (
            <button
              key={ratio.id}
              onClick={() => handleOutputRatioChange(ratio.id)}
              className={`py-1 px-1 rounded text-xs font-medium transition-all ${
                outputAspectRatio === ratio.id
                  ? 'glass-btn glass-btn-active text-orange-500'
                  : 'glass-btn text-gray-600 dark:text-gray-300'
              }`}
              title={ratio.name}
            >
              {ratio.id === 'auto' ? 'Auto' : ratio.id}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/toolbar/tool-settings.tsx">
// ToolSettings - Color and stroke settings for annotation tools

import { useState, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { useAnnotationStore } from '../../stores/annotation-store';
import { ColorPicker } from '../ui/color-picker';

const PRESET_COLORS = [
  '#ff0000', // Red
  '#ff6600', // Orange
  '#ffcc00', // Yellow
  '#00cc00', // Green
  '#0066ff', // Blue
  '#9933ff', // Purple
  '#000000', // Black
  '#ffffff', // White
];

export function ToolSettings() {
  const {
    strokeColor,
    strokeWidth,
    setStrokeColor,
    setStrokeWidth,
  } = useAnnotationStore();

  const [showColorPicker, setShowColorPicker] = useState(false);

  const closeColorPicker = useCallback(() => {
    setShowColorPicker(false);
  }, []);

  return (
    <div className="flex items-center gap-3">
      {/* Stroke color - 2 rows grid (5 columns x 2 rows) */}
      <div className="flex items-center gap-1.5">
        <label className="text-xs text-gray-500 dark:text-gray-400">Color:</label>
        <div className="grid grid-cols-5 gap-0.5">
          {PRESET_COLORS.map((color) => (
            <button
              key={`stroke-${color}`}
              onClick={() => setStrokeColor(color)}
              className={`w-5 h-5 rounded border cursor-pointer ${
                strokeColor === color ? 'ring-2 ring-orange-500' : 'border-gray-300 dark:border-gray-600'
              }`}
              style={{ backgroundColor: color }}
              title={color}
              aria-label={`Stroke color ${color}`}
            />
          ))}
          {/* Custom color picker button - 9th item */}
          <button
            onClick={() => setShowColorPicker(!showColorPicker)}
            className={`w-5 h-5 rounded border-2 border-dashed flex items-center justify-center transition-all hover:scale-105 cursor-pointer ${
              !PRESET_COLORS.includes(strokeColor)
                ? 'ring-2 ring-orange-500 border-orange-500'
                : 'border-gray-400 dark:border-gray-500'
            }`}
            style={{
              backgroundColor: !PRESET_COLORS.includes(strokeColor) ? strokeColor : 'transparent',
            }}
            title="Custom color"
            aria-label="Pick custom color"
          >
            {PRESET_COLORS.includes(strokeColor) && (
              <svg className="w-2.5 h-2.5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
              </svg>
            )}
          </button>
        </div>
      </div>

      {/* Color Picker Modal - Using Portal */}
      {showColorPicker && createPortal(
        <>
          <div
            className="fixed inset-0 bg-black/30 z-[9998]"
            onClick={closeColorPicker}
          />
          <div
            className="fixed z-[9999] glass-heavy rounded-2xl shadow-2xl w-[260px] p-4"
            style={{
              left: '50%',
              top: '50%',
              transform: 'translate(-50%, -50%)',
            }}
          >
            <div className="flex justify-between items-center mb-3">
              <p className="text-sm font-medium text-gray-700 dark:text-gray-200">Pick Color</p>
              <button
                onClick={closeColorPicker}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <ColorPicker color={strokeColor} onChange={setStrokeColor} />
            <div className="mt-3 pt-3 border-t border-white/10">
              <p className="text-xs text-gray-500 dark:text-gray-400 mb-2">Presets</p>
              <div className="flex flex-wrap gap-1.5">
                {PRESET_COLORS.map((color) => (
                  <button
                    key={`picker-${color}`}
                    onClick={() => setStrokeColor(color)}
                    className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 cursor-pointer ${
                      strokeColor === color ? 'border-orange-500' : 'border-gray-300 dark:border-gray-600'
                    }`}
                    style={{ backgroundColor: color }}
                    title={color}
                  />
                ))}
              </div>
            </div>
            {/* OK Button */}
            <div className="mt-4 flex justify-end">
              <button
                onClick={closeColorPicker}
                className="px-4 py-1.5 bg-orange-500 hover:bg-orange-600 text-white text-sm font-medium rounded-lg transition-colors cursor-pointer"
              >
                OK
              </button>
            </div>
          </div>
        </>,
        document.body
      )}

      {/* Stroke width - horizontal slider */}
      <div className="flex items-center gap-1.5">
        <label className="text-xs text-gray-500 dark:text-gray-400">Width:</label>
        <input
          type="range"
          min="1"
          max="100"
          value={strokeWidth}
          onChange={(e) => setStrokeWidth(Number(e.target.value))}
          className="w-20 h-1.5 cursor-pointer"
          title={`${strokeWidth}px`}
        />
        <span className="text-xs text-gray-600 dark:text-gray-300 w-8 text-right">{strokeWidth}px</span>
      </div>
    </div>
  );
}
</file>

<file path="src/utils/screenshot-api.ts">
// Screenshot capture API - Tauri IPC wrapper
// Communicates with Rust backend for screenshot functionality

import { invoke } from "@tauri-apps/api/core";
import { getCurrentWindow } from "@tauri-apps/api/window";
import type { MonitorInfo, WindowInfo, CaptureRegion } from "../types/screenshot";

// Delay for window hide - allows OS to process hide before capture
const MACOS_HIDE_DELAY_MS = 10;
const WINDOWS_HIDE_DELAY_MS = 200;

// Detect platform via userAgent
const userAgent = navigator.userAgent.toLowerCase();
const isWindows = userAgent.includes("win");

/**
 * Decode base64 string to Uint8Array (fast binary conversion)
 */
function base64ToBytes(base64: string): Uint8Array {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

/**
 * Capture the primary monitor's full screen
 * @returns PNG image bytes as Uint8Array
 */
export async function captureFullscreen(): Promise<Uint8Array> {
  const base64 = await invoke<string>("capture_fullscreen");
  return base64ToBytes(base64);
}

/**
 * Capture a specific region from the primary monitor
 * @param region - The region coordinates and dimensions
 * @returns PNG image bytes as Uint8Array
 */
export async function captureRegion(region: CaptureRegion): Promise<Uint8Array> {
  const base64 = await invoke<string>("capture_region", {
    x: region.x,
    y: region.y,
    width: region.width,
    height: region.height,
  });
  return base64ToBytes(base64);
}

/**
 * Capture a specific window by ID
 * @param windowId - The window ID to capture
 * @returns PNG image bytes as Uint8Array
 */
export async function captureWindow(windowId: number): Promise<Uint8Array> {
  const base64 = await invoke<string>("capture_window", { windowId });
  return base64ToBytes(base64);
}

/**
 * Get list of all capturable windows
 * @returns Array of WindowInfo objects
 */
export async function getWindows(): Promise<WindowInfo[]> {
  return await invoke<WindowInfo[]>("get_windows");
}

/**
 * Get thumbnail preview of a window
 * @param windowId - The window ID to capture
 * @param maxSize - Maximum width/height of thumbnail (default 200px)
 * @returns Base64-encoded PNG thumbnail string
 */
export async function getWindowThumbnail(windowId: number, maxSize: number = 200): Promise<string> {
  return await invoke<string>("get_window_thumbnail", { windowId, maxSize });
}

/**
 * Get list of all monitors
 * @returns Array of MonitorInfo objects
 */
export async function getMonitors(): Promise<MonitorInfo[]> {
  return await invoke<MonitorInfo[]>("get_monitors");
}

/**
 * Check if screen capture permission is granted (macOS)
 * @returns true if permission granted, false otherwise
 */
export async function checkScreenPermission(): Promise<boolean> {
  return await invoke<boolean>("check_screen_permission");
}

/**
 * Check if running on Wayland (Linux)
 * @returns Warning message if Wayland detected, null otherwise
 */
export async function checkWayland(): Promise<string | null> {
  return await invoke<string | null>("check_wayland");
}

/**
 * Convert PNG bytes to a displayable image URL
 * @param bytes - PNG image bytes
 * @returns Object URL for the image (remember to revoke when done)
 */
export function bytesToImageUrl(bytes: Uint8Array): string {
  const blob = new Blob([bytes], { type: "image/png" });
  return URL.createObjectURL(blob);
}

/**
 * Helper: Wait for specified milliseconds
 */
function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Hide the current app window, execute capture, then show the window again
 * Ensures screenshots don't include the app itself
 * @param captureFunc - The capture function to execute while hidden
 * @returns PNG image bytes as Uint8Array
 */
export async function captureWithHiddenWindow<T>(
  captureFunc: () => Promise<T>
): Promise<T> {
  const appWindow = getCurrentWindow();

  // Hide window before capture
  await appWindow.hide();

  // Wait for hide animation to complete
  // Windows DWM needs more time than macOS/Linux
  const hideDelay = isWindows ? WINDOWS_HIDE_DELAY_MS : MACOS_HIDE_DELAY_MS;
  await delay(hideDelay);

  try {
    // Perform the capture
    const result = await captureFunc();
    return result;
  } finally {
    // Show window immediately, focus in background (non-blocking)
    await appWindow.show();
    appWindow.setFocus(); // Fire and forget
  }
}

/**
 * Capture fullscreen with window hidden
 * @returns PNG image bytes as Uint8Array
 */
export async function captureFullscreenHidden(): Promise<Uint8Array> {
  return captureWithHiddenWindow(captureFullscreen);
}

/**
 * Capture region with window hidden
 * @param region - The region coordinates and dimensions
 * @returns PNG image bytes as Uint8Array
 */
export async function captureRegionHidden(region: CaptureRegion): Promise<Uint8Array> {
  return captureWithHiddenWindow(() => captureRegion(region));
}


/**
 * Update global keyboard shortcuts in the backend
 * @param capture - Hotkey for fullscreen capture
 * @param captureRegion - Hotkey for region capture
 * @param captureWindow - Hotkey for window capture
 * @returns Array of error messages for shortcuts that failed to register
 */
export async function updateShortcuts(
  capture: string,
  captureRegion: string,
  captureWindow: string
): Promise<string[]> {
  return await invoke<string[]>("update_shortcuts", { capture, captureRegion, captureWindow });
}

/**
 * Create overlay window for interactive region selection
 */
export async function createOverlayWindow(): Promise<void> {
  await invoke("create_overlay_window");
}

/**
 * Close overlay window
 */
export async function closeOverlayWindow(): Promise<void> {
  await invoke("close_overlay_window");
}

/**
 * Get screenshot data stored for overlay background
 */
export async function getScreenshotData(): Promise<string | null> {
  return await invoke<string | null>("get_screenshot_data");
}

/**
 * Clear stored screenshot data
 */
export async function clearScreenshotData(): Promise<void> {
  await invoke("clear_screenshot_data");
}
</file>

<file path="src/components/sidebar/sidebar.tsx">
// Sidebar - Right sidebar with Edit (background/crop) and Export tabs

import { useState } from 'react';
import { BackgroundPanel } from './background-panel';
import { CropPanel } from './crop-panel';
import { ExportPanel } from './export-panel';

type SidebarTab = 'edit' | 'export';

export function Sidebar() {
  const [activeTab, setActiveTab] = useState<SidebarTab>('edit');

  const tabs: { id: SidebarTab; label: string }[] = [
    { id: 'edit', label: 'Edit' },
    { id: 'export', label: 'Export' },
  ];

  return (
    <div className="w-80 glass floating-panel flex flex-col h-full">
      {/* Tab navigation - compact */}
      <div className="flex shrink-0 p-1 gap-1">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`flex-1 py-1.5 px-3 text-sm font-medium transition-all rounded-lg ${
              activeTab === tab.id
                ? 'glass-btn glass-btn-active text-orange-500'
                : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-white/30 dark:hover:bg-white/5'
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Tab content */}
      <div className="flex-1 overflow-y-auto px-1 pb-1">

        {activeTab === 'edit' && (
          <>
            <CropPanel />
            <BackgroundPanel />
          </>
        )}

        {activeTab === 'export' && <ExportPanel />}
      </div>
    </div>
  );
}
</file>

<file path="src/hooks/use-drawing.ts">
// useDrawing hook - Handles mouse events for creating annotations

import { useState, useCallback } from 'react';
import Konva from 'konva';
import { useAnnotationStore } from '../stores/annotation-store';
import { useBackgroundStore } from '../stores/background-store';
import { useCanvasStore } from '../stores/canvas-store';
import { useExportStore } from '../stores/export-store';
import { ANNOTATION_DEFAULTS } from '../constants/annotations';
import { calculateAspectRatioExtend } from '../utils/export-utils';
import type {
  RectAnnotation,
  EllipseAnnotation,
  LineAnnotation,
  FreehandAnnotation,
  TextAnnotation,
  NumberAnnotation,
  SpotlightAnnotation,
} from '../types/annotations';

export interface PreviewShape {
  type: 'rectangle' | 'ellipse' | 'line' | 'arrow' | 'freehand' | 'spotlight';
  startX: number;
  startY: number;
  currentX: number;
  currentY: number;
  points?: number[]; // For freehand
}

interface DrawingState {
  isDrawing: boolean;
  startPos: { x: number; y: number };
  preview: PreviewShape | null;
  freehandPoints: number[];
  textInputPos: { x: number; y: number; screenX: number; screenY: number } | null;
}

export function useDrawing() {
  const [state, setState] = useState<DrawingState>({
    isDrawing: false,
    startPos: { x: 0, y: 0 },
    preview: null,
    freehandPoints: [],
    textInputPos: null,
  });

  const {
    strokeColor,
    fillColor,
    strokeWidth,
    fontSize,
    fontFamily,
    addAnnotation,
    setTool,
  } = useAnnotationStore();

  // Get content offset (padding + aspect ratio extension offset)
  const getContentOffset = () => {
    const { originalWidth, originalHeight } = useCanvasStore.getState();
    const { outputAspectRatio } = useExportStore.getState();
    const padding = useBackgroundStore.getState().getPaddingPx(originalWidth, originalHeight);

    // Calculate aspect ratio extension offset
    const baseWidth = originalWidth + padding * 2;
    const baseHeight = originalHeight + padding * 2;
    const aspectExtension = calculateAspectRatioExtend(baseWidth, baseHeight, outputAspectRatio);

    const contentOffsetX = aspectExtension?.offsetX || 0;
    const contentOffsetY = aspectExtension?.offsetY || 0;

    return {
      padding,
      contentOffsetX,
      contentOffsetY,
    };
  };

  const getPointerPosition = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent | TouchEvent>) => {
      const stage = e.target.getStage();
      const pos = stage?.getPointerPosition();
      if (!pos || !stage) return null;

      // Adjust for stage transform (zoom/pan)
      const transform = stage.getAbsoluteTransform().copy().invert();
      const transformed = transform.point(pos);

      // Adjust for content offset (aspect ratio extension + padding)
      const { padding, contentOffsetX, contentOffsetY } = getContentOffset();
      return {
        x: transformed.x - contentOffsetX - padding,
        y: transformed.y - contentOffsetY - padding,
      };
    },
    []
  );

  const handleMouseDown = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      const tool = useAnnotationStore.getState().currentTool;
      // Only handle left click and when using a drawing tool
      if (e.evt.button !== 0 || tool === 'select' || !tool) {
        return;
      }

      const target = e.target;
      const isAnnotation = target.draggable() && target.id();
      if (isAnnotation) {
        // When clicking on existing annotation while in drawing mode,
        // switch to select mode and select the clicked annotation
        const annotationId = target.id();
        setTool('select');
        useAnnotationStore.getState().setSelected(annotationId);
        return;
      }

      const pos = getPointerPosition(e);
      if (!pos) return;

      // Click-to-place tools
      if (tool === 'text') {
        if (state.textInputPos) {
          return;
        }
        const stage = e.target.getStage();
        const screenPos = stage?.getPointerPosition();
        setState((prev) => ({
          ...prev,
          textInputPos: {
            x: pos.x,
            y: pos.y,
            screenX: screenPos?.x ?? 0,
            screenY: screenPos?.y ?? 0,
          },
        }));
        return;
      }

      if (tool === 'number') {
        const { getNextNumber, strokeColor: numberColor } = useAnnotationStore.getState();
        const numberAnnotation: Omit<NumberAnnotation, 'id'> = {
          type: 'number',
          x: pos.x,
          y: pos.y,
          number: getNextNumber(),
          radius: 16,
          fill: numberColor,
          textColor: '#ffffff',
          fontSize: 14,
          rotation: 0,
          draggable: true,
        };
        addAnnotation(numberAnnotation);
        return;
      }

      if (tool === 'freehand') {
        setState({
          isDrawing: true,
          startPos: pos,
          preview: {
            type: 'freehand',
            startX: pos.x,
            startY: pos.y,
            currentX: pos.x,
            currentY: pos.y,
            points: [pos.x, pos.y],
          },
          freehandPoints: [pos.x, pos.y],
          textInputPos: null,
        });
        return;
      }
      setState({
        isDrawing: true,
        startPos: pos,
        preview: {
          type: tool as PreviewShape['type'],
          startX: pos.x,
          startY: pos.y,
          currentX: pos.x,
          currentY: pos.y,
        },
        freehandPoints: [],
        textInputPos: null,
      });
    },
    [getPointerPosition, state.textInputPos]
  );

  const handleMouseMove = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      const tool = useAnnotationStore.getState().currentTool;
      if (!state.isDrawing || tool === 'select' || !tool) return;

      const pos = getPointerPosition(e);
      if (!pos) return;

      if (tool === 'freehand') {
        const newPoints = [...state.freehandPoints, pos.x, pos.y];
        setState((prev) => ({
          ...prev,
          freehandPoints: newPoints,
          preview: prev.preview
            ? {
                ...prev.preview,
                currentX: pos.x,
                currentY: pos.y,
                points: newPoints,
              }
            : null,
        }));
      } else {
        setState((prev) => ({
          ...prev,
          preview: prev.preview
            ? {
                ...prev.preview,
                currentX: pos.x,
                currentY: pos.y,
              }
            : null,
        }));
      }
    },
    [state.isDrawing, state.freehandPoints, getPointerPosition]
  );

  const handleMouseUp = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      const tool = useAnnotationStore.getState().currentTool;
      if (!state.isDrawing || tool === 'select' || !tool) {
        setState((prev) => ({ ...prev, isDrawing: false, preview: null }));
        return;
      }

      const pos = getPointerPosition(e);
      if (!pos) {
        setState((prev) => ({ ...prev, isDrawing: false, preview: null }));
        return;
      }

      const { startPos, freehandPoints } = state;

      if (tool === 'freehand') {
        const finalPoints = [...freehandPoints, pos.x, pos.y];
        if (finalPoints.length >= 4) {
          const freehandAnnotation: Omit<FreehandAnnotation, 'id'> = {
            type: 'freehand',
            x: 0,
            y: 0,
            points: finalPoints,
            stroke: strokeColor,
            strokeWidth,
            rotation: 0,
            draggable: true,
          };
          addAnnotation(freehandAnnotation);
        }
        setState((prev) => ({ ...prev, isDrawing: false, preview: null, freehandPoints: [] }));
        return;
      }

      const width = Math.abs(pos.x - startPos.x);
      const height = Math.abs(pos.y - startPos.y);
      const x = Math.min(startPos.x, pos.x);
      const y = Math.min(startPos.y, pos.y);

      // Ignore too small shapes
      const minSize = ANNOTATION_DEFAULTS.SHAPE.MIN_DRAW_SIZE;
      if (width < minSize && height < minSize) {
        setState((prev) => ({ ...prev, isDrawing: false, preview: null }));
        return;
      }

      switch (tool) {
        case 'rectangle': {
          const rectAnnotation: Omit<RectAnnotation, 'id'> = {
            type: 'rectangle',
            x,
            y,
            width,
            height,
            fill: fillColor,
            stroke: strokeColor,
            strokeWidth,
            rotation: 0,
            draggable: true,
          };
          addAnnotation(rectAnnotation);
          break;
        }

        case 'ellipse': {
          const ellipseAnnotation: Omit<EllipseAnnotation, 'id'> = {
            type: 'ellipse',
            x: x + width / 2,
            y: y + height / 2,
            radiusX: width / 2,
            radiusY: height / 2,
            fill: fillColor,
            stroke: strokeColor,
            strokeWidth,
            rotation: 0,
            draggable: true,
          };
          addAnnotation(ellipseAnnotation);
          break;
        }

        case 'line':
        case 'arrow': {
          const lineAnnotation: Omit<LineAnnotation, 'id'> = {
            type: tool,
            x: 0,
            y: 0,
            points: [startPos.x, startPos.y, pos.x, pos.y],
            stroke: strokeColor,
            strokeWidth,
            pointerLength: ANNOTATION_DEFAULTS.ARROW.POINTER_LENGTH,
            pointerWidth: ANNOTATION_DEFAULTS.ARROW.POINTER_WIDTH,
            rotation: 0,
            draggable: true,
          };
          addAnnotation(lineAnnotation);
          break;
        }

        case 'spotlight': {
          const spotlightAnnotation: Omit<SpotlightAnnotation, 'id'> = {
            type: 'spotlight',
            x,
            y,
            width,
            height,
            shape: 'rectangle',
            rotation: 0,
            draggable: true,
          };
          addAnnotation(spotlightAnnotation);
          break;
        }
      }

      setState((prev) => ({ ...prev, isDrawing: false, preview: null }));
    },
    [
      state.isDrawing,
      state.startPos,
      state.freehandPoints,
      getPointerPosition,
      addAnnotation,
      fillColor,
      strokeColor,
      strokeWidth,
    ]
  );

  const handleStageClick = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      // Deselect when clicking on empty area in select mode
      const tool = useAnnotationStore.getState().currentTool;
      if (tool === 'select') {
        const clickedOnEmpty = e.target === e.target.getStage();
        if (clickedOnEmpty) {
          useAnnotationStore.getState().setSelected(null);
        }
      }
    },
    []
  );

  // Submit text from input
  const submitText = useCallback(
    (text: string) => {
      if (!state.textInputPos) return;
      const trimmed = text.trim();
      if (trimmed) {
        const textAnnotation: Omit<TextAnnotation, 'id'> = {
          type: 'text',
          x: state.textInputPos.x,
          y: state.textInputPos.y,
          text: trimmed,
          fontSize,
          fontFamily,
          fill: strokeColor,
          rotation: 0,
          draggable: true,
        };
        addAnnotation(textAnnotation);
        setTool('select');
      }
      setState((prev) => ({ ...prev, textInputPos: null }));
    },
    [state.textInputPos, addAnnotation, fontSize, fontFamily, strokeColor, setTool]
  );

  const cancelTextInput = useCallback(() => {
    setState((prev) => ({ ...prev, textInputPos: null }));
    setTool('select');
  }, [setTool]);

  return {
    isDrawing: state.isDrawing,
    preview: state.preview,
    textInputPos: state.textInputPos,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handleStageClick,
    submitText,
    cancelTextInput,
  };
}
</file>

<file path="src/stores/canvas-store.ts">
// Canvas store - Zustand state management for canvas editor
// Single source of truth for image data and URL lifecycle

import { create } from 'zustand';
import type Konva from 'konva';
import { ZOOM } from '../constants/canvas';
import { useAnnotationStore } from './annotation-store';
import { useBackgroundStore } from './background-store';
import { useExportStore } from './export-store';
import { calculateAspectRatioExtend } from '../utils/export-utils';
import type { ImageSnapshot } from './history-store';

interface CropRect {
  x: number;
  y: number;
  width: number;
  height: number;
}

interface CanvasState {
  // Stage ref for export
  stageRef: React.RefObject<Konva.Stage | null> | null;
  // Image data
  imageUrl: string | null;
  imageBytes: Uint8Array | null;
  originalWidth: number;
  originalHeight: number;

  // Canvas viewport
  stageWidth: number;
  stageHeight: number;
  scale: number;
  position: { x: number; y: number };

  // Actions
  setStageRef: (ref: React.RefObject<Konva.Stage | null>) => void;
  setImageFromBytes: (bytes: Uint8Array, width: number, height: number) => void;
  setStageSize: (width: number, height: number) => void;
  setScale: (scale: number) => void;
  setPosition: (x: number, y: number) => void;
  resetView: () => void;
  fitToView: () => void;
  clearCanvas: () => void;
  cropImage: (rect: CropRect) => Promise<void>;
  restoreFromSnapshot: (snapshot: ImageSnapshot) => void;
  getImageSnapshot: () => ImageSnapshot;
  initHistoryCallbacks: () => void;
}

// Helper: Create blob URL from bytes
function bytesToUrl(bytes: Uint8Array): string {
  const blob = new Blob([bytes.buffer], { type: 'image/png' });
  return URL.createObjectURL(blob);
}

// Track URLs pending revocation (deferred to avoid race conditions)
const pendingRevocations = new Set<string>();

// Safely revoke URL after a delay to ensure no component is using it
function safeRevokeURL(url: string | null) {
  if (!url) return;

  // Add to pending set to prevent double revocation
  if (pendingRevocations.has(url)) return;
  pendingRevocations.add(url);

  // Delay revocation to allow React to finish rendering with new URL
  setTimeout(() => {
    URL.revokeObjectURL(url);
    pendingRevocations.delete(url);
  }, 100);
}

export const useCanvasStore = create<CanvasState>((set, get) => ({
  stageRef: null,
  imageUrl: null,
  imageBytes: null,
  originalWidth: 0,
  originalHeight: 0,
  stageWidth: 800,
  stageHeight: 600,
  scale: 1,
  position: { x: 0, y: 0 },

  setStageRef: (ref) => set({ stageRef: ref }),

  setImageFromBytes: (bytes, width, height) => {
    const oldUrl = get().imageUrl;
    const url = bytesToUrl(bytes);

    // Clear annotations from previous screenshot
    useAnnotationStore.getState().clearAnnotations();

    // Set new state first, then safely revoke old URL
    set({
      imageUrl: url,
      imageBytes: bytes,
      originalWidth: width,
      originalHeight: height,
    });

    // Revoke old URL after state update to prevent race condition
    safeRevokeURL(oldUrl);
  },

  setStageSize: (width, height) => set({ stageWidth: width, stageHeight: height }),

  setScale: (newScale) => {
    const { stageWidth, stageHeight, scale: oldScale, position } = get();

    // Clamp the new scale
    const clampedScale = Math.max(ZOOM.MIN_SCALE, Math.min(ZOOM.MAX_SCALE, newScale));

    // Calculate canvas center as the zoom anchor point
    const centerX = stageWidth / 2;
    const centerY = stageHeight / 2;

    // Calculate the canvas point that is currently at the center
    const canvasPointX = (centerX - position.x) / oldScale;
    const canvasPointY = (centerY - position.y) / oldScale;

    // Calculate new position so that the same canvas point stays at center
    const newX = centerX - canvasPointX * clampedScale;
    const newY = centerY - canvasPointY * clampedScale;

    set({
      scale: clampedScale,
      position: { x: newX, y: newY }
    });
  },

  setPosition: (x, y) => set({ position: { x, y } }),

  resetView: () => set({ scale: 1, position: { x: 0, y: 0 } }),

  fitToView: () => {
    const { originalWidth, originalHeight, stageWidth, stageHeight, stageRef } = get();
    if (!originalWidth || !originalHeight || !stageWidth || !stageHeight) return;

    // Get padding from background store (percentage-based)
    const bgPadding = useBackgroundStore.getState().getPaddingPx(originalWidth, originalHeight);

    // Base canvas size (image + padding)
    const baseWidth = originalWidth + bgPadding * 2;
    const baseHeight = originalHeight + bgPadding * 2;

    // Check for aspect ratio extension
    const outputAspectRatio = useExportStore.getState().outputAspectRatio;
    const aspectExtension = calculateAspectRatioExtend(baseWidth, baseHeight, outputAspectRatio);

    // Total canvas size including aspect ratio extension
    const totalWidth = aspectExtension?.width || baseWidth;
    const totalHeight = aspectExtension?.height || baseHeight;

    // Add some margin from stage edges
    const margin = 20;
    const availableWidth = stageWidth - margin * 2;
    const availableHeight = stageHeight - margin * 2;

    // Calculate scale to fit
    const scaleX = availableWidth / totalWidth;
    const scaleY = availableHeight / totalHeight;
    const newScale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 100%

    // Center the image
    const scaledWidth = totalWidth * newScale;
    const scaledHeight = totalHeight * newScale;
    const newX = (stageWidth - scaledWidth) / 2;
    const newY = (stageHeight - scaledHeight) / 2;

    // Also sync stage position directly via Konva API (in case it was dragged)
    const stage = stageRef?.current;
    if (stage) {
      stage.position({ x: newX, y: newY });
      stage.scale({ x: newScale, y: newScale });
      stage.draggable(false); // Reset draggable state
    }

    set({
      scale: Math.max(ZOOM.MIN_SCALE, Math.min(ZOOM.MAX_SCALE, newScale)),
      position: { x: newX, y: newY },
    });
  },

  clearCanvas: () => {
    const oldUrl = get().imageUrl;

    // Clear state first, then safely revoke old URL
    set({
      imageUrl: null,
      imageBytes: null,
      originalWidth: 0,
      originalHeight: 0,
    });

    safeRevokeURL(oldUrl);
  },

  cropImage: async (rect: CropRect) => {
    const { imageUrl, imageBytes, originalWidth, originalHeight } = get();
    if (!imageUrl) return;

    // Save current state to history before cropping (includes image data)
    useAnnotationStore.getState().saveToHistory({
      imageBytes: imageBytes ? new Uint8Array(imageBytes) : null,
      originalWidth,
      originalHeight,
    });

    // Load current image
    const img = new Image();
    img.crossOrigin = 'anonymous';

    await new Promise<void>((resolve, reject) => {
      img.onload = () => resolve();
      img.onerror = () => reject(new Error('Failed to load image for cropping'));
      img.src = imageUrl;
    });

    // Create canvas and crop
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(rect.width);
    canvas.height = Math.round(rect.height);
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Draw cropped region
    ctx.drawImage(
      img,
      Math.round(rect.x),
      Math.round(rect.y),
      Math.round(rect.width),
      Math.round(rect.height),
      0,
      0,
      Math.round(rect.width),
      Math.round(rect.height)
    );

    // Convert to blob and bytes
    const blob = await new Promise<Blob | null>((resolve) =>
      canvas.toBlob(resolve, 'image/png')
    );
    if (!blob) return;

    const bytes = new Uint8Array(await blob.arrayBuffer());

    // Get current URL at this point (may have changed during async ops)
    const currentUrl = get().imageUrl;
    const newUrl = bytesToUrl(bytes);

    // Update state first, then safely revoke
    set({
      imageUrl: newUrl,
      imageBytes: bytes,
      originalWidth: Math.round(rect.width),
      originalHeight: Math.round(rect.height),
    });

    // Safely revoke the URL that was current before this update
    safeRevokeURL(currentUrl);
  },

  restoreFromSnapshot: (snapshot: ImageSnapshot) => {
    const oldUrl = get().imageUrl;

    if (snapshot.imageBytes) {
      const newUrl = bytesToUrl(new Uint8Array(snapshot.imageBytes));
      // Set new state first
      set({
        imageUrl: newUrl,
        imageBytes: new Uint8Array(snapshot.imageBytes),
        originalWidth: snapshot.originalWidth,
        originalHeight: snapshot.originalHeight,
      });
    } else {
      // Restoring to empty state
      set({
        imageUrl: null,
        imageBytes: null,
        originalWidth: 0,
        originalHeight: 0,
      });
    }

    // Safely revoke old URL after state update
    safeRevokeURL(oldUrl);
  },

  getImageSnapshot: () => {
    const { imageBytes, originalWidth, originalHeight } = get();
    return {
      imageBytes: imageBytes ? new Uint8Array(imageBytes) : null,
      originalWidth,
      originalHeight,
    };
  },

  initHistoryCallbacks: () => {
    const store = get();
    useAnnotationStore.getState().setRestoreImageCallback(store.restoreFromSnapshot);
    useAnnotationStore.getState().setGetImageSnapshotCallback(store.getImageSnapshot);
  },
}));
</file>

<file path="package.json">
{
  "name": "beautyfullshot",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "dependencies": {
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-clipboard-manager": "^2.3.2",
    "@tauri-apps/plugin-dialog": "^2.4.2",
    "@tauri-apps/plugin-global-shortcut": "^2",
    "@tauri-apps/plugin-notification": "^2",
    "@tauri-apps/plugin-opener": "^2",
    "@tauri-apps/plugin-process": "^2.3.1",
    "konva": "^9.3.0",
    "nanoid": "^5.1.6",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-konva": "^18.2.10",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4",
    "@tauri-apps/cli": "^2",
    "@testing-library/react": "^16.3.1",
    "@testing-library/user-event": "^14.6.1",
    "@types/react": "^18.3.27",
    "@types/react-dom": "^18.3.7",
    "@vitejs/plugin-react": "^4.6.0",
    "@vitest/coverage-v8": "^4.0.16",
    "@vitest/ui": "^4.0.16",
    "jsdom": "^27.4.0",
    "playwright": "^1.57.0",
    "tailwindcss": "^4",
    "typescript": "~5.8.3",
    "vite": "^7.0.4",
    "vitest": "^4.0.16"
  }
}
</file>

<file path="src/hooks/use-export.ts">
// Export hook - handles all export operations for Konva stage

import { useCallback } from 'react';
import { sendNotification } from '@tauri-apps/plugin-notification';
import { invoke } from '@tauri-apps/api/core';
import { useExportStore } from '../stores/export-store';
import { toast } from '../stores/toast-store';
import { useCanvasStore } from '../stores/canvas-store';
import { useBackgroundStore } from '../stores/background-store';
import { useSettingsStore } from '../stores/settings-store';
import {
  stageToDataURL,
  dataURLToBytes,
  generateFilename,
  calculateAspectRatioExtend,
  ExportError,
} from '../utils/export-utils';
import {
  saveFile,
  getPicturesDir,
  getDesktopDir,
  showSaveDialog,
  normalizePath,
  extractFilename,
} from '../utils/file-api';
import { logError } from '../utils/logger';
import { useCropStore } from '../stores/crop-store';

export function useExport() {
  const {
    format,
    quality,
    pixelRatio,
    outputAspectRatio,
    isExporting,
    exportOperation,
    setLastSavePath,
    startExport,
    finishExport,
  } = useExportStore();
  const { cropRect } = useCropStore();
  const { stageRef, originalWidth, originalHeight } = useCanvasStore();
  const { getPaddingPx } = useBackgroundStore();
  const { showNotifications, saveLocation, customSavePath } = useSettingsStore();

  /**
   * Send notification if enabled in settings
   */
  const notify = useCallback(
    async (title: string, body: string) => {
      if (showNotifications) {
        await sendNotification({ title, body });
      }
    },
    [showNotifications]
  );

  /**
   * Show in-app toast notification for saved files with "Show in Folder" action
   */
  const notifyFileSaved = useCallback(
    (title: string, body: string, filePath: string) => {
      // Show in-app toast with action button (replaces system notification)
      toast.success(title, body, filePath);
    },
    []
  );

  /**
   * Export stage to data URL string
   * Note: Aspect ratio is applied via canvas extension, not export-time cropping
   */
  const exportToDataURL = useCallback(() => {
    if (!stageRef?.current) return null;

    // Calculate canvas dimensions (image + padding + aspect ratio extension)
    let canvasWidth: number | undefined;
    let canvasHeight: number | undefined;

    if (originalWidth > 0 && originalHeight > 0) {
      const padding = getPaddingPx(originalWidth, originalHeight);
      const baseWidth = originalWidth + padding * 2;
      const baseHeight = originalHeight + padding * 2;

      // Check for aspect ratio extension
      const aspectExtension = calculateAspectRatioExtend(baseWidth, baseHeight, outputAspectRatio);
      canvasWidth = aspectExtension?.width || baseWidth;
      canvasHeight = aspectExtension?.height || baseHeight;
    }

    return stageToDataURL(stageRef.current, {
      format,
      quality,
      pixelRatio,
      cropRect: null,
      canvasWidth,
      canvasHeight,
    });
  }, [stageRef, format, quality, pixelRatio, cropRect, originalWidth, originalHeight, getPaddingPx, outputAspectRatio]);

  /**
   * Get user-friendly error message
   */
  const getErrorMessage = (e: unknown): string => {
    if (e instanceof ExportError) {
      switch (e.code) {
        case 'INVALID_INPUT':
          return 'No image to export';
        case 'DECODE_ERROR':
          return 'Failed to process image data';
        default:
          return e.message;
      }
    }
    if (e instanceof Error) {
      // Check for file size limit error from Rust
      if (e.message.includes('exceeds maximum')) {
        return 'Image is too large to export. Try reducing resolution.';
      }
      return e.message;
    }
    return 'An unexpected error occurred';
  };

  /**
   * Copy image to clipboard with loading state
   * Uses custom Rust command with arboard for reliable clipboard access on macOS
   */
  const copyToClipboard = useCallback(async () => {
    if (isExporting) return false;

    startExport('clipboard');
    const dataURL = exportToDataURL();
    if (!dataURL) {
      finishExport();
      await notify('Copy Failed', 'No image to copy. Take a screenshot first.');
      return false;
    }

    try {
      // Convert data URL to base64 (remove data:image/png;base64, prefix)
      const base64Data = dataURL.split(',')[1];

      // Use custom Rust command with arboard crate for reliable clipboard
      await invoke('copy_image_to_clipboard', { base64Data });

      // Show in-app toast notification
      toast.success('Copied!', 'Image copied to clipboard');

      // Also send system notification if enabled
      await notify('Copied!', 'Image copied to clipboard');

      return true;
    } catch (e) {
      logError('copyToClipboard', e);
      await notify('Copy Failed', 'Could not copy to clipboard.');
      return false;
    } finally {
      finishExport();
    }
  }, [isExporting, exportToDataURL, startExport, finishExport, notify]);

  /**
   * Get save directory based on settings
   */
  const getSaveDir = useCallback(async (): Promise<string> => {
    switch (saveLocation) {
      case 'desktop':
        return await getDesktopDir();
      case 'custom':
        if (customSavePath) {
          return customSavePath;
        }
        // Fallback to pictures if custom path not set
        return await getPicturesDir();
      case 'pictures':
      default:
        return await getPicturesDir();
    }
  }, [saveLocation, customSavePath]);

  /**
   * Quick save to configured folder with loading state
   */
  const quickSave = useCallback(async () => {
    if (isExporting) return null;

    startExport('quickSave');
    const dataURL = exportToDataURL();
    if (!dataURL) {
      finishExport();
      await notify('Save Failed', 'No image to save. Take a screenshot first.');
      return null;
    }

    try {
      const bytes = dataURLToBytes(dataURL);
      const saveDir = await getSaveDir();
      const filename = generateFilename(format);
      const fullPath = `${saveDir}/${filename}`;

      const savedPath = await saveFile(fullPath, bytes);
      // Normalize path for display (removes Windows \\?\ prefix)
      const displayPath = normalizePath(savedPath);
      setLastSavePath(displayPath);

      await notifyFileSaved('Saved!', `Image saved to ${filename}`, displayPath);

      return savedPath;
    } catch (e) {
      logError('quickSave', e);
      await notify('Save Failed', getErrorMessage(e));
      return null;
    } finally {
      finishExport();
    }
  }, [isExporting, exportToDataURL, format, setLastSavePath, startExport, finishExport, notify, notifyFileSaved, getSaveDir]);

  /**
   * Save with dialog for location selection with loading state
   */
  const saveAs = useCallback(async () => {
    if (isExporting) return null;

    startExport('saveAs');
    const dataURL = exportToDataURL();
    if (!dataURL) {
      finishExport();
      await notify('Save Failed', 'No image to save. Take a screenshot first.');
      return null;
    }

    try {
      const defaultName = generateFilename(format);
      const path = await showSaveDialog(defaultName, format);

      if (!path) {
        finishExport();
        return null; // User cancelled
      }

      const bytes = dataURLToBytes(dataURL);
      const savedPath = await saveFile(path, bytes);
      // Normalize path for display (removes Windows \\?\ prefix)
      const displayPath = normalizePath(savedPath);
      setLastSavePath(displayPath);

      // Extract filename for display message (handles cross-platform separators)
      const filename = extractFilename(savedPath);
      await notifyFileSaved('Saved!', `Image saved to ${filename}`, displayPath);

      return savedPath;
    } catch (e) {
      logError('saveAs', e);
      await notify('Save Failed', getErrorMessage(e));
      return null;
    } finally {
      finishExport();
    }
  }, [isExporting, exportToDataURL, format, setLastSavePath, startExport, finishExport, notify, notifyFileSaved]);

  return {
    exportToDataURL,
    copyToClipboard,
    quickSave,
    saveAs,
    isExporting,
    exportOperation,
  };
}
</file>

<file path="src-tauri/src/overlay.rs">
// Overlay window management for region selection
// Creates persistent overlay window at startup, shows/hides as needed

use base64::{engine::general_purpose::STANDARD, Engine};
use image::codecs::png::{CompressionType, FilterType, PngEncoder};
use image::ImageEncoder;
use std::sync::Mutex;
use std::thread;
use std::time::Duration;
use tauri::{AppHandle, Emitter, Manager, WebviewUrl, WebviewWindowBuilder};
use xcap::Monitor;

// Store screenshot data for overlay background
static OVERLAY_SCREENSHOT: Mutex<Option<String>> = Mutex::new(None);

/// Wait for Windows DWM animation to complete
/// Uses DwmFlush to sync with Desktop Window Manager composition cycles
#[cfg(target_os = "windows")]
fn wait_for_dwm_animation() {
    // Sync with multiple DWM composition cycles
    // Each DwmFlush waits for next VBlank (~16ms at 60Hz)
    // 10 cycles with 10ms sleep = ~260ms total, enough for most animations
    for _ in 0..10 {
        unsafe {
            let _ = windows::Win32::Graphics::Dwm::DwmFlush();
        }
        thread::sleep(Duration::from_millis(10));
    }
}

/// Capture screenshot and convert to base64 for overlay background
fn capture_for_overlay() -> Result<String, String> {
    let monitors = Monitor::all().map_err(|e| e.to_string())?;
    let primary = monitors
        .into_iter()
        .find(|m| m.is_primary().unwrap_or(false))
        .ok_or("No primary monitor found")?;

    let image = primary.capture_image().map_err(|e| e.to_string())?;

    let width = image.width();
    let height = image.height();

    // Verify we got a valid image
    if width == 0 || height == 0 {
        return Err("Screen recording permission not granted".to_string());
    }

    // Convert to PNG with fast compression
    let estimated_size = (width * height * 4) as usize + 1024;
    let mut bytes: Vec<u8> = Vec::with_capacity(estimated_size);
    let encoder =
        PngEncoder::new_with_quality(&mut bytes, CompressionType::Fast, FilterType::NoFilter);
    encoder
        .write_image(
            image.as_raw(),
            width,
            height,
            image::ExtendedColorType::Rgba8,
        )
        .map_err(|e| e.to_string())?;

    Ok(STANDARD.encode(&bytes))
}

/// Initialize overlay window at app startup (hidden)
/// Call this from setup() in lib.rs
/// Note: Currently unused - overlay created on-demand via create_overlay_window
#[allow(dead_code)]
pub fn init_overlay_window(app: &AppHandle) -> Result<(), Box<dyn std::error::Error>> {
    // Create overlay window using fullscreen mode to guarantee full coverage
    let _window = WebviewWindowBuilder::new(
        app,
        "region-overlay",
        WebviewUrl::App("overlay.html".into()),
    )
    .title("")
    .fullscreen(true)
    .decorations(false)
    .always_on_top(true)
    .skip_taskbar(true)
    .focused(false)
    .closable(true)
    .resizable(false)
    .visible(false) // Hidden at startup
    .build()?;

    Ok(())
}

/// Show overlay window for region selection
/// Creates overlay on-demand if not exists, captures screenshot, then shows
#[tauri::command]
pub async fn show_overlay_window(app: AppHandle) -> Result<(), String> {
    // Hide main window FIRST (so screenshot doesn't include app window)
    if let Some(main_window) = app.get_webview_window("main") {
        let _ = main_window.hide();
    }

    // Wait for window hide animation to complete
    #[cfg(target_os = "windows")]
    wait_for_dwm_animation();

    #[cfg(not(target_os = "windows"))]
    thread::sleep(Duration::from_millis(50));

    // Capture screenshot AFTER window is fully hidden
    let screenshot_base64 = capture_for_overlay()?;

    // Store screenshot for overlay to retrieve (recover from poisoned Mutex)
    {
        let mut data = OVERLAY_SCREENSHOT
            .lock()
            .unwrap_or_else(|poisoned| poisoned.into_inner());
        *data = Some(screenshot_base64);
    }

    // Get or create overlay window
    let window = match app.get_webview_window("region-overlay") {
        Some(w) => w,
        None => {
            // Create overlay window on-demand (invisible until frontend shows it)
            match WebviewWindowBuilder::new(
                &app,
                "region-overlay",
                WebviewUrl::App("overlay.html".into()),
            )
            .title("")
            .fullscreen(true)
            .decorations(false)
            .always_on_top(true)
            .skip_taskbar(true)
            .focused(false)
            .closable(true)
            .resizable(false)
            .visible(false) // Keep hidden until frontend loads screenshot
            .build()
            {
                Ok(w) => w,
                Err(e) => {
                    // Clear screenshot data on window creation failure to prevent memory leak
                    let mut data = OVERLAY_SCREENSHOT
                        .lock()
                        .unwrap_or_else(|poisoned| poisoned.into_inner());
                    *data = None;
                    return Err(format!("{}", e));
                }
            }
        }
    };

    // Ensure fullscreen mode is set (don't show yet - frontend will show after screenshot loads)
    let _ = window.set_fullscreen(true);

    // Notify overlay to load screenshot and show itself
    let _ = window.emit("overlay-activate", ());

    Ok(())
}

/// Hide overlay window (don't destroy, just hide)
#[tauri::command]
pub async fn hide_overlay_window(app: AppHandle) -> Result<(), String> {
    if let Some(window) = app.get_webview_window("region-overlay") {
        window.hide().map_err(|e| e.to_string())?;
    }
    Ok(())
}

/// Get the stored screenshot data for overlay background
#[tauri::command]
pub fn get_screenshot_data() -> Option<String> {
    let data = OVERLAY_SCREENSHOT
        .lock()
        .unwrap_or_else(|poisoned| poisoned.into_inner());
    data.clone()
}

/// Clear stored screenshot data
#[tauri::command]
pub fn clear_screenshot_data() {
    let mut data = OVERLAY_SCREENSHOT
        .lock()
        .unwrap_or_else(|poisoned| poisoned.into_inner());
    *data = None;
}

// Compatibility aliases
#[tauri::command]
pub async fn create_overlay_window(app: AppHandle) -> Result<(), String> {
    show_overlay_window(app).await
}

#[tauri::command]
pub async fn close_overlay_window(app: AppHandle) -> Result<(), String> {
    hide_overlay_window(app).await
}
</file>

<file path="src/components/sidebar/background-panel.tsx">
// BackgroundPanel - UI for selecting background with tabs: Wallpaper, Gradient, Color, Image

import { useState, useRef, useCallback, useEffect } from 'react';
import { GRADIENT_PRESETS, SOLID_COLORS } from '../../data/gradients';
import {
  WALLPAPER_CATEGORIES,
  WALLPAPER_PRESETS,
  getWallpapersByCategory,
  getRandomWallpaper,
  parseWallpaperUrl,
} from '../../data/wallpapers';
import { useBackgroundStore, BORDER_PRESET_COLORS } from '../../stores/background-store';
import { useCanvasStore } from '../../stores/canvas-store';
import { extractDominantColor } from '../../utils/color-extractor';
import { ColorPicker } from '../ui/color-picker';

// Tab type mapping
type TabType = 'wallpaper' | 'gradient' | 'color' | 'image';

// Icons
const BriefcaseIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
  </svg>
);

const SparklesIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
  </svg>
);

const ImageIcon = () => (
  <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
  </svg>
);

export function BackgroundPanel() {
  const {
    type,
    gradient,
    solidColor,
    wallpaper,
    customImageUrl,
    autoColor,
    blurAmount,
    shadowBlur,
    cornerRadius,
    paddingPercent,
    borderWidth,
    borderColor,
    borderOpacity,
    recentBorderColors,
    imageLibrary,
    setGradient,
    setSolidColor,
    setTransparent,
    setAuto,
    setAutoColor,
    setWallpaper,
    setCustomImage,
    clearCustomImage,
    setBlurAmount,
    setShadowBlur,
    setCornerRadius,
    setPaddingPercent,
    setBorderWidth,
    setBorderColor,
    setBorderOpacity,
    loadLibrary,
    selectFromLibrary,
    removeFromLibrary,
    clearLibrary,
  } = useBackgroundStore();

  useEffect(() => {
    loadLibrary();
  }, [loadLibrary]);

  const { imageUrl, fitToView } = useCanvasStore();
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Active tab state
  const [activeTab, setActiveTab] = useState<TabType>(() => {
    if (type === 'wallpaper') return 'wallpaper';
    if (type === 'gradient') return 'gradient';
    if (type === 'solid' || type === 'transparent') return 'color';
    if (type === 'image') return 'image';
    return 'wallpaper';
  });

  // Active wallpaper category
  const [activeCategory, setActiveCategory] = useState('professional');

  // Color picker modal state
  const [showColorModal, setShowColorModal] = useState(false);

  // Close color picker and save to recent colors
  const closeColorPicker = useCallback(() => {
    // Save current color to recent when closing
    if (borderColor && /^#[0-9A-Fa-f]{6}$/.test(borderColor)) {
      setBorderColor(borderColor, true);
    }
    setShowColorModal(false);
  }, [borderColor, setBorderColor]);

  // Auto-extract dominant color when image changes
  useEffect(() => {
    if (imageUrl) {
      extractDominantColor(imageUrl)
        .then((color) => {
          setAutoColor(color);
        })
        .catch(() => {
          setAutoColor('#808080'); // Fallback gray
        });
    }
  }, [imageUrl, setAutoColor]);

  // Handle tab change
  const handleTabChange = (tab: TabType) => {
    setActiveTab(tab);
  };

  // Update padding and re-fit view
  const handlePaddingChange = (percent: number) => {
    setPaddingPercent(percent);
    fitToView();
  };

  // Handle file upload
  const handleFileUpload = useCallback((file: File) => {
    if (!file.type.startsWith('image/')) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const result = e.target?.result;
      if (result && typeof result === 'string') {
        // Create blob URL for display
        const blob = new Blob([file], { type: file.type });
        const url = URL.createObjectURL(blob);

        // Read as bytes for persistence
        const arrayReader = new FileReader();
        arrayReader.onload = (ae) => {
          const bytes = ae.target?.result;
          if (bytes instanceof ArrayBuffer) {
            setCustomImage(url, new Uint8Array(bytes));
          }
        };
        arrayReader.readAsArrayBuffer(file);
      }
    };
    reader.readAsDataURL(file);
  }, [setCustomImage]);

  // Handle file input change
  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileUpload(file);
    }
  };

  // Handle drag and drop
  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) {
      handleFileUpload(file);
    }
  }, [handleFileUpload]);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
  };


  // Pick random wallpaper
  const handleRandomWallpaper = () => {
    const random = getRandomWallpaper();
    setWallpaper(random);
  };

  // Get wallpaper thumbnail style
  const getWallpaperStyle = (wp: typeof WALLPAPER_PRESETS[0]) => {
    if (wp.thumbnailUrl) {
      return {
        backgroundImage: `url(${wp.thumbnailUrl})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
      };
    }
    const parsed = parseWallpaperUrl(wp.url);
    if (parsed.type === 'gradient') {
      return { background: parsed.value };
    }
    return { background: `linear-gradient(135deg, ${wp.colors.join(', ')})` };
  };

  const tabs: { id: TabType; label: string }[] = [
    { id: 'wallpaper', label: 'Wallpaper' },
    { id: 'gradient', label: 'Gradient' },
    { id: 'color', label: 'Color' },
    { id: 'image', label: 'Image' },
  ];

  return (
    <div className="p-3 glass-flat rounded-xl mb-2">
      <h3 className="font-medium mb-3 text-gray-800 dark:text-gray-200">Background</h3>

      {/* Tab buttons */}
      <div className="flex gap-1 mb-4 glass-flat rounded-xl p-1">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabChange(tab.id)}
            className={`flex-1 py-1.5 px-2 rounded-lg text-xs font-medium transition-all ${activeTab === tab.id
              ? 'glass-btn glass-btn-active text-orange-500'
              : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Wallpaper Tab */}
      {activeTab === 'wallpaper' && (
        <div className="space-y-3">
          {/* Category tabs */}
          <div className="flex gap-1 overflow-x-auto pb-1">
            {WALLPAPER_CATEGORIES.map((category) => (
              <button
                key={category.id}
                onClick={() => setActiveCategory(category.id)}
                className={`flex items-center gap-1 px-3 py-1.5 rounded-full text-xs whitespace-nowrap transition-colors ${activeCategory === category.id
                  ? 'bg-gray-700 text-white dark:bg-gray-600'
                  : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700'
                  }`}
              >
                {category.id === 'professional' && <BriefcaseIcon />}
                {category.name}
              </button>
            ))}
          </div>

          {/* Random wallpaper button */}
          <button
            onClick={handleRandomWallpaper}
            className="w-full flex items-center justify-center gap-2 py-2 px-4 rounded-lg bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
          >
            <SparklesIcon />
            <span className="text-sm">Pick random wallpaper</span>
          </button>

          {/* Wallpaper grid */}
          <div className="grid grid-cols-4 gap-2">
            {getWallpapersByCategory(activeCategory).map((wp) => (
              <button
                key={wp.id}
                onClick={() => setWallpaper(wp)}
                className={`aspect-square rounded-lg overflow-hidden transition-all cursor-pointer ${type === 'wallpaper' && wallpaper?.id === wp.id
                  ? 'ring-2 ring-orange-500 ring-offset-1 dark:ring-offset-gray-900'
                  : 'hover:ring-1 hover:ring-gray-300 dark:hover:ring-gray-600 hover:scale-105'
                  }`}
                style={getWallpaperStyle(wp)}
                title={wp.name}
              />
            ))}
          </div>
        </div>
      )}

      {/* Gradient Tab */}
      {activeTab === 'gradient' && (
        <div className="grid grid-cols-6 gap-2">
          {GRADIENT_PRESETS.map((preset) => (
            <button
              key={preset.id}
              onClick={() => setGradient(preset)}
              className={`w-8 h-8 rounded transition-all cursor-pointer ${type === 'gradient' && gradient?.id === preset.id
                ? 'ring-2 ring-orange-500 ring-offset-1 dark:ring-offset-gray-900'
                : 'hover:ring-1 hover:ring-gray-300 dark:hover:ring-gray-600 hover:scale-110'
                }`}
              style={{
                background: `linear-gradient(${preset.angle || 135}deg, ${preset.colors.join(', ')})`,
              }}
              title={preset.name}
            />
          ))}
        </div>
      )}

      {/* Color Tab */}
      {activeTab === 'color' && (
        <div className="space-y-3">
          {/* Auto color option */}
          <div>
            <p className="text-xs text-gray-500 dark:text-gray-400 mb-2">Auto (from screenshot)</p>
            <button
              onClick={setAuto}
              className={`w-full flex items-center gap-3 p-2 rounded-lg border transition-all cursor-pointer ${type === 'auto'
                ? 'border-orange-500 bg-orange-50 dark:bg-orange-900/20 ring-2 ring-orange-500'
                : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500'
                }`}
              title="Auto color from screenshot"
            >
              <div
                className="w-8 h-8 rounded border border-gray-300 dark:border-gray-600"
                style={{ background: autoColor || '#808080' }}
              />
              <div className="text-left">
                <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Auto</span>
                <p className="text-xs text-gray-500 dark:text-gray-400">
                  {autoColor || 'Calculating...'}
                </p>
              </div>
            </button>
          </div>

          <p className="text-xs text-gray-500 dark:text-gray-400">Solid Colors</p>
          <div className="flex flex-wrap gap-2">
            {SOLID_COLORS.map((c) => (
              <button
                key={c.id}
                onClick={() => setSolidColor(c.color)}
                className={`w-8 h-8 rounded border border-gray-300 dark:border-gray-600 transition-all cursor-pointer ${type === 'solid' && solidColor === c.color
                  ? 'ring-2 ring-orange-500 ring-offset-1 dark:ring-offset-gray-900'
                  : 'hover:ring-1 hover:ring-gray-300 dark:hover:ring-gray-600 hover:scale-110'
                  }`}
                style={{ background: c.color }}
                title={c.name}
              />
            ))}
            <button
              onClick={setTransparent}
              className={`w-8 h-8 rounded border border-gray-300 dark:border-gray-600 transition-all cursor-pointer ${type === 'transparent'
                ? 'ring-2 ring-orange-500 ring-offset-1 dark:ring-offset-gray-900'
                : 'hover:ring-1 hover:ring-gray-300 dark:hover:ring-gray-600 hover:scale-110'
                }`}
              style={{
                background: 'repeating-linear-gradient(45deg, #ccc, #ccc 3px, #fff 3px, #fff 6px)',
              }}
              title="Transparent"
            />
          </div>

          {/* Custom color picker */}
          <div className="flex items-center gap-2">
            <input
              type="color"
              value={solidColor}
              onChange={(e) => setSolidColor(e.target.value)}
              className="w-8 h-8 rounded border border-gray-300 dark:border-gray-600 cursor-pointer"
            />
            <span className="text-xs text-gray-500 dark:text-gray-400">Custom color</span>
          </div>
        </div>
      )}

      {/* Image Tab */}
      {activeTab === 'image' && (
        <div className="space-y-3">
          <p className="text-xs text-gray-500 dark:text-gray-400">Background Image</p>

          {/* Upload area */}
          <div
            onClick={() => fileInputRef.current?.click()}
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            className={`border-2 border-dashed rounded-lg p-4 text-center cursor-pointer transition-colors ${type === 'image' && customImageUrl
              ? 'border-orange-500 bg-orange-50 dark:bg-orange-900/20'
              : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500'
              }`}
          >
            {type === 'image' && customImageUrl ? (
              <div className="space-y-2">
                <div
                  className="w-full h-12 rounded bg-cover bg-center"
                  style={{ backgroundImage: `url(${customImageUrl})` }}
                />
                <p className="text-xs text-gray-500 dark:text-gray-400">
                  Click to change image
                </p>
              </div>
            ) : (
              <>
                <ImageIcon />
                <p className="text-xs text-gray-500 dark:text-gray-400 mt-2">
                  Click to select or drop image
                </p>
              </>
            )}
          </div>

          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            onChange={handleFileInputChange}
            className="hidden"
          />

          {/* Clear image button */}
          {type === 'image' && customImageUrl && (
            <button
              onClick={clearCustomImage}
              className="w-full py-1.5 text-xs text-red-500 hover:text-red-600 transition-colors"
            >
              Remove background image
            </button>
          )}

          {/* Image Library */}
          {imageLibrary.length > 0 && (
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <p className="text-xs text-gray-500 dark:text-gray-400">Recent Images</p>
                <button
                  onClick={clearLibrary}
                  className="text-xs text-gray-400 hover:text-red-500 transition-colors"
                >
                  Clear all
                </button>
              </div>
              <div className="grid grid-cols-4 gap-2">
                {imageLibrary.map((img) => (
                  <div key={img.id} className="relative group">
                    <button
                      onClick={() => selectFromLibrary(img.id)}
                      className="w-full aspect-square rounded-lg overflow-hidden bg-cover bg-center border border-gray-200 dark:border-gray-700 hover:border-orange-500 transition-colors cursor-pointer"
                      style={{ backgroundImage: `url(${img.thumbnail})` }}
                    />
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        removeFromLibrary(img.id);
                      }}
                      className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center"
                      title="Remove"
                    >
                      ×
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Compact sliders row - 2x2 grid */}
      <div className="mt-3 pt-3 border-t border-white/10 dark:border-white/5 grid grid-cols-2 gap-3">
        {/* Blur */}
        <div>
          <label className="text-xs text-gray-500 dark:text-gray-400 flex justify-between mb-1">
            <span>Blur</span>
            <span className="text-gray-600 dark:text-gray-300">{blurAmount}</span>
          </label>
          <input
            type="range"
            min="0"
            max="100"
            value={blurAmount}
            onChange={(e) => setBlurAmount(Number(e.target.value))}
            className="w-full cursor-pointer"
          />
        </div>

        {/* Shadow */}
        <div>
          <label className="text-xs text-gray-500 dark:text-gray-400 flex justify-between mb-1">
            <span>Shadow</span>
            <span className="text-gray-600 dark:text-gray-300">{shadowBlur}</span>
          </label>
          <input
            type="range"
            min="0"
            max="500"
            value={shadowBlur}
            onChange={(e) => setShadowBlur(Number(e.target.value))}
            className="w-full cursor-pointer"
          />
        </div>

        {/* Radius */}
        <div>
          <label className="text-xs text-gray-500 dark:text-gray-400 flex justify-between mb-1">
            <span>Radius</span>
            <span className="text-gray-600 dark:text-gray-300">{cornerRadius}</span>
          </label>
          <input
            type="range"
            min="0"
            max="100"
            value={cornerRadius}
            onChange={(e) => setCornerRadius(Number(e.target.value))}
            className="w-full cursor-pointer"
          />
        </div>

        {/* Padding */}
        <div>
          <label className="text-xs text-gray-500 dark:text-gray-400 flex justify-between mb-1">
            <span>Padding</span>
            <span className="text-gray-600 dark:text-gray-300">{paddingPercent}%</span>
          </label>
          <input
            type="range"
            min="0"
            max="50"
            value={paddingPercent}
            onChange={(e) => handlePaddingChange(Number(e.target.value))}
            className="w-full cursor-pointer"
          />
        </div>
      </div>

      {/* Border section - compact */}
      <div className="mt-3 pt-3 border-t border-white/10 dark:border-white/5">
        <div className="flex items-center justify-between mb-2">
          <p className="text-xs text-gray-500 dark:text-gray-400">Border</p>
          {/* Color button - opens popover */}
          <div className="relative">
            <button
              onClick={() => setShowColorModal(!showColorModal)}
              className="w-6 h-6 rounded border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-105"
              style={{ backgroundColor: borderColor }}
              title="Pick border color"
            />
            {/* Color Picker Popover */}
            {showColorModal && (
              <>
                <div className="fixed inset-0 z-40" onClick={closeColorPicker} />
                <div className="absolute right-0 bottom-full mb-2 glass-heavy floating-panel w-[240px] p-3 space-y-3 z-50">
                  <ColorPicker color={borderColor} onChange={(c) => setBorderColor(c)} />
                  <div>
                    <p className="text-xs text-gray-500 dark:text-gray-400 mb-1.5">Preset</p>
                    <div className="flex flex-wrap gap-1.5">
                      {BORDER_PRESET_COLORS.map((color) => (
                        <button
                          key={color}
                          onClick={() => setBorderColor(color, true)}
                          className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 cursor-pointer ${
                            borderColor.toLowerCase() === color.toLowerCase()
                              ? 'border-orange-500'
                              : 'border-gray-300 dark:border-gray-600'
                          }`}
                          style={{ backgroundColor: color }}
                          title={color}
                        />
                      ))}
                    </div>
                  </div>
                  {recentBorderColors.length > 0 && (
                    <div>
                      <p className="text-xs text-gray-500 dark:text-gray-400 mb-1.5">Recent</p>
                      <div className="flex flex-wrap gap-1.5">
                        {recentBorderColors.map((color, index) => (
                          <button
                            key={`${color}-${index}`}
                            onClick={() => setBorderColor(color)}
                            className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 cursor-pointer ${
                              borderColor.toLowerCase() === color.toLowerCase()
                                ? 'border-orange-500'
                                : 'border-gray-300 dark:border-gray-600'
                            }`}
                            style={{ backgroundColor: color }}
                            title={color}
                          />
                        ))}
                      </div>
                    </div>
                  )}
                  <div className="mt-3 flex justify-end">
                    <button
                      onClick={closeColorPicker}
                      className="px-4 py-1.5 bg-orange-500 hover:bg-orange-600 text-white text-sm font-medium rounded-lg transition-colors cursor-pointer"
                    >
                      OK
                    </button>
                  </div>
                </div>
              </>
            )}
          </div>
        </div>

        {/* Border width & opacity in 2 columns */}
        <div className="grid grid-cols-2 gap-3">
          <div>
            <label className="text-xs text-gray-500 dark:text-gray-400 flex justify-between mb-1">
              <span>Width</span>
              <span className="text-gray-600 dark:text-gray-300">{borderWidth}</span>
            </label>
            <input
              type="range"
              min="0"
              max="50"
              value={borderWidth}
              onChange={(e) => setBorderWidth(Number(e.target.value))}
              className="w-full cursor-pointer"
            />
          </div>
          <div>
            <label className="text-xs text-gray-500 dark:text-gray-400 flex justify-between mb-1">
              <span>Opacity</span>
              <span className="text-gray-600 dark:text-gray-300">{borderOpacity}%</span>
            </label>
            <input
              type="range"
              min="0"
              max="100"
              value={borderOpacity}
              onChange={(e) => setBorderOpacity(Number(e.target.value))}
              className="w-full cursor-pointer"
            />
          </div>
        </div>
      </div>

    </div>
  );
}
</file>

<file path="src/components/toolbar/tool-buttons.tsx">
// ToolButtons - Annotation tool selection buttons with Draw dropdown

import { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { useAnnotationStore } from '../../stores/annotation-store';
import type { ToolType } from '../../types/annotations';

interface Tool {
  type: ToolType;
  icon: React.ReactNode;
  label: string;
}

// SVG Icons for consistent styling
const SelectIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
    <path d="M4 4l7.07 17 2.51-7.39L21 11.07 4 4z" />
  </svg>
);

const RectangleIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
    <rect x="4" y="4" width="16" height="16" rx="1" />
  </svg>
);

const EllipseIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
    <ellipse cx="12" cy="12" rx="9" ry="9" />
  </svg>
);

const LineIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
    <line x1="5" y1="19" x2="19" y2="5" />
  </svg>
);

const ArrowIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <line x1="5" y1="12" x2="19" y2="12" />
    <polyline points="14 7 19 12 14 17" />
  </svg>
);

const TextIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
    <path d="M5 5v3h5.5v12h3V8H19V5H5z" />
  </svg>
);

const NumberIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <circle cx="12" cy="12" r="9" />
    <text x="12" y="16" textAnchor="middle" fontSize="10" fill="currentColor" stroke="none">1</text>
  </svg>
);

const FreehandIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <path d="M12 19l7-7 3 3-7 7-3-3z" />
    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
    <path d="M2 2l7.586 7.586" />
  </svg>
);

const SpotlightIcon = () => (
  <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
    <circle cx="12" cy="12" r="9" />
    <path d="M12 3a9 9 0 0 0 0 18" fill="currentColor" stroke="none" />
  </svg>
);

// Chevron down icon for dropdown
const ChevronDownIcon = () => (
  <svg className="w-3 h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <polyline points="6 9 12 15 18 9" />
  </svg>
);

// Draw tools grouped in dropdown
const DRAW_TOOLS: Tool[] = [
  { type: 'rectangle', icon: <RectangleIcon />, label: 'Rectangle' },
  { type: 'ellipse', icon: <EllipseIcon />, label: 'Ellipse' },
  { type: 'line', icon: <LineIcon />, label: 'Line' },
  { type: 'arrow', icon: <ArrowIcon />, label: 'Arrow' },
  { type: 'freehand', icon: <FreehandIcon />, label: 'Freehand' },
];

export function ToolButtons() {
  const { currentTool, setTool } = useAnnotationStore();
  const [showDrawMenu, setShowDrawMenu] = useState(false);
  const [menuPosition, setMenuPosition] = useState({ top: 0, left: 0 });
  const buttonRef = useRef<HTMLButtonElement>(null);

  // Update menu position when opening
  useEffect(() => {
    if (showDrawMenu && buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      setMenuPosition({
        top: rect.bottom + 4,
        left: rect.left,
      });
    }
  }, [showDrawMenu]);

  // Close menu handler
  const closeMenu = () => setShowDrawMenu(false);

  // Check if current tool is a draw tool
  const isDrawToolActive = DRAW_TOOLS.some((t) => t.type === currentTool);
  const activeDrawTool = DRAW_TOOLS.find((t) => t.type === currentTool);

  // Handle draw tool selection
  const handleDrawToolSelect = (tool: Tool) => {
    setTool(tool.type);
    setShowDrawMenu(false);
  };

  return (
    <div className="flex gap-1">
      {/* Select tool */}
      <button
        onClick={() => setTool('select')}
        className={`w-9 h-9 flex items-center justify-center rounded-xl text-base font-medium transition-all ${
          currentTool === 'select'
            ? 'glass-btn glass-btn-active text-orange-500'
            : 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
        }`}
        title="Select"
        aria-label="Select"
        aria-pressed={currentTool === 'select'}
      >
        <SelectIcon />
      </button>

      {/* Draw tools dropdown */}
      <div className="relative">
        <button
          ref={buttonRef}
          onClick={() => setShowDrawMenu(!showDrawMenu)}
          className={`h-9 px-2 flex items-center gap-1 rounded-xl text-base font-medium transition-all ${
            isDrawToolActive
              ? 'glass-btn glass-btn-active text-orange-500'
              : 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
          }`}
          title="Draw tools"
          aria-label="Draw tools"
          aria-expanded={showDrawMenu}
        >
          {activeDrawTool ? activeDrawTool.icon : <RectangleIcon />}
          <ChevronDownIcon />
        </button>

        {/* Dropdown menu - Using Portal to avoid overflow/transform issues */}
        {showDrawMenu && createPortal(
          <>
            <div
              className="fixed inset-0 z-[9998]"
              onClick={closeMenu}
            />
            <div
              className="fixed glass-heavy floating-panel rounded-xl p-1 z-[9999] min-w-[140px]"
              style={{
                top: menuPosition.top,
                left: menuPosition.left,
              }}
            >
              {DRAW_TOOLS.map((tool) => (
                <button
                  key={tool.type}
                  onClick={() => handleDrawToolSelect(tool)}
                  className={`w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-all ${
                    currentTool === tool.type
                      ? 'bg-orange-500/20 text-orange-500'
                      : 'text-gray-600 dark:text-gray-300 hover:bg-white/10'
                  }`}
                >
                  {tool.icon}
                  <span>{tool.label}</span>
                </button>
              ))}
            </div>
          </>,
          document.body
        )}
      </div>

      {/* Text tool */}
      <button
        onClick={() => setTool('text')}
        className={`w-9 h-9 flex items-center justify-center rounded-xl text-base font-medium transition-all ${
          currentTool === 'text'
            ? 'glass-btn glass-btn-active text-orange-500'
            : 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
        }`}
        title="Text"
        aria-label="Text"
        aria-pressed={currentTool === 'text'}
      >
        <TextIcon />
      </button>

      {/* Number tool */}
      <button
        onClick={() => setTool('number')}
        className={`w-9 h-9 flex items-center justify-center rounded-xl text-base font-medium transition-all ${
          currentTool === 'number'
            ? 'glass-btn glass-btn-active text-orange-500'
            : 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
        }`}
        title="Number"
        aria-label="Number"
        aria-pressed={currentTool === 'number'}
      >
        <NumberIcon />
      </button>

      {/* Spotlight tool */}
      <button
        onClick={() => setTool('spotlight')}
        className={`w-9 h-9 flex items-center justify-center rounded-xl text-base font-medium transition-all ${
          currentTool === 'spotlight'
            ? 'glass-btn glass-btn-active text-orange-500'
            : 'glass-btn text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white'
        }`}
        title="Spotlight"
        aria-label="Spotlight"
        aria-pressed={currentTool === 'spotlight'}
      >
        <SpotlightIcon />
      </button>
    </div>
  );
}
</file>

<file path="src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "beautiFULLshot",
  "version": "1.0.0",
  "identifier": "com.beautyfullshot.desktop",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "beautiFULLshot",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600,
        "resizable": true,
        "fullscreen": false,
        "decorations": true,
        "transparent": false,
        "center": true,
        "dragDropEnabled": false
      }
    ],
    "security": {
      "csp": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob: asset: https://asset.localhost https://images.unsplash.com; connect-src ipc: http://ipc.localhost http://tauri.localhost data: blob:"
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "category": "GraphicsAndDesign",
    "shortDescription": "Screenshot beautification app",
    "longDescription": "Capture, annotate, and beautify screenshots with gradient backgrounds and export options. Cross-platform support for Windows, macOS, and Linux.",
    "copyright": "2025 beautiFULLshot",
    "windows": {
      "nsis": {
        "displayLanguageSelector": true,
        "installerIcon": "icons/icon.ico"
      },
      "webviewInstallMode": {
        "type": "downloadBootstrapper"
      }
    },
    "macOS": {
      "minimumSystemVersion": "11.0",
      "entitlements": "entitlements.plist",
      "exceptionDomain": null,
      "signingIdentity": null
    },
    "linux": {
      "appimage": {
        "bundleMediaFramework": true
      },
      "deb": {
        "depends": [
          "libwebkit2gtk-4.1-0",
          "libgtk-3-0"
        ],
        "section": "graphics"
      },
      "rpm": {
        "epoch": 0
      }
    }
  }
}
</file>

<file path="src/hooks/use-hotkeys.ts">
// useHotkeys - Listen for global hotkeys and tray events from Tauri

import { useEffect, useCallback } from 'react';
import { listen } from '@tauri-apps/api/event';
import { getCurrentWindow } from '@tauri-apps/api/window';
import { useCanvasStore } from '../stores/canvas-store';
import { useCropStore } from '../stores/crop-store';
import { useUIStore } from '../stores/ui-store';
import * as screenshotApi from '../utils/screenshot-api';
import { logError } from '../utils/logger';
import type { CaptureRegion } from '../types/screenshot';

// Helper: Get image dimensions from bytes
function getImageDimensions(
  bytes: Uint8Array
): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const blob = new Blob([bytes], { type: 'image/png' });
    const url = URL.createObjectURL(blob);
    const img = new Image();

    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve({ width: img.width, height: img.height });
    };

    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };

    img.src = url;
  });
}

// Helper: Crop base64 image to specified region using Canvas
function cropBase64Image(
  base64Data: string,
  region: { x: number; y: number; width: number; height: number }
): Promise<Uint8Array | null> {
  return new Promise((resolve, reject) => {
    const img = new Image();

    img.onload = () => {
      try {
        // Create canvas with region dimensions
        const canvas = document.createElement('canvas');
        canvas.width = region.width;
        canvas.height = region.height;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Failed to get canvas context'));
          return;
        }

        // Draw cropped region onto canvas
        ctx.drawImage(
          img,
          region.x, region.y, region.width, region.height,  // Source region
          0, 0, region.width, region.height                  // Destination (full canvas)
        );

        // Convert canvas to PNG bytes
        canvas.toBlob((blob) => {
          if (blob) {
            blob.arrayBuffer().then((buffer) => {
              resolve(new Uint8Array(buffer));
            });
          } else {
            resolve(null);
          }
        }, 'image/png');
      } catch (e) {
        reject(e);
      }
    };

    img.onerror = () => {
      reject(new Error('Failed to load image for cropping'));
    };

    // Load image from base64
    img.src = `data:image/png;base64,${base64Data}`;
  });
}

/**
 * Hook that listens for global hotkeys and tray capture events
 * Triggers fullscreen capture when hotkey or tray menu is activated
 * Returns shortcut registration errors for UI display
 */
export function useHotkeys(): void {
  const { setImageFromBytes, fitToView } = useCanvasStore();
  const { clearCrop } = useCropStore();
  const { openWindowPicker } = useUIStore();

  // Capture fullscreen handler
  const handleCapture = useCallback(async () => {
    try {
      const bytes = await screenshotApi.captureFullscreenHidden();
      if (bytes) {
        const { width, height } = await getImageDimensions(bytes);
        clearCrop(); // Clear any existing crop when loading new image
        setImageFromBytes(bytes, width, height);
        // Auto-fit to view after capture
        setTimeout(() => fitToView(), 50);
      }
    } catch (e) {
      logError('useHotkeys:capture', e);
      // Emit permission error event if permission denied
      const errorMsg = e instanceof Error ? e.message : String(e);
      if (errorMsg.includes('permission')) {
        const appWindow = getCurrentWindow();
        appWindow.emit('permission-denied', {});
      }
    }
  }, [clearCrop, setImageFromBytes, fitToView]);

  // Capture region handler - opens fullscreen overlay for selection
  // Note: Window hiding and DWM sync is handled in Rust backend (overlay.rs)
  const handleCaptureRegion = useCallback(async () => {
    try {
      // Create fullscreen overlay window for region selection
      // Rust backend will:
      // 1. Hide main window
      // 2. Wait for DWM animation (Windows) or short delay (macOS/Linux)
      // 3. Capture screenshot
      // 4. Show overlay
      await screenshotApi.createOverlayWindow();
    } catch (e) {
      logError('useHotkeys:captureRegion', e);
      // Show main window again on error (likely permission denied)
      const appWindow = getCurrentWindow();
      await appWindow.show();
      await appWindow.setFocus();
      // Emit permission error event for App.tsx to handle
      const errorMsg = e instanceof Error ? e.message : String(e);
      if (errorMsg.includes('permission')) {
        appWindow.emit('permission-denied', {});
      }
    }
  }, []);

  // Capture window handler - shows app and opens window picker modal
  const handleCaptureWindow = useCallback(async () => {
    const appWindow = getCurrentWindow();
    await appWindow.show();
    await appWindow.setFocus();
    openWindowPicker();
  }, [openWindowPicker]);

  // Handle region selected from overlay
  // Uses stored screenshot data and crops to selection (instead of taking new screenshot)
  const handleRegionSelected = useCallback(async (region: CaptureRegion) => {
    try {
      // Get stored screenshot data (the same image shown in overlay)
      const screenshotBase64 = await screenshotApi.getScreenshotData();

      if (screenshotBase64) {
        // Crop the stored screenshot to the selected region using Canvas
        const croppedBytes = await cropBase64Image(screenshotBase64, region);
        if (croppedBytes) {
          const { width, height } = await getImageDimensions(croppedBytes);
          clearCrop();
          setImageFromBytes(croppedBytes, width, height);
          // Auto-fit to view after capture
          setTimeout(() => fitToView(), 50);
        }
      }

      // Clear stored screenshot data after extraction
      await screenshotApi.clearScreenshotData();
    } catch (e) {
      logError('useHotkeys:regionSelected', e);
    } finally {
      // Show main window again
      const appWindow = getCurrentWindow();
      await appWindow.show();
      appWindow.setFocus();
    }
  }, [clearCrop, setImageFromBytes, fitToView]);

  // Handle region selection cancelled
  const handleRegionCancelled = useCallback(async () => {
    // Show main window again
    const appWindow = getCurrentWindow();
    await appWindow.show();
    appWindow.setFocus();
  }, []);

  useEffect(() => {
    // Use variables to track unlisten functions for cleaner cleanup
    let unlistenTrayScreen: (() => void) | null = null;
    let unlistenTrayRegion: (() => void) | null = null;
    let unlistenTrayWindow: (() => void) | null = null;
    let unlistenHotkey: (() => void) | null = null;
    let unlistenHotkeyRegion: (() => void) | null = null;
    let unlistenHotkeyWindow: (() => void) | null = null;
    let unlistenRegionSelected: (() => void) | null = null;
    let unlistenRegionCancelled: (() => void) | null = null;

    // Listen for tray capture menu events
    listen('tray-capture-screen', () => handleCapture()).then((fn) => {
      unlistenTrayScreen = fn;
    });

    listen('tray-capture-region', () => handleCaptureRegion()).then((fn) => {
      unlistenTrayRegion = fn;
    });

    listen('tray-capture-window', () => handleCaptureWindow()).then((fn) => {
      unlistenTrayWindow = fn;
    });

    // Listen for global hotkey events
    listen('hotkey-capture', () => handleCapture()).then((fn) => {
      unlistenHotkey = fn;
    });

    listen('hotkey-capture-region', () => handleCaptureRegion()).then((fn) => {
      unlistenHotkeyRegion = fn;
    });

    listen('hotkey-capture-window', () => handleCaptureWindow()).then((fn) => {
      unlistenHotkeyWindow = fn;
    });

    // Listen for region selection events from overlay window
    listen<CaptureRegion>('region-selected', (event) => {
      handleRegionSelected(event.payload);
    }).then((fn) => {
      unlistenRegionSelected = fn;
    });

    listen('region-selection-cancelled', () => {
      handleRegionCancelled();
    }).then((fn) => {
      unlistenRegionCancelled = fn;
    });

    // Cleanup listeners on unmount
    return () => {
      unlistenTrayScreen?.();
      unlistenTrayRegion?.();
      unlistenTrayWindow?.();
      unlistenHotkey?.();
      unlistenHotkeyRegion?.();
      unlistenHotkeyWindow?.();
      unlistenRegionSelected?.();
      unlistenRegionCancelled?.();
    };
  }, [handleCapture, handleCaptureRegion, handleCaptureWindow, handleRegionSelected, handleRegionCancelled]);
}
</file>

<file path="src/App.tsx">
// App - Root application component
// Checks permissions on startup and blocks until both Screen Recording
// and Accessibility permissions are granted (macOS only)

import { useEffect, useState, useCallback } from "react";
import { getCurrentWindow } from "@tauri-apps/api/window";
import { invoke } from "@tauri-apps/api/core";
import { EditorLayout } from "./components/layout/editor-layout";
import { ToastContainer } from "./components/common/toast";
import { PermissionRequired } from "./components/permission-required";
import { useKeyboardShortcuts } from "./hooks/use-keyboard-shortcuts";
import { useHotkeys } from "./hooks/use-hotkeys";
import { useSyncShortcuts } from "./hooks/use-sync-shortcuts";
import { useSettingsStore } from "./stores/settings-store";
import { useToastStore } from "./stores/toast-store";
import type { ThemeMode } from "./stores/settings-store";

/** Determine if dark mode should be active based on theme setting */
function shouldUseDarkMode(theme: ThemeMode): boolean {
  if (theme === 'dark') return true;
  if (theme === 'light') return false;
  return window.matchMedia('(prefers-color-scheme: dark)').matches;
}

type AppState = 'checking' | 'permissions_required' | 'ready';

function App() {
  const { closeToTray, theme } = useSettingsStore();
  const { toasts, removeToast } = useToastStore();
  const [appState, setAppState] = useState<AppState>('checking');

  // Check permissions on startup
  useEffect(() => {
    async function checkStartupPermissions() {
      // Skip permission check in dev mode for faster iteration
      const isDev = import.meta.env.DEV;
      if (isDev) {
        console.log('[DEV] Bypassing permission check');
        setAppState('ready');
        return;
      }

      try {
        const [screenPermission, accessibilityPermission] = await Promise.all([
          invoke<boolean>('check_screen_permission'),
          invoke<boolean>('check_accessibility_permission'),
        ]);

        if (screenPermission && accessibilityPermission) {
          setAppState('ready');
        } else {
          setAppState('permissions_required');
        }
      } catch (error) {
        console.error('Failed to check permissions:', error);
        // On non-macOS or error, allow app to proceed
        setAppState('ready');
      }
    }

    checkStartupPermissions();
  }, []);

  // Callback when all permissions are granted
  const handlePermissionsGranted = useCallback(() => {
    setAppState('ready');
  }, []);

  // Initialize global keyboard shortcuts (in-app)
  useKeyboardShortcuts();

  // Sync hotkey settings with backend on startup
  useSyncShortcuts();

  // Initialize global hotkeys listener (system-wide from Tauri)
  useHotkeys();

  // Apply dark mode class to document
  useEffect(() => {
    const isDark = shouldUseDarkMode(theme);
    document.documentElement.classList.toggle('dark', isDark);

    if (theme === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      const handler = (e: MediaQueryListEvent) => {
        document.documentElement.classList.toggle('dark', e.matches);
      };
      mediaQuery.addEventListener('change', handler);
      return () => mediaQuery.removeEventListener('change', handler);
    }
  }, [theme]);

  // Handle window close - minimize to tray if enabled
  useEffect(() => {
    const appWindow = getCurrentWindow();

    const unlisten = appWindow.onCloseRequested(async (event) => {
      if (closeToTray) {
        event.preventDefault();
        await appWindow.hide();
      }
    });

    return () => {
      unlisten.then((fn) => fn());
    };
  }, [closeToTray]);

  // Show loading spinner while checking permissions
  if (appState === 'checking') {
    return (
      <div className="fixed inset-0 canvas-area flex items-center justify-center">
        <div className="glass floating-panel p-8 flex flex-col items-center gap-4">
          <div className="w-10 h-10 border-4 border-orange-500 border-t-transparent rounded-full animate-spin" />
          <span className="text-sm text-gray-600 dark:text-gray-300">Loading...</span>
        </div>
      </div>
    );
  }

  // Show permission screen if permissions not granted
  if (appState === 'permissions_required') {
    return <PermissionRequired onAllGranted={handlePermissionsGranted} />;
  }

  return (
    <>
      <EditorLayout />
      <ToastContainer toasts={toasts} onDismiss={removeToast} />
    </>
  );
}

export default App;
</file>

<file path="src/components/canvas/canvas-editor.tsx">
// CanvasEditor - Main canvas component with zoom/pan and annotation support

import { useRef, useEffect, useCallback, useMemo, useState } from 'react';
import { Stage, Layer, Image as KonvaImage, Group, Rect, Ellipse, Line, Arrow } from 'react-konva';
import Konva from 'konva';
import { useCanvasStore } from '../../stores/canvas-store';
import { useAnnotationStore } from '../../stores/annotation-store';
import { useBackgroundStore } from '../../stores/background-store';
import { useExportStore } from '../../stores/export-store';
import { useImage } from '../../hooks/use-image';
import { useDrawing } from '../../hooks/use-drawing';
import { ZOOM } from '../../constants/canvas';
import { calculateAspectRatioExtend } from '../../utils/export-utils';
import { AnnotationLayer } from './annotation-layer';
import { BackgroundLayer } from './background-layer';
import { CropOverlay } from './crop-overlay';
import { TextInputOverlay } from './text-input-overlay';
import { TextEditOverlay } from './text-edit-overlay';
import { ANNOTATION_DEFAULTS } from '../../constants/annotations';

export function CanvasEditor() {
  const stageRef = useRef<Konva.Stage>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const {
    imageUrl,
    originalWidth,
    originalHeight,
    stageWidth,
    stageHeight,
    scale,
    position,
    setStageRef,
    setStageSize,
    setScale,
    setPosition,
    initHistoryCallbacks,
  } = useCanvasStore();

  const { currentTool, strokeColor, fillColor, strokeWidth } = useAnnotationStore();
  const { getPaddingPx, shadowBlur, cornerRadius, borderWidth, borderColor, borderOpacity } = useBackgroundStore();
  const { outputAspectRatio } = useExportStore();
  const padding = getPaddingPx(originalWidth, originalHeight);
  const [image] = useImage(imageUrl || '');
  const {
    preview,
    textInputPos,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handleStageClick,
    submitText,
    cancelTextInput,
  } = useDrawing();

  // Track if dragging on empty area (not on annotation)
  // Use ref for immediate value (stage draggable) + state for cursor re-render
  const isDraggingRef = useRef(false);
  const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);


  // Calculate canvas dimensions with aspect ratio extension
  const baseCanvasWidth = originalWidth + padding * 2;
  const baseCanvasHeight = originalHeight + padding * 2;

  // Get extended dimensions based on output aspect ratio
  const aspectExtension = useMemo(() => {
    if (!originalWidth || !originalHeight) return null;
    return calculateAspectRatioExtend(baseCanvasWidth, baseCanvasHeight, outputAspectRatio);
  }, [baseCanvasWidth, baseCanvasHeight, outputAspectRatio, originalWidth, originalHeight]);

  // Final canvas dimensions (extended or base)
  const canvasWidth = aspectExtension?.width || baseCanvasWidth;
  const canvasHeight = aspectExtension?.height || baseCanvasHeight;

  // Offset for centering content when aspect ratio extends the canvas
  const contentOffsetX = aspectExtension?.offsetX || 0;
  const contentOffsetY = aspectExtension?.offsetY || 0;

  // Note: Stage draggable is controlled via Konva API in mouse handlers
  // to allow immediate response (React state is async)

  // Register stageRef in store for export panel access
  useEffect(() => {
    setStageRef(stageRef);
  }, [setStageRef]);

  // Initialize history callbacks for undo/redo of image state
  useEffect(() => {
    initHistoryCallbacks();
  }, [initHistoryCallbacks]);

  // Responsive resize
  useEffect(() => {
    const handleResize = () => {
      if (containerRef.current) {
        setStageSize(
          containerRef.current.offsetWidth,
          containerRef.current.offsetHeight
        );
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [setStageSize]);

  // Check if click target is an annotation or transformer
  const isAnnotationTarget = useCallback((target: Konva.Node | null): boolean => {
    if (!target) return false;

    // Stage itself is not an annotation
    if (target === stageRef.current) return false;

    // Walk up the parent chain to check if any node is draggable (annotation)
    // or is a Transformer anchor
    let node: Konva.Node | null = target;
    while (node && node !== stageRef.current) {
      // Check if it's a draggable shape (annotation) with an id
      if (node.draggable() && node.id()) {
        return true;
      }
      // Check for Transformer class name
      const className = node.getClassName();
      if (className === 'Transformer' || (className === 'Rect' && node.name()?.includes('anchor'))) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }, []);

  // Zoom with mouse wheel
  const handleWheel = useCallback(
    (e: Konva.KonvaEventObject<WheelEvent>) => {
      e.evt.preventDefault();

      const stage = stageRef.current;
      if (!stage) return;

      const oldScale = scale;
      const pointer = stage.getPointerPosition();
      if (!pointer) return;

      const mousePointTo = {
        x: (pointer.x - position.x) / oldScale,
        y: (pointer.y - position.y) / oldScale,
      };

      const direction = e.evt.deltaY > 0 ? -1 : 1;
      const newScale =
        direction > 0 ? oldScale * ZOOM.FACTOR : oldScale / ZOOM.FACTOR;

      const clampedScale = Math.max(
        ZOOM.MIN_SCALE,
        Math.min(ZOOM.MAX_SCALE, newScale)
      );

      setScale(clampedScale);
      setPosition(
        pointer.x - mousePointTo.x * clampedScale,
        pointer.y - mousePointTo.y * clampedScale
      );
    },
    [scale, position, setScale, setPosition]
  );

  // Handle stage mouse down - enable canvas drag if clicking empty area
  const handleStageMouseDown = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      const tool = useAnnotationStore.getState().currentTool;
      // Only in select mode
      if (tool !== 'select') {
        handleMouseDown(e);
        return;
      }

      // Check if clicking on annotation
      const clickedOnAnnotation = isAnnotationTarget(e.target);
      const shouldDragCanvas = !clickedOnAnnotation;

      // Set stage draggable immediately via Konva API
      const stage = stageRef.current;
      if (stage) {
        stage.draggable(shouldDragCanvas);
      }

      // Update ref and state
      isDraggingRef.current = shouldDragCanvas;
      setIsDraggingCanvas(shouldDragCanvas);

      // Still call the drawing handler
      handleMouseDown(e);
    },
    [isAnnotationTarget, handleMouseDown]
  );

  // Handle stage mouse up - disable canvas drag
  const handleStageMouseUp = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      // Disable stage draggable via Konva API
      const stage = stageRef.current;
      if (stage) {
        stage.draggable(false);
      }

      isDraggingRef.current = false;
      setIsDraggingCanvas(false);
      handleMouseUp(e);
    },
    [handleMouseUp]
  );

  // Pan with drag (only when draggable)
  const handleDragEnd = useCallback(
    (e: Konva.KonvaEventObject<DragEvent>) => {
      if (isDraggingRef.current) {
        setPosition(e.target.x(), e.target.y());
      }

      // Disable stage draggable via Konva API
      const stage = stageRef.current;
      if (stage) {
        stage.draggable(false);
      }

      isDraggingRef.current = false;
      setIsDraggingCanvas(false);
    },
    [setPosition]
  );

  // Cursor style based on current tool and drag state
  const getCursorStyle = () => {
    // Show grab cursor when dragging canvas
    if (isDraggingCanvas) return 'grabbing';
    if (currentTool === 'select') return 'default';
    if (currentTool === 'text') return 'text';
    return 'crosshair';
  };


  return (
    <div
      ref={containerRef}
      className="h-full w-full bg-gray-100 dark:bg-gray-800 overflow-hidden"
      style={{ cursor: getCursorStyle() }}
    >
      <Stage
        ref={stageRef}
        width={stageWidth}
        height={stageHeight}
        scaleX={scale}
        scaleY={scale}
        x={position.x}
        y={position.y}
        draggable={false}
        onWheel={handleWheel}
        onDragEnd={handleDragEnd}
        onMouseDown={handleStageMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleStageMouseUp}
        onClick={handleStageClick}
      >
        {/* Background layer - renders at full extended canvas size */}
        <Layer>
          <BackgroundLayer
            canvasWidth={canvasWidth}
            canvasHeight={canvasHeight}
          />
          {/* Content group - offset to center when aspect ratio extends canvas */}
          <Group x={contentOffsetX} y={contentOffsetY}>
            {image && (
              <Group>
                {/* Drop shadow layer - strong color, compact size */}
                {shadowBlur > 0 && (
                  <Rect
                    x={padding}
                    y={padding}
                    width={originalWidth}
                    height={originalHeight}
                    fill="#000"
                    cornerRadius={cornerRadius}
                    shadowColor="rgba(0, 0, 0, 1)"
                    shadowBlur={shadowBlur * 0.6}
                    shadowOffset={{ x: shadowBlur * 0.15, y: shadowBlur * 0.25 }}
                    shadowOpacity={1}
                    shadowEnabled={true}
                    listening={false}
                  />
                )}
                {/* Image */}
                <KonvaImage
                  image={image}
                  x={padding}
                  y={padding}
                  cornerRadius={cornerRadius}
                  listening={false}
                />
                {/* Border rect - drawn outside the image */}
                {borderWidth > 0 && (
                  <Rect
                    x={padding - borderWidth / 2}
                    y={padding - borderWidth / 2}
                    width={originalWidth + borderWidth}
                    height={originalHeight + borderWidth}
                    stroke={borderColor}
                    strokeWidth={borderWidth}
                    cornerRadius={cornerRadius + borderWidth / 2}
                    opacity={borderOpacity / 100}
                    listening={false}
                  />
                )}
              </Group>
            )}
          </Group>
        </Layer>
        {/* Annotation layer - also offset by aspect ratio extension */}
        <AnnotationLayer offsetX={contentOffsetX} offsetY={contentOffsetY} />
        <CropOverlay offsetX={contentOffsetX} offsetY={contentOffsetY} />
        {/* Drawing preview layer */}
        {preview && (
          <Layer>
            <Group x={contentOffsetX + padding} y={contentOffsetY + padding}>
              {preview.type === 'rectangle' && (
                <Rect
                  x={Math.min(preview.startX, preview.currentX)}
                  y={Math.min(preview.startY, preview.currentY)}
                  width={Math.abs(preview.currentX - preview.startX)}
                  height={Math.abs(preview.currentY - preview.startY)}
                  fill={fillColor}
                  stroke={strokeColor}
                  strokeWidth={strokeWidth}
                  dash={[5, 5]}
                  listening={false}
                />
              )}
              {preview.type === 'ellipse' && (
                <Ellipse
                  x={(preview.startX + preview.currentX) / 2}
                  y={(preview.startY + preview.currentY) / 2}
                  radiusX={Math.abs(preview.currentX - preview.startX) / 2}
                  radiusY={Math.abs(preview.currentY - preview.startY) / 2}
                  fill={fillColor}
                  stroke={strokeColor}
                  strokeWidth={strokeWidth}
                  dash={[5, 5]}
                  listening={false}
                />
              )}
              {preview.type === 'line' && (
                <Line
                  points={[preview.startX, preview.startY, preview.currentX, preview.currentY]}
                  stroke={strokeColor}
                  strokeWidth={strokeWidth}
                  dash={[5, 5]}
                  listening={false}
                />
              )}
              {preview.type === 'arrow' && (
                <Arrow
                  points={[preview.startX, preview.startY, preview.currentX, preview.currentY]}
                  stroke={strokeColor}
                  strokeWidth={strokeWidth}
                  pointerLength={ANNOTATION_DEFAULTS.ARROW.POINTER_LENGTH}
                  pointerWidth={ANNOTATION_DEFAULTS.ARROW.POINTER_WIDTH}
                  dash={[5, 5]}
                  listening={false}
                />
              )}
              {preview.type === 'freehand' && preview.points && (
                <Line
                  points={preview.points}
                  stroke={strokeColor}
                  strokeWidth={strokeWidth}
                  tension={0.5}
                  lineCap="round"
                  lineJoin="round"
                  listening={false}
                />
              )}
              {preview.type === 'spotlight' && (
                <Rect
                  x={Math.min(preview.startX, preview.currentX)}
                  y={Math.min(preview.startY, preview.currentY)}
                  width={Math.abs(preview.currentX - preview.startX)}
                  height={Math.abs(preview.currentY - preview.startY)}
                  fill="rgba(255,255,255,0.3)"
                  stroke="rgba(255,255,255,0.8)"
                  strokeWidth={2}
                  dash={[5, 5]}
                  listening={false}
                />
              )}
            </Group>
          </Layer>
        )}
      </Stage>
      {/* Text input overlay - positioned over canvas */}
      {textInputPos && (
        <TextInputOverlay
          position={textInputPos}
          scale={scale}
          onSubmit={submitText}
          onCancel={cancelTextInput}
        />
      )}
      {/* Text edit overlay - for editing existing text annotations */}
      <TextEditOverlay />
    </div>
  );
}
</file>

<file path="src/components/toolbar/toolbar.tsx">
// Toolbar - Main toolbar with capture, annotation tools, and settings

import { useState, useCallback } from 'react';
import { emit } from '@tauri-apps/api/event';
import { useScreenshot } from '../../hooks/use-screenshot';
import { useCanvasStore } from '../../stores/canvas-store';
import { useAnnotationStore } from '../../stores/annotation-store';
import { useCropStore } from '../../stores/crop-store';
import { useUIStore } from '../../stores/ui-store';
import { ToolButtons } from './tool-buttons';
import { ToolSettings } from './tool-settings';
import { UndoRedoButtons } from './undo-redo-buttons';
import { SettingsModal } from '../settings/settings-modal';
import { logError } from '../../utils/logger';

// Helper: Get image dimensions from bytes
function getImageDimensions(bytes: Uint8Array): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const blob = new Blob([bytes], { type: 'image/png' });
    const url = URL.createObjectURL(blob);
    const img = new Image();

    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve({ width: img.width, height: img.height });
    };

    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };

    img.src = url;
  });
}

export function Toolbar() {
  const { captureFullscreen, loading, error, waylandWarning } = useScreenshot();
  const { setImageFromBytes, clearCanvas, imageUrl, fitToView } = useCanvasStore();
  const { clearAnnotations } = useAnnotationStore();
  const { clearCrop } = useCropStore();
  const { openWindowPicker } = useUIStore();
  const [showSettings, setShowSettings] = useState(false);

  const handleCaptureFullscreen = useCallback(async () => {
    const bytes = await captureFullscreen();
    if (bytes) {
      try {
        const { width, height } = await getImageDimensions(bytes);
        clearCrop(); // Clear any existing crop when loading new image
        setImageFromBytes(bytes, width, height);
        // Auto-fit to view after capture
        setTimeout(() => fitToView(), 50);
      } catch (e) {
        logError('Toolbar:captureFullscreen', e);
      }
    }
  }, [captureFullscreen, clearCrop, setImageFromBytes, fitToView]);

  return (
    <div className="h-14 glass floating-panel flex items-center px-3 gap-2 overflow-visible">
      {/* Capture buttons group */}
      <div className="flex items-center gap-1.5 flex-shrink-0">
        {/* Capture fullscreen button */}
        <button
          onClick={handleCaptureFullscreen}
          disabled={loading}
          aria-label="Capture full screen screenshot"
          title="Capture Screen"
          className="h-10 px-3 flex items-center gap-1.5 glass-btn rounded-xl text-orange-500 hover:text-orange-600 disabled:opacity-50"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
          </svg>
          <span className="text-xs font-medium">Full</span>
        </button>

        {/* Region capture button */}
        <button
          onClick={() => emit('hotkey-capture-region')}
          disabled={loading}
          aria-label="Capture screen region"
          title="Capture Region"
          className="h-10 px-3 flex items-center gap-1.5 glass-btn rounded-xl text-orange-500 hover:text-orange-600 disabled:opacity-50"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 5a1 1 0 011-1h4a1 1 0 010 2H6v3a1 1 0 01-2 0V5zM20 5a1 1 0 00-1-1h-4a1 1 0 000 2h3v3a1 1 0 002 0V5zM4 19a1 1 0 001 1h4a1 1 0 000-2H6v-3a1 1 0 00-2 0v4zM20 19a1 1 0 01-1 1h-4a1 1 0 010-2h3v-3a1 1 0 012 0v4z" />
          </svg>
          <span className="text-xs font-medium">Region</span>
        </button>

        {/* Window capture button */}
        <button
          onClick={openWindowPicker}
          aria-label="Select window to capture"
          title="Capture Window"
          className="h-10 px-3 flex items-center gap-1.5 glass-btn rounded-xl text-orange-500 hover:text-orange-600"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z" />
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 9h16" />
          </svg>
          <span className="text-xs font-medium">Window</span>
        </button>
      </div>

      {/* Clear button */}
      {imageUrl && (
        <button
          onClick={() => {
            clearCanvas();
            clearAnnotations();
          }}
          aria-label="Clear current screenshot and annotations"
          className="px-4 py-2 glass-btn rounded-xl text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-white font-medium text-sm flex-shrink-0"
        >
          Clear
        </button>
      )}

      {/* Divider */}
      <div className="w-px h-7 bg-gray-300/50 dark:bg-gray-500/30 flex-shrink-0" />

      {/* Undo/Redo buttons */}
      <div className="flex-shrink-0">
        <UndoRedoButtons />
      </div>

      {/* Divider */}
      <div className="w-px h-7 bg-gray-300/50 dark:bg-gray-500/30 flex-shrink-0" />

      {/* Annotation Tools */}
      <div className="flex-shrink-0">
        <ToolButtons />
      </div>

      {/* Divider */}
      <div className="w-px h-7 bg-gray-300/50 dark:bg-gray-500/30 flex-shrink-0" />

      {/* Tool Settings */}
      <div className="flex-shrink-0">
        <ToolSettings />
      </div>

      {/* Error display */}
      {error && (
        <span role="alert" className="text-red-500 text-sm glass-flat px-2 py-1 rounded-lg">{error}</span>
      )}

      {/* Wayland warning */}
      {waylandWarning && (
        <span role="status" className="text-yellow-600 dark:text-yellow-400 text-sm glass-flat px-2 py-1 rounded-lg">{waylandWarning}</span>
      )}

      {/* Spacer */}
      <div className="flex-1" />

      {/* Settings button */}
      <button
        onClick={() => setShowSettings(true)}
        aria-label="Open settings"
        className="w-9 h-9 flex items-center justify-center glass-btn rounded-xl text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 flex-shrink-0"
        title="Settings"
      >
        <svg
          className="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
          />
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
          />
        </svg>
      </button>

      {/* Settings Modal */}
      <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} />
    </div>
  );
}
</file>

<file path="src-tauri/Cargo.toml">
[package]
name = "beautyfullshot"
version = "1.0.0"
description = "Cross-platform screenshot beautification app"
authors = ["dcppsw"]
edition = "2021"

[lib]
name = "beautyfullshot_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = ["tray-icon"] }
tauri-plugin-opener = "2"
tauri-plugin-global-shortcut = "2"
tauri-plugin-notification = "2"
xcap = "0.8.1"
image = "0.25"
dirs = "5.0"
tauri-plugin-dialog = "2"
tauri-plugin-clipboard-manager = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
base64 = "0.22"
arboard = "3.4"
tauri-plugin-process = "2.3.1"

[target.'cfg(target_os = "macos")'.dependencies]
macos-accessibility-client = "0.0.1"
core-graphics = "0.25"

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = ["Win32_Graphics_Dwm"] }
</file>

<file path="src-tauri/src/lib.rs">
// BeautyFullShot - Screenshot Beautification App
// Tauri commands: https://tauri.app/develop/calling-rust/

use std::sync::atomic::{AtomicBool, Ordering};
use tauri::{Manager, RunEvent, WindowEvent};

#[cfg(target_os = "macos")]
use tauri::menu::{MenuBuilder, MenuItemBuilder, PredefinedMenuItem, SubmenuBuilder};

/// Global flag to track if app should actually quit (from tray menu)
/// vs just hide to tray (from Cmd+Q or window close)
pub static SHOULD_QUIT: AtomicBool = AtomicBool::new(false);

mod clipboard;
mod file_ops;
mod overlay;
mod permissions;
mod screenshot;
mod shortcuts;
mod tray;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_global_shortcut::Builder::new().build())
        .plugin(tauri_plugin_notification::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_clipboard_manager::init())
        .plugin(tauri_plugin_process::init())
        .setup(|app| {
            // Create system tray
            tray::create_tray(app.handle())?;

            // On macOS, create custom app menu to override Cmd+Q behavior
            #[cfg(target_os = "macos")]
            {
                let handle = app.handle();

                // Create "Hide" menu item with Cmd+Q shortcut (replaces default Quit)
                let hide_item = MenuItemBuilder::with_id("hide_to_tray", "Hide to Tray")
                    .accelerator("CmdOrCtrl+Q")
                    .build(handle)?;

                // Create app submenu (first menu on macOS)
                let app_submenu = SubmenuBuilder::new(handle, "beautiFULLshot")
                    .item(&PredefinedMenuItem::about(handle, Some("About beautiFULLshot"), None)?)
                    .separator()
                    .item(&hide_item)
                    .separator()
                    .item(&PredefinedMenuItem::hide(handle, Some("Hide"))?)
                    .item(&PredefinedMenuItem::hide_others(handle, Some("Hide Others"))?)
                    .item(&PredefinedMenuItem::show_all(handle, Some("Show All"))?)
                    .build()?;

                // Create Edit submenu for standard text editing shortcuts
                let edit_submenu = SubmenuBuilder::new(handle, "Edit")
                    .item(&PredefinedMenuItem::undo(handle, Some("Undo"))?)
                    .item(&PredefinedMenuItem::redo(handle, Some("Redo"))?)
                    .separator()
                    .item(&PredefinedMenuItem::cut(handle, Some("Cut"))?)
                    .item(&PredefinedMenuItem::copy(handle, Some("Copy"))?)
                    .item(&PredefinedMenuItem::paste(handle, Some("Paste"))?)
                    .item(&PredefinedMenuItem::select_all(handle, Some("Select All"))?)
                    .build()?;

                // Create Window submenu
                let window_submenu = SubmenuBuilder::new(handle, "Window")
                    .item(&PredefinedMenuItem::minimize(handle, Some("Minimize"))?)
                    .item(&PredefinedMenuItem::maximize(handle, Some("Zoom"))?)
                    .separator()
                    .item(&PredefinedMenuItem::close_window(handle, Some("Close"))?)
                    .build()?;

                // Build and set the menu
                let menu = MenuBuilder::new(handle)
                    .item(&app_submenu)
                    .item(&edit_submenu)
                    .item(&window_submenu)
                    .build()?;

                app.set_menu(menu)?;

                // Handle custom menu events
                let handle_clone = handle.clone();
                app.on_menu_event(move |_app, event| {
                    if event.id().as_ref() == "hide_to_tray" {
                        // Hide window instead of quitting
                        if let Some(window) = handle_clone.get_webview_window("main") {
                            let _ = window.hide();
                        }
                        // Hide from dock
                        let _ = handle_clone.set_activation_policy(tauri::ActivationPolicy::Accessory);
                    }
                });
            }

            // Note: Overlay window is created on-demand when needed
            // to avoid fullscreen white screen at startup

            Ok(())
        })
        .on_window_event(|window, event| {
            // Intercept close request on main window - hide instead of quit
            if window.label() == "main" {
                if let WindowEvent::CloseRequested { api, .. } = event {
                    // Prevent default close behavior
                    api.prevent_close();
                    // Hide window instead
                    let _ = window.hide();

                    // On macOS, also hide from dock when window is hidden
                    #[cfg(target_os = "macos")]
                    {
                        let app = window.app_handle();
                        let _ = app.set_activation_policy(tauri::ActivationPolicy::Accessory);
                    }
                }
            }
        })
        .invoke_handler(tauri::generate_handler![
            screenshot::capture_fullscreen,
            screenshot::capture_region,
            screenshot::capture_window,
            screenshot::get_windows,
            screenshot::get_window_thumbnail,
            screenshot::get_monitors,
            permissions::check_screen_permission,
            permissions::check_accessibility_permission,
            permissions::request_accessibility_permission,
            permissions::request_screen_permission,
            permissions::check_wayland,
            permissions::open_screen_recording_settings,
            permissions::open_accessibility_settings,
            file_ops::save_file,
            file_ops::get_pictures_dir,
            file_ops::get_desktop_dir,
            shortcuts::update_shortcuts,
            overlay::create_overlay_window,
            overlay::close_overlay_window,
            overlay::get_screenshot_data,
            overlay::clear_screenshot_data,
            clipboard::copy_image_to_clipboard,
        ])
        .build(tauri::generate_context!())
        .expect("error while building tauri application")
        .run(|app, event| {
            match &event {
                // Handle Cmd+Q (macOS) - hide to tray instead of quit
                // Unless SHOULD_QUIT flag is set (from tray menu quit)
                #[cfg(target_os = "macos")]
                RunEvent::ExitRequested { api, .. } => {
                    // Check if we should actually quit (set by tray menu)
                    if SHOULD_QUIT.load(Ordering::SeqCst) {
                        // Allow exit - don't call prevent_exit()
                        return;
                    }

                    // Prevent app from quitting (hide to tray instead)
                    api.prevent_exit();

                    // Hide main window to tray
                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.hide();
                    }

                    // Hide from dock
                    let _ = app.set_activation_policy(tauri::ActivationPolicy::Accessory);
                }

                // Handle macOS dock click to reopen window
                #[cfg(target_os = "macos")]
                RunEvent::Reopen { .. } => {
                    // Restore dock icon
                    let _ = app.set_activation_policy(tauri::ActivationPolicy::Regular);

                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.show();
                        let _ = window.unminimize();
                        let _ = window.set_focus();
                    }
                }

                _ => {}
            }
        });
}
</file>

</files>
